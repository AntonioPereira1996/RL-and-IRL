#+TITLE: Utility functions that should be moved elsewhere

This file regroups utility functions used elsewhere in the code, whose implementation is quite straightforward.
* C utility functions
** Externals
  Count the number of lines in a text file
   #+begin_src c :tangle utils.h :main no
unsigned int nb_lines( char* fn );
   #+end_src
  
  Create a GSL matrix from a text file
   #+begin_src c :tangle utils.h :main no
gsl_matrix* file2matrix( char* fn, unsigned int col );
   #+end_src

  Return a random int in [min:max]
   #+begin_src c :tangle utils.h :main no
int random_int( int min, int max ); 
   #+end_src

  Return 0 with probability 0.9 and 1 with probability 0.1
   #+begin_src c :tangle utils.h :main no
int rand_1_in_10();
   #+end_src

  Return $||m1-m2||_2$ 
   #+begin_src c :tangle utils.h :main no
double diff_norm( gsl_matrix* m1, gsl_matrix* m2 );
   #+end_src

** Internals
  
  #+begin_src c :tangle utils.c :main no
#include <stdio.h>
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_blas.h>
#include <stdlib.h>

/* Count the number of lines in a text file */
unsigned int nb_lines( char* fn ){
  unsigned int answer = 0;
  char str[1024];
  FILE* f = fopen( fn, "r" );
  while( fscanf( f, "%[^\n]", str ) != EOF ){
    answer++;
    fscanf( f, "\n" );
  }
  fclose( f );
  return answer;
}

/* Create a gsl matrix from a text file */
gsl_matrix* file2matrix( char* fn, unsigned int col ){
  unsigned int l = nb_lines( fn );
  gsl_matrix* answer = gsl_matrix_alloc( l, col );
  FILE* f = fopen( fn, "r" );
  gsl_matrix_fscanf( f, answer );
  fclose( f );
  return answer;
}

/* Return an int chosen randomly in [min:max] */
int random_int( int min, int max ){
  return rand()%(max-min+1) + min;
}

/* Return 0 w.p. 0.9 and 1 w.p. 0.1 */
int rand_1_in_10(){
  if( (double)rand() > (double)RAND_MAX*0.1 ){
    return 0;
  }
  return 1;
}

/* ||m1-m2||_2 */
double diff_norm( gsl_matrix* m1, gsl_matrix* m2 ){
  gsl_vector_view v1 = gsl_matrix_column( m1, 0 );
  gsl_vector_view v2 = gsl_matrix_column( m2, 0 );
  gsl_vector* diff = gsl_vector_calloc( m1->size1 );
  gsl_vector_memcpy( diff, &v1.vector );
  gsl_vector_sub( diff, &v2.vector );
  double answer = gsl_blas_dnrm2( diff );
  gsl_vector_free( diff );
  return answer;
}
  #+end_src

* Python utility functions
  We need the matrices to be output so that two equal matrices are output the same way.

  #+begin_src python :tangle a2str.py
#Do not indent
def l2str_fullprecision(l):
	"""Return a string representing line l without loss of precision"""
	answer = ""
	for x in l:
		answer+="%e\t"%x
	answer +="\n"
	return answer

def l2str(l):
	"""Return the unique string representing line l"""
	answer = ""
	for x in l:
		if (abs(x)<1e-10): #FIXME : this is not right.
			answer += " 0.00e+00\t"
		elif (x>0):
			answer += " %1.2e\t"%x
		else:
			answer += "%+1.2e\t"%x
	answer +="\n"
	return answer
		
        
def a2str(a):
	"""Return the unique string representing array a"""
	answer = ""
	for l in a:
		answer += l2str( l )
	return answer


  #+end_src

  We output values near 0 as 0. Instead we probably should understand why there are so much near-0 values in the normal output. I think it has to do with the linear system solver.
* Makefile rules
  Tangling : 
  #+srcname: utils_code_make
  #+begin_src makefile
utils.c: utils.org 
	$(call tangle,"utils.org")

utils.h: utils.org
	$(call tangle,"utils.org")

a2str.py: utils.org
	$(call tangle,"utils.org")
  #+end_src

   A rule to create the object file :
  #+srcname: utils_c2o_make
  #+begin_src makefile
utils.o: utils.c utils.h
	$(call c2obj,"utils.c")
  #+end_src
   A rule to clean the mess :
  #+srcname: utils_clean_make
  #+begin_src makefile
utils_clean:
	find . -maxdepth 1 -iname "utils.h"   | xargs -t rm
	find . -maxdepth 1 -iname "utils.c"   | xargs -t rm 
	find . -maxdepth 1 -iname "utils.o"   | xargs -t rm
	find . -maxdepth 1 -iname "a2str.py"   | xargs -t rm
  #+end_src
