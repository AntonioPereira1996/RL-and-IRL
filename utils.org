#+TITLE: Utility functions that should be moved elsewhere

This file regroups utility functions used elsewhere in the code, whose implementation is quite straightforward.
* C utility functions
** Externals
  Count the number of lines in a text file
   #+begin_src c :tangle utils.h :main no
unsigned int nb_lines( char* fn );
   #+end_src
  
  Create a GSL matrix from a text file
   #+begin_src c :tangle utils.h :main no
gsl_matrix* file2matrix( char* fn, unsigned int col );
   #+end_src

  Save a GSL matrix to a text file
   #+begin_src c :tangle utils.h :main no
int matrix2file( char* fn, gsl_matrix* m);
   #+end_src


  Return a random int in [min:max]
   #+begin_src c :tangle utils.h :main no
int random_int( int min, int max ); 
   #+end_src

  Return 0 with probability 0.9 and 1 with probability 0.1
   #+begin_src c :tangle utils.h :main no
int rand_1_in_10();
   #+end_src

  Return $||m1-m2||_2$ 
   #+begin_src c :tangle utils.h :main no
double diff_norm( gsl_matrix* m1, gsl_matrix* m2 );
   #+end_src

** Internals
  
  #+begin_src c :tangle utils.c :main no
#include <stdio.h>
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_blas.h>
#include <stdlib.h>

/* Count the number of lines in a text file */
unsigned int nb_lines( char* fn ){
  unsigned int answer = 0;
  char str[1024];
  FILE* f = fopen( fn, "r" );
  while( fscanf( f, "%[^\n]", str ) != EOF ){
    answer++;
    fscanf( f, "\n" );
  }
  fclose( f );
  return answer;
}

/* Create a gsl matrix from a text file */
gsl_matrix* file2matrix( char* fn, unsigned int col ){
  unsigned int l = nb_lines( fn );
  gsl_matrix* answer = gsl_matrix_alloc( l, col );
  FILE* f = fopen( fn, "r" );
  gsl_matrix_fscanf( f, answer );
  fclose( f );
  return answer;
}

/* Save a gsl matrix to a text file */
int matrix2file( char* fn , gsl_matrix* m){
  FILE* f = fopen( fn, "w" );
  for( int i = 0 ; i < m->size1 ; i++ ){
    for( int j = 0 ; j < m->size2 ; j++ ){
      fprintf( f, "%e ", gsl_matrix_get( m, i, j ) );
    }
    fprintf( f, "\n" );
  }
  fclose( f );
  return 0;
}

/* Return an int chosen randomly in [min:max] */
int random_int( int min, int max ){
  return rand()%(max-min+1) + min;
}

/* Return 0 w.p. 0.9 and 1 w.p. 0.1 */
int rand_1_in_10(){
  if( (double)rand() > (double)RAND_MAX*0.1 ){
    return 0;
  }
  return 1;
}

/* ||m1-m2||_2 */
double diff_norm( gsl_matrix* m1, gsl_matrix* m2 ){
  gsl_vector_view v1 = gsl_matrix_column( m1, 0 );
  gsl_vector_view v2 = gsl_matrix_column( m2, 0 );
  gsl_vector* diff = gsl_vector_calloc( m1->size1 );
  gsl_vector_memcpy( diff, &v1.vector );
  gsl_vector_sub( diff, &v2.vector );
  double answer = gsl_blas_dnrm2( diff );
  gsl_vector_free( diff );
  return answer;
}

  #+end_src

* Python utility functions
** a2str
  We need the matrices to be output so that two equal matrices are output the same way.

  #+begin_src python :tangle a2str.py
#Do not indent
def l2str_fullprecision(l):
	"""Return a string representing line l without loss of precision"""
	answer = ""
	for x in l:
		answer+="%e\t"%x
	answer +="\n"
	return answer

def l2str(l):
	"""Return the unique string representing line l"""
	answer = ""
	for x in l:
		if (abs(x)<1e-10): #FIXME : this is not right.
			answer += " 0.00e+00\t"
		elif (x>0):
			answer += " %1.2e\t"%x
		else:
			answer += "%+1.2e\t"%x
	answer +="\n"
	return answer
		
        
def a2str(a):
	"""Return the unique string representing array a"""
	answer = ""
	for l in a:
		answer += l2str( l )
	return answer


  #+end_src

  We output values near 0 as 0. Instead we probably should understand why there are so much near-0 values in the normal output. I think it has to do with the linear system solver.

** Plot
  Some code used to plot mean, min and maxes
  #+begin_src python :tangle Plot.py
from numpy import *
import scipy
import pylab as pylab


def mean_min_max( D ):
    "Returns the abscissa, mean, min and max value for each abscissa in matrix D. D follows format : [[x,y],...,[x,y]]"
    X = unique(D[:,0])
    #Yes, it is unreadable.
    Y_min = map(min,map( lambda d_x: map( lambda d_xi:d_xi[1],d_x),[filter(lambda a:a[0]==x,D) for x in X]))
    Y_max = map(max,map( lambda d_x: map( lambda d_xi:d_xi[1],d_x),[filter(lambda a:a[0]==x,D) for x in X]))
    Y_mean = map(mean,map( lambda d_x: map( lambda d_xi:d_xi[1],d_x),[filter(lambda a:a[0]==x,D) for x in X]))
    return [X,Y_mean,Y_min,Y_max]

def naive_variance(data):
    n = 0
    Sum = 0
    Sum_sqr = 0 
    for x in data:
        n = n + 1
        Sum = Sum + x
        Sum_sqr = Sum_sqr + x*x
    mean = Sum/n
    variance = (Sum_sqr - Sum*mean)/(n - 1)
    return variance


def mean_var( D ):
    "Returns the abscissa, mean, and variance values for each abscissa in matrix D. D follows format : [[x,y],...,[x,y]]"
    X = unique(D[:,0])
    #Yes, it is unreadable
    Y_mean = map(mean,map( lambda d_x: map( lambda d_xi:d_xi[1],d_x),[filter(lambda a:a[0]==x,D) for x in X]))
    Y_var = map(lambda a: sqrt(naive_variance(a)),map( lambda d_x: map( lambda d_xi:d_xi[1],d_x),[filter(lambda a:a[0]==x,D) for x in X]))
    return [X,Y_mean,Y_var]

def filled_mean_min_max( p, X, Y_mean, Y_min, Y_max, color, _alpha, style, lblmain,lblminmax ):
    "Plot data, with bold mean line, and a light color fill betwee the min and max"
    if lblmain == None:
        p.plot( X, Y_mean,color=color,lw=2)
    else:
        p.plot( X, Y_mean,color=color,lw=2, label=lblmain)
    if lblminmax == None:
        p.plot( X, Y_min, color=color,lw=1,linestyle=style)
    else:
        p.plot( X, Y_min, color=color,lw=1,linestyle=style, label=lblminmax)
    p.plot( X, Y_max, color=color,lw=1,linestyle=style)
    p.fill_between(X,Y_min,Y_max,facecolor=color,alpha=_alpha)

class Plot:
    Random_mean = None
    Random_min = None
    Random_var = None
    Random_max = None
    Expert = None
    ymin = None
    ymax = None

    def __init__( self ):
        pass
    def plot( self, D, color, filename ):
        [X,Y_mean,Y_min,Y_max] = map( array, mean_min_max( D ))
        [X,Y_mean,Y_var] = map( array, mean_var( D ))
        pylab.figure(1)
        pylab.clf()
        x_min = min(X)
        x_max = max(X)
        y_max = self.ymax if self.ymax else mint(max( self.Expert, max( Y_max + Y_var) ))+1
        y_min = self.ymin if self.ymin else int(min( self.Random_min,min(Y_min - Y_var) ) - 1)
        pylab.axis([x_min,x_max,y_min,y_max])
        pylab.xlabel('Number of samples from the expert')
        pylab.ylabel('$\mathbf{E}_{s\sim\mathcal{U}}[V^{\pi}_{\mathcal{R}_E}(s)]$')
        pylab.grid(True)
        filled_mean_min_max( pylab, X, Y_mean, Y_min, Y_max, color, 0.2,'--',None,None)
        filled_mean_min_max( pylab, X, Y_mean, Y_mean - Y_var, Y_mean + Y_var, color, 0.4,'-.',None,None)
        filled_mean_min_max( pylab, X, self.Random_mean*ones(X.shape), self.Random_min*ones(X.shape), self.Random_max*ones(X.shape), 'cyan',0.2,'--',"Agent trained on a random reward",None)
        filled_mean_min_max( pylab, X, self.Random_mean*ones(X.shape), (self.Random_mean-self.Random_var)*ones(X.shape), (self.Random_mean+self.Random_var)*ones(X.shape), 'cyan',0.4,'-.',None,None)
        pylab.plot(X,self.Expert*ones(X.shape), color='cyan',label="Expert",lw=2,ls=':')
        pylab.savefig(filename,transparent=True)

  #+end_src
** Random Wighted Choice  
#+begin_src python :tangle RWC.py
#code from http://stackoverflow.com/questions/3679694/a-weighted-version-of-random-choice
import random

def weighted_choice(choices):
   total = sum(w for c,w in choices)
   r = random.uniform(0, total)
   upto = 0
   for c, w in choices:
      if upto+w > r:
         return c
      upto += w
   assert False, "Shouldn't get here"

#+end_src
* Makefile rules
  Tangling : 
  #+srcname: utils_code_make
  #+begin_src makefile
utils.c: utils.org 
	$(call tangle,"utils.org")

utils.h: utils.org
	$(call tangle,"utils.org")

a2str.py: utils.org
	$(call tangle,"utils.org")
Plot.py: utils.org
	$(call tangle,"utils.org")
  #+end_src

   A rule to create the object file :
  #+srcname: utils_c2o_make
  #+begin_src makefile
utils.o: utils.c utils.h
	$(call c2obj,"utils.c")
  #+end_src
   A rule to clean the mess :
  #+srcname: utils_clean_make
  #+begin_src makefile
utils_clean:
	find . -maxdepth 1 -iname "utils.h"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "utils.c"   | xargs $(XARGS_OPT) rm 
	find . -maxdepth 1 -iname "utils.o"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "a2str.py"   | xargs $(XARGS_OPT) rm
  #+end_src
