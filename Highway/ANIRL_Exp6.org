#+TITLE:Highway, ANIRL, Dégradé

Cette expérience s'inscrit dans une démarche de test plus grande : [[file:../Protocoles.org]]. 

On récupère, comme prévu dans le protocole, les valeurs des paramètres d'ANIRL trouvées dans le cas parfait ([[file:ANIRL_Exp5.org]]). A savoir : $\epsilon_{ANIRL} = 0.03$ et $T_{ANIRL} = 70$.

* Test de LSPI
LSPI étant la routine utilisée par ANIRL pour résoudre le MDP, il convient de voir si elle parvient effectivement à résoudre le problème.

** Génération de trajectoires aléatoires
#+begin_src python :tangle ANIRL_Exp6_D.py
import Highway
from numpy import *
import scipy

trans = Highway.random_play( 600, 10 )
savetxt( "ANIRL_Exp6_D.mat", trans, "%d", " " )

#+end_src
   #+srcname: ANIRL_Exp6_make
   #+begin_src makefile
ANIRL_Exp6_D.py: ANIRL_Exp6.org
	$(call tangle,"ANIRL_Exp6.org")
ANIRL_Exp6_D.mat: ANIRL_Exp6_D.py Highway.py ../DP.py
	python ANIRL_Exp6_D.py

   #+end_src

** LSPI et évaluation du resultat
  #+begin_src c :tangle ANIRL_Exp6_LSPI.c :main no
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_blas.h>
#include <math.h>
#include "LSPI.h"
#include "../RL_Globals.h"
#include "utils.h"

#include "phipsi.h"


#define ACTION_FILE "actions.mat"
unsigned int g_iS = 4; /*State space dimension*/
unsigned int g_iA = 1; /*Action space dimension*/
double g_dGamma_lstdq =  0.9; /*Discount factor*/
double g_dEpsilon_lspi = 0.03; /*Halt criterion*/
gsl_matrix* g_mOmega = NULL; //Omega
gsl_matrix* (*g_fPhi)(gsl_matrix*) = &phi; //\phi
gsl_matrix* g_mActions = NULL; //All actions, one per line
unsigned int g_iIt_max_lspi = 20;
double g_dLambda_lstdQ = 0.1;

int main( void ){
  gsl_matrix* omega_0 = gsl_matrix_calloc( g_iK, 1 );
  g_mActions = file2matrix( ACTION_FILE, g_iA );
  gsl_matrix* D = file2matrix( "ANIRL_Exp6_D.mat", 4+1+4+1+1 );
  gsl_matrix* omega = lspi( D, omega_0 );
  matrix2file( "ANIRL_Exp6_omega_LSPI.mat", omega );
  gsl_matrix_free( omega );
  gsl_matrix_free( D );
printf("Entrainement sur beaucoup de données\n");
  system( "python PlayOmega2.py ANIRL_Exp6_omega_LSPI.mat" );
  #+end_src

On regarde maintenant ce que ça donne avec en entrée les trajectoires de l'expert (beaucoup moins nombreuses) :

  #+begin_src c :tangle ANIRL_Exp6_LSPI.c :main no
D = file2matrix( "SCIRL_Exp3_DE.mat", 4+1+4+1+1 );
 omega = lspi( D, omega_0 );
  matrix2file( "ANIRL_Exp6_omega_LSPI.mat", omega );
  gsl_matrix_free( omega );
  gsl_matrix_free( D );
  gsl_matrix_free( omega_0 );
printf("Entraînement sur les données de l'expert\n");
  system( "python PlayOmega2.py ANIRL_Exp6_omega_LSPI.mat" );
}

#+end_src
   #+srcname: ANIRL_Exp6_make
   #+begin_src makefile
../LSPI.h:
	make -C .. LSPI.h
../LSTDQ.h:
	make -C .. LSTDQ.h
../LSPI.o:
	make -C .. LSPI.o
../LSTDQ.o:
	make -C .. LSTDQ.o
../LSTDmu.o:
	make -C .. LSTDmu.o
../LSTDmu.h:
	make -C .. LSTDmu.h

actions.mat: ANIRL_Exp6.org
	$(call tangle,"ANIRL_Exp6.org")
ANIRL_Exp6_LSPI.c: ANIRL_Exp6.org
	$(call tangle,"ANIRL_Exp6.org")

ANIRL_Exp6_LSPI.o: ANIRL_Exp6_LSPI.c ../greedy.h ../RL_Globals.h ../utils.h  phipsi.h ../LSPI.h ../LSTDQ.h
	$(call c2obj,"ANIRL_Exp6_LSPI.c")
ANIRL_Exp6_LSPI.exe: ANIRL_Exp6_LSPI.o ../greedy.o ../utils.o  phipsi.o ../LSPI.o ../LSTDQ.o 
	$(O2EXE) -o ANIRL_Exp6_LSPI.exe ANIRL_Exp6_LSPI.o ../greedy.o ../utils.o  phipsi.o ../LSPI.o ../LSTDQ.o

ANIRL_Exp6_LSPI: ANIRL_Exp6_LSPI.exe ANIRL_Exp6_D.mat actions.mat ../DP_mu.py SCIRL_Exp3_DE.mat
	./ANIRL_Exp6_LSPI.exe

   #+end_src

Le résultat n'est pas aussi bon, mais ça laisse espérer qu'ANIRL fonctionne comme il faut.

* Expérience

Il ne reste enfin plus qu'à utiliser ces données pour faire tourner ANIRL.
#+begin_src c :tangle ANIRL_Exp6.c :main no
#define _POSIX_C_SOURCE 1
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_blas.h>
#include <math.h>
#include "utils.h"
#include "LSPI.h"
#include "ANIRL.h"
#include "LSTDmu.h"
#include "greedy.h"
#include "phipsi.h"

#include "RL_Globals.h"
#include "IRL_Globals.h"
#define TRANS_WIDTH 4+1+4+1+1
#define ACTION_FILE "actions.mat"

unsigned int g_iNb_samples = -1;
unsigned int g_iS = 4;
unsigned int g_iA = 1;
unsigned int g_iIt_max_lspi = 20;
gsl_matrix* (*g_fPhi)(gsl_matrix*) = &phi;
gsl_matrix* g_mOmega = NULL;
double g_dLambda_lstdQ = 0.1;
double g_dGamma_lstdq =  0.9;
double g_dEpsilon_lspi = 0.1;
double g_dLambda_lstdmu = 0.1;
double g_dGamma_anirl = 0.9;
double g_dEpsilon_anirl = 0.03;
unsigned int g_iIt_max_anirl = 70;
gsl_matrix* g_mActions = NULL; 
gsl_matrix* (*g_fPsi)(gsl_matrix*) = &psi;
gsl_matrix* D_E = NULL;
gsl_matrix* D_mu = NULL;
gsl_matrix* (*g_fSimulator)(int) = NULL;

//FIXME: Useless but defined anyway in order to compile
unsigned int M = -1; //M_{MCip}
double g_dGamma_lafem = -1;
#+end_src

Les sous routines utilisées pour ANIRL sont :
 - LSTD$\mu$ pour le calcul des /feature expectations/ :
   #+begin_src c :tangle ANIRL_Exp6.c :main no
gsl_matrix* S_0(){
  gsl_matrix* s_0 = gsl_matrix_alloc( 1, 4 );
  gsl_matrix_set( s_0, 0, 0, 1 );
  gsl_matrix_set( s_0, 0, 1, 2 );
  gsl_matrix_set( s_0, 0, 2, 2 );
  gsl_matrix_set( s_0, 0, 3, 1 );
  return s_0;
}

gsl_matrix* mu_pi(gsl_matrix* omega){
  g_mOmega = omega;
  return lstd_mu( D_mu, &greedy_policy );
}

gsl_matrix* mu_E(){
  return lstd_mu_op( D_mu );
}

gsl_matrix* (*g_fS_0)(void) = &S_0;
gsl_matrix* (*g_fMu_pi)(gsl_matrix*) = &mu_pi;
gsl_matrix* (*g_fMu_E)() = &mu_E;

   #+end_src
 - LSPI en tant que solveur de MDP :
   #+begin_src c :tangle ANIRL_Exp6.c :main no
gsl_matrix* lspi_wrapper(gsl_matrix* theta){
  for( unsigned int i = 0 ; i < D_E->size1 ; i++ ){
    gsl_matrix_view state = 
      gsl_matrix_submatrix( D_E, i, 0, 1, g_iS );
    gsl_matrix* psi_s = g_fPsi( &state.matrix );
    gsl_matrix_view r = 
      gsl_matrix_submatrix( D_E, i, 2*g_iS+g_iA, 1, 1 );
    gsl_blas_dgemm( CblasTrans, CblasNoTrans, 1.0, 
		    theta, psi_s, 0.0, &r.matrix );
    gsl_matrix_free( psi_s );
    }
  gsl_matrix* omega_0 = gsl_matrix_calloc( g_iK, 1 );
  gsl_matrix* omega = lspi( D_E, omega_0 );
  gsl_matrix_free( omega_0 );
  return omega;
}

gsl_matrix* (*g_fMDP_solver)(gsl_matrix*) = &lspi_wrapper;
   #+end_src



#+begin_src c :tangle ANIRL_Exp6.c :main no
int main( int argc, char** argv ){
  g_mActions = file2matrix( ACTION_FILE, g_iA );
  D_E = file2matrix( argv[1], TRANS_WIDTH );
  D_mu = gsl_matrix_alloc( D_E->size1, g_iS + g_iA + g_iS + g_iP + 1 );

  for( int i = 0; i < D_E->size1 ; i++ ){
    gsl_matrix_view vsasdash_src = gsl_matrix_submatrix( D_E, i, 0, 1, g_iS + g_iA + g_iS );
    gsl_matrix_view vsasdash_dst = gsl_matrix_submatrix( D_mu, i, 0,
							 1, g_iS + g_iA + g_iS );
    gsl_matrix_memcpy( &(vsasdash_dst.matrix), &(vsasdash_src.matrix) );
    
    gsl_matrix_view vs = gsl_matrix_submatrix( D_E, i, 0, 1, g_iS );
    gsl_matrix* psi_s = g_fPsi( &(vs.matrix) );
    gsl_matrix_view vpsi_s = gsl_matrix_submatrix( D_mu, i, g_iS + g_iA + g_iS, 1, g_iP );
    gsl_matrix_transpose_memcpy( &(vpsi_s.matrix), psi_s );
    gsl_matrix_free( psi_s );

    gsl_matrix_view eoe_src = gsl_matrix_submatrix( D_E, i, g_iS + g_iA + g_iS + 1,
						    1, 1 );
    gsl_matrix_view eoe_dst = gsl_matrix_submatrix( D_mu, i, g_iS + g_iA + g_iS + g_iP,
						    1, 1 );
    gsl_matrix_memcpy( &(eoe_dst.matrix), &(eoe_src.matrix) );    
  }

#+end_src

On lance ANIRL :
#+begin_src c :tangle ANIRL_Exp6.c :main no
    gsl_matrix* omega_agent =proj_ANIRL();
#+end_src

Puis on vérifie que le contrôle obtenu tient la route :
#+begin_src c :tangle ANIRL_Exp6.c :main no
  matrix2file( "ANIRL_Exp6_omega_agent.mat", omega_agent );
  printf("%d ",D_E->size1);
  fflush(NULL);
  return system( "python EvaluateOmega.py ANIRL_Exp6_omega_agent.mat" );
}


#+end_src

   #+srcname: ANIRL_Exp6_make
   #+begin_src makefile
../abbeel2004apprenticeship.o:
	make -C .. abbeel2004apprenticeship.o

ANIRL_Exp6.c: ANIRL_Exp6.org
	$(call tangle,"ANIRL_Exp6.org")
ANIRL_Exp6.o: ANIRL_Exp6.c ../greedy.h ../RL_Globals.h ../utils.h  phipsi.h ../LSTDmu.h ../IRL_Globals.h ../ANIRL.h ../LSPI.h
	$(call c2obj,"ANIRL_Exp6.c")
#FIXME: On ne devrait pas avoir à lier avec criteria.o ou abbeel2004apprenticeship.o
ANIRL_Exp6.exe: ANIRL_Exp6.o ../greedy.o ../utils.o  phipsi.o ../LSTDmu.o ../ANIRL.o ../LSPI.o ../LSTDQ.o ../abbeel2004apprenticeship.o ../criteria.o ../DP_mu.py
	$(O2EXE) -o ANIRL_Exp6.exe ANIRL_Exp6.o ../greedy.o ../utils.o  phipsi.o ../LSTDmu.o ../ANIRL.o ../LSPI.o ../LSTDQ.o ../abbeel2004apprenticeship.o ../criteria.o

../criteria.o:
	make -C .. criteria.o

ANIRL_Exp6: ANIRL_Exp6.exe EvaluateOmega.py DE.py
	for i in $(LM_VALUES); \
	do \
	python DE.py $$i > DE.mat; \
        ./ANIRL_Exp6.exe DE.mat >> ANIRL_Exp6.mat; \
	done

   #+end_src


  #+srcname: ANIRL_Exp6_clean_make
  #+begin_src makefile
ANIRL_Exp6_clean:
	find . -maxdepth 1 -iname "ANIRL_Exp6.h"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "ANIRL_Exp6.c"   | xargs $(XARGS_OPT) rm 
	find . -maxdepth 1 -iname "ANIRL_Exp6.o"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "ANIRL_Exp6.exe"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "ANIRL_Exp6.tex"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "ANIRL_Exp6.pdf"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "ANIRL_Exp6_*"   | xargs $(XARGS_OPT) rm

  #+end_src


