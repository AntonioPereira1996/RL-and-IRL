#+TITLE: Cascading IRL on the Highway


We will need data from the expert. We can use what was done in SCIRL_Exp3.

* With true features
#+begin_src python :tangle Cascading_Exp1.py
import sys
sys.path+=['..']
from numpy import *
import scipy
from DP import *
from DP_mu import *
import Cascading
import Highway

D_E = genfromtxt( "SCIRL_Exp3_DE.mat" )
Data = map( lambda trans: [trans[0:4],trans[4:5][0]], D_E ) 
theta_E,theta_C = Cascading.run( Data, Highway.psi, Highway.phi, Highway.A )

#+end_src

Policies corresponding to these rewards are computed :
     #+begin_src python :tangle Cascading_Exp1.py
print "Agent_E creation..."
Pi_E = DP_txt( theta_E, [Highway.P(a) for a in Highway.A], "Cascading_Exp1_V_agentE.mat" )#FIXME, Pi_E c'est super foireux comme notation
print "Agent_C creation..."
Pi_C = DP_txt( theta_C, [Highway.P(a) for a in Highway.A], "Cascading_Exp1_V_agentC.mat" )
     #+end_src
And evaluated  ($\theta^T\mu_\pi(s_0)$)
     #+begin_src python :tangle Cascading_Exp1.py
Mu_E = genfromtxt( "Mu_E.mat" )
perf_expert = dot( Highway.R().transpose() , ( Mu_E[ Highway.s_index( Highway.S_0() )]).transpose() )
print "mu_piE computation..."
Mu_piE = DP_mu( Pi_E, identity( 3*9*9*3 ))
print "mu_piC computation..."
Mu_piC = DP_mu( Pi_C, identity( 3*9*9*3 ))
perf_agentE = dot( Highway.R().transpose() , ( Mu_piE[ Highway.s_index( Highway.S_0() )]).transpose() )
perf_agentC = dot( Highway.R().transpose() , ( Mu_piC[ Highway.s_index( Highway.S_0() )]).transpose() )

print "Performance moyenne de l'expert : "
print perf_expert

print "Performance moyenne de l'agent E :"
print perf_agentE

print "Performance moyenne de l'agent C :"
print perf_agentC

     #+end_src


#+srcname: Cascading_Exp1_make
#+begin_src makefile
Cascading_Exp1.py: Cascading_Exp1.org
	$(call tangle,"Cascading_Exp1.org")

Cascading_Exp1: Cascading_Exp1.py Highway.py ../DP.py Mu_E.mat ../Cascading.py ../LAFEM.py SCIRL_Exp3_DE.mat
	python Cascading_Exp1.py

../Cascading.py:
	make -C .. Cascading.py

#+end_src

* With LSPI informative features
#+begin_src python :tangle Cascading_Exp1b.py
import sys
sys.path+=['..']
from numpy import *
import scipy
from DP import *
from DP_mu import *
import Cascading
import Highway

D_E = genfromtxt( "SCIRL_Exp3_DE.mat" )
Data = map( lambda trans: [trans[0:4],trans[4:5][0]], D_E ) 
theta_E,theta_C = Cascading.run( Data, Highway.psi2, Highway.phi2, Highway.A )

#+end_src

Policies corresponding to these rewards are computed :
     #+begin_src python :tangle Cascading_Exp1b.py
R_E = zeros( Highway.R().shape )
R_C = zeros( R_E.shape )

for s in Highway.Sgenerator():
    index = Highway.s_index( s )
    R_E[ index ] = dot( theta_E.transpose(), Highway.psi2( s ) )
    R_C[ index ] = dot( theta_C.transpose(), Highway.psi2( s ) )


print "Agent_E creation..."
Pi_E = DP_txt( R_E, [Highway.P(a) for a in Highway.A], "Cascading_Exp1_V_agentE.mat" )#FIXME, Pi_E c'est super foireux comme notation
print "Agent_C creation..."
Pi_C = DP_txt( R_C, [Highway.P(a) for a in Highway.A], "Cascading_Exp1_V_agentC.mat" )

     #+end_src
And evaluated  ($\theta^T\mu_\pi(s_0)$)
     #+begin_src python :tangle Cascading_Exp1b.py
Mu_E = genfromtxt( "Mu_E.mat" )
perf_expert = dot( Highway.R().transpose() , ( Mu_E[ Highway.s_index( Highway.S_0() )]).transpose() )
print "mu_piE computation..."
Mu_piE = DP_mu( Pi_E, identity( 3*9*9*3 ))
print "mu_piC computation..."
Mu_piC = DP_mu( Pi_C, identity( 3*9*9*3 ))
perf_agentE = dot( Highway.R().transpose() , ( Mu_piE[ Highway.s_index( Highway.S_0() )]).transpose() )
perf_agentC = dot( Highway.R().transpose() , ( Mu_piC[ Highway.s_index( Highway.S_0() )]).transpose() )

print "Performance moyenne de l'expert : "
print perf_expert

print "Performance moyenne de l'agent E :"
print perf_agentE

print "Performance moyenne de l'agent C :"
print perf_agentC

     #+end_src


#+srcname: Cascading_Exp1_make
#+begin_src makefile
Cascading_Exp1b.py: Cascading_Exp1.org
	$(call tangle,"Cascading_Exp1.org")

Cascading_Exp1b: Cascading_Exp1b.py Highway.py ../DP.py Mu_E.mat ../Cascading.py ../LAFEM.py SCIRL_Exp3_DE.mat
	python Cascading_Exp1b.py

#+end_src


* Stuff
  #+srcname: Cascading_Exp1_clean_make
  #+begin_src makefile
Cascading_Exp1_clean:
	find . -maxdepth 1 -iname "Cascading_Exp1.py"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "Cascading_Exp1.tex"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "Cascading_Exp1_*"   | xargs $(XARGS_OPT) rm

  #+end_src
