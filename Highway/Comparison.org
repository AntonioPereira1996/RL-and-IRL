#+TITLE:Comparaison entre quelques algorithmes d'imitation

Utilisons ici les résultats obtenus dans [[file:MWAL.org]] et [[file:SCIRL.org]] à des fins de comparaison.

La valeur qui nous importe est celle de la fonction de valeur dans l'état initial, $V(s_0)$, relativement à la vraie fonction de récompense. Nous effectuons ce calcul grâce à la formule : $V(s_0) = \theta^T\mu(s_0)$, et nous estimons $\mu(s_0)$ grâce à une estimation de Monte-Carlo.

#+begin_src python :tangle ComparativeResults.py
from numpy import*
import sys


Fast_R = genfromtxt( "al_code/fast_reward.mat" )
Safe_R = genfromtxt( "al_code/safe_reward.mat" )

Fast_mu = genfromtxt( "PlayFast_mu_"+sys.argv[1]+".mat" )
Safe_mu = genfromtxt( "PlaySafe_mu_"+sys.argv[1]+".mat" )

Fast_mu_mwal = genfromtxt( "PlayFast_mwal_mu_"+sys.argv[1]+".mat" )
Safe_mu_mwal = genfromtxt( "PlaySafe_mwal_mu_"+sys.argv[1]+".mat" )

Fast_mu_scirl = genfromtxt( "PlayFast_scirl_mu_"+sys.argv[1]+".mat" )
Safe_mu_scirl = genfromtxt( "PlaySafe_scirl_mu_"+sys.argv[1]+".mat" )

Fast_true_V = dot(Fast_R, Fast_mu)
Fast_mwal_V = dot(Fast_R, Fast_mu_mwal)
Fast_scirl_V = dot(Fast_R, Fast_mu_scirl)

Safe_true_V = dot(Safe_R, Safe_mu)
Safe_mwal_V = dot(Safe_R, Safe_mu_mwal)
Safe_scirl_V = dot(Safe_R, Safe_mu_scirl)



print "Fast driving :"
print "True V(s_0) : " + str( Fast_true_V )
print "MWAL V(s_0) : " + str( Fast_mwal_V )
print "SCIRL V(s_0) : " + str( Fast_scirl_V )
print
print "Safe driving :"
print "True V(s_0) : " + str( Safe_true_V )
print "MWAL V(s_0) : " + str( Safe_mwal_V )
print "SCIRL V(s_0) : " + str( Safe_scirl_V )

f_Fast_true = open( "FastResults_true.mat", "w" ) #The last to be written i.e. the one with
f_Safe_true = open( "SafeResults_true.mat", "w" ) #the most samples will overwrite the others (see the makefile rules)
f_Fast_true.write("%e\n"% Fast_true_V ) #No abscissa we want a flat line
f_Safe_true.write("%e\n"% Safe_true_V )
f_Fast_true.close()
f_Safe_true.close()

f_Fast_scirl = open( "FastResults_scirl.mat", "a" )
f_Fast_mwal = open( "FastResults_mwal.mat", "a" )
f_Safe_scirl = open( "SafeResults_scirl.mat", "a" )
f_Safe_mwal = open( "SafeResults_mwal.mat", "a" )

f_Fast_scirl.write(sys.argv[1]+" %e\n"% Fast_scirl_V )
f_Fast_mwal.write(sys.argv[1]+" %e\n"% Fast_mwal_V )
f_Safe_scirl.write(sys.argv[1]+" %e\n"% Safe_scirl_V )
f_Safe_mwal.write(sys.argv[1]+" %e\n"% Safe_mwal_V )

f_Fast_scirl.close()
f_Fast_mwal.close()
f_Safe_scirl.close()
f_Safe_mwal.close()
#+end_src

#+srcname: Comparison_make
#+begin_src makefile
ComparativeResults.py: Comparison.org
	$(call tangle,"Comparison.org")

FastResults_scirl.mat: ComparativeResults.py PlayFast_scirl_mu_X.mat PlaySafe_scirl_mu_X.mat PlayFast_mwal_mu_X.mat PlaySafe_mwal_mu_X.mat PlayFast_mu_X.mat PlaySafe_mu_X.mat al_code/fast_reward.mat al_code/safe_reward.mat
	touch FastResults_scirl.mat
	rm FastResults_scirl.mat
	for i in $(N_VALUES); do python ComparativeResults.py $$i; done

FastResults_mwal.mat: ComparativeResults.py PlayFast_scirl_mu_X.mat PlaySafe_scirl_mu_X.mat PlayFast_mwal_mu_X.mat PlaySafe_mwal_mu_X.mat PlayFast_mu_X.mat PlaySafe_mu_X.mat al_code/fast_reward.mat al_code/safe_reward.mat
	touch FastResults_mwal.mat
	rm FastResults_mwal.mat
	for i in $(N_VALUES); do python ComparativeResults.py $$i; done

SafeResults_scirl.mat: ComparativeResults.py PlayFast_scirl_mu_X.mat PlaySafe_scirl_mu_X.mat PlayFast_mwal_mu_X.mat PlaySafe_mwal_mu_X.mat PlayFast_mu_X.mat PlaySafe_mu_X.mat al_code/fast_reward.mat al_code/safe_reward.mat
	touch SafeResults_scirl.mat
	rm SafeResults_scirl.mat
	for i in $(N_VALUES); do python ComparativeResults.py $$i; done

SafeResults_mwal.mat: ComparativeResults.py PlayFast_scirl_mu_X.mat PlaySafe_scirl_mu_X.mat PlayFast_mwal_mu_X.mat PlaySafe_mwal_mu_X.mat PlayFast_mu_X.mat PlaySafe_mu_X.mat al_code/fast_reward.mat al_code/safe_reward.mat
	touch SafeResults_mwal.mat
	rm SafeResults_mwal.mat
	for i in $(N_VALUES); do python ComparativeResults.py $$i; done


#+end_src


Une fois cette valeur calculée, il est possible de la plotter.

Nous allons calculer plusieurs fois l'estimation de Monte-Carlo de la valeur afin d'obtenir des barres d'erreur.
The first thing to do is to define a clean rule to remove the file to plot and all the other files that have been used to create it, so that making it again will be a statistically independant experiment.
  #+srcname: Comparison_make
  #+begin_src makefile
clean_EB:
	find . -maxdepth 1 -iname "PlayFast_SCIRL_*.dat" | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "PlayFast_SCIRL_stripped_*.dat" | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "PlayFast_scirl_mu_*.mat" | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "PlayFast_mwal_*.dat" | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "PlayFast_mwal_stripped_*.dat" | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "PlayFast_mwal_mu_*.mat" | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "FastResults_*.mat" | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "PlaySafe_SCIRL_*.dat" | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "PlaySafe_SCIRL_stripped_*.dat" | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "PlaySafe_scirl_mu_*.mat" | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "PlaySafe_mwal_*.dat" | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "PlaySafe_mwal_stripped_*.dat" | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "PlaySafe_mwal_mu_*.mat" | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "SafeResults_*.mat" | xargs $(XARGS_OPT) rm

clean_FastResults_scirl.mat: clean_EB
clean_FastResults_mwal.mat: clean_EB
clean_SafeResults_scirl.mat: clean_EB
clean_SafeResults_mwal.mat: clean_EB

clean_SafeResults.mat: 

  #+end_src

  #+begin_src python :tangle Comparison_conf.py
g_nlInput = ['FastResults_scirl.mat', ['-d" " -f\'1 2\''], [],
             'FastResults_mwal.mat', ['-d" " -f\'1 2\''], [],
             'SafeResults_scirl.mat', ['-d" " -f\'1 2\''], [],
             'SafeResults_mwal.mat', ['-d" " -f\'1 2\''], []]
g_iN = 2

  #+end_src

  #+srcname: Comparison_make
  #+begin_src makefile
Comparison_conf.py: Comparison.org 
	$(call tangle,"Comparison.org")

Comparison_ErrorBars: Comparison_conf.py FastResults_scirl.mat
	mv Comparison_conf.py conf.py
	../../Utils/ErrorBars.py
	rm conf.py

  #+end_src

Les fichiers ainsi obtenus, =[Fast|Safe]Results_[scirl|mwal}.mat-0= permettent de tracer deux jolies courbes comparatives.


  #+begin_src gnuplot :tangle FastResults_EB.gp
set output "FastResults_EB.ps"
set term postscript enhanced color
set xrange [0:330]
set yrange [0.02:0.04]
set ylabel "Performance"
set ylabel "Number of samples from the expert"
plot "./FastResults_scirl.mat-0" u 1:2 w lines ls 1 notitle, "./FastResults_scirl.mat-0" u 1:2:3 w errorbars ls 1 title "SCIRL", "./FastResults_mwal.mat-0" u 1:2 w lines ls 2 notitle, "./FastResults_mwal.mat-0" u 1:2:3 w errorbars ls 2 title "MWAL", "FastResults_true.mat" w lines ls 3 title "Expert"

#+end_src

#+begin_src gnuplot :tangle SafeResults_EB.gp
set output "SafeResults_EB.ps"
set term postscript enhanced color
set xrange [0:330]
set yrange [0.01:0.03]
set ylabel "Performance"
set ylabel "Number of samples from the expert"
plot "./SafeResults_scirl.mat-0" u 1:2 w lines ls 1 notitle, "./SafeResults_scirl.mat-0" u 1:2:3 w errorbars ls 1 title "SCIRL", "./SafeResults_mwal.mat-0" u 1:2 w lines ls 2 notitle, "./SafeResults_mwal.mat-0" u 1:2:3 w errorbars ls 2 title "MWAL", "SafeResults_true.mat" w lines ls 3 title "Expert"

#+end_src

  #+srcname: Comparison_make
  #+begin_src makefile
FastResults_EB.gp: Comparison.org
	$(call tangle,"Comparison.org")

FastResults_EB.pdf: FastResults_EB.gp Comparison_ErrorBars
	gnuplot FastResults_EB.gp
	ps2pdf FastResults_EB.ps
	rm FastResults_EB.ps

SafeResults_EB.gp: Comparison.org
	$(call tangle,"Comparison.org")

SafeResults_EB.pdf: SafeResults_EB.gp Comparison_ErrorBars
	gnuplot SafeResults_EB.gp
	ps2pdf SafeResults_EB.ps
	rm SafeResults_EB.ps

  #+end_src


