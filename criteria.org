#+TITLE: Different criteria for assessing the quality of the imitation in IRL algorithms

* Different criteria
** True feature expectation difference
  The "true" (i.e. not approximated) difference between the feature expectation of the expert and the one for the current policy : $||\mu_E-\mu||_2$, computed via a monte-carlo so big the variance is negligible. expert_just_set() must be called before this function.

   #+begin_src c :tangle criteria.h :main no
double true_diff_norm( gsl_matrix* omega );
   #+end_src

  The following helper function must be called after the global variable g_mOmega_E is set, so that its feature expectation and V(s_0) can be computed

   #+begin_src c :tangle criteria.h :main no
void expert_just_set();
   #+end_src
  
  This one must be called if expert_just_set has been called before, in order to free the memory.

   #+begin_src c :tangle criteria.h :main no
void expert_free();
   #+end_src

** Value function
  Compute V(s0) for the given set of trajectories $D$.
   #+begin_src c :tangle criteria.h :main no
double value_func( gsl_matrix* D );
   #+end_src
** Value function difference
  $|V^E(s_0)-V^\pi(s_0)|$ for the current policy, it is an objective measurement for task transfer. Computed via a big monte_carlo.
*/
   #+begin_src c :tangle criteria.h :main no
double true_V_diff( gsl_matrix* omega );
   #+end_src

* Implementation
  The implementation is straightforward.
  
  We use the GSL, its BLAS interface and some of the neighbouring code.
   #+begin_src c :tangle criteria.c :main no
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_blas.h>
#include <math.h>
#include "RL_Globals.h"
#include "IRL_Globals.h"
#include "abbeel2004apprenticeship.h"
#include "utils.h"
#include "criteria.h"
   #+end_src

  This parameter is a trade-off between computation time and closeness to the truth
   #+begin_src c :tangle criteria.c :main no
#define PERFECT_MC_LENGTH 2000
   #+end_src

  We declare some gobal variables, some of them are present in [[file:IRL_Globals.org]] : 
  - Public global where the omega of the expert is stored
    #+begin_src c :tangle criteria.c :main no
gsl_matrix* g_mOmega_E = NULL;
    #+end_src
  - Private variable where the feature expectation of the expert is stored
     #+begin_src c :tangle criteria.c :main no
gsl_matrix* g_mMu_E = NULL;
     #+end_src
  - Private variable where V_E(s_0) is stored
    #+begin_src c :tangle criteria.c :main no
double g_dV_E = -1;
    #+end_src
 
 We now implment the different criteria.
   #+begin_src c :tangle criteria.c :main no
double true_diff_norm( gsl_matrix* omega ){
  g_mOmega = omega;
  unsigned int nb_samples_backup = g_iNb_samples;
  gsl_matrix* D = g_fSimulator( PERFECT_MC_LENGTH );
  g_iNb_samples = nb_samples_backup;
  gsl_matrix* mu = monte_carlo_mu( D );
  double norm = diff_norm( mu, g_mMu_E );
  gsl_matrix_free( mu );
  gsl_matrix_free( D );
  return norm;
}

void expert_just_set(){
  unsigned int nb_samples_backup = g_iNb_samples;
  g_mOmega = g_mOmega_E;
  gsl_matrix* D = g_fSimulator( PERFECT_MC_LENGTH );
  g_iNb_samples = nb_samples_backup;
  g_mMu_E = monte_carlo_mu( D );
  g_dV_E = value_func( D );
  gsl_matrix_free( D );
}

void expert_free(){
  gsl_matrix_free( g_mMu_E );
}
   #+end_src

   #+begin_src c :tangle criteria.c :main no
double value_func( gsl_matrix* D ){
  double answer = 0;
  double gamma_t = 1;
  unsigned int nb_episodes = 0;
  for( unsigned int i = 0; i<D->size1; i++ ){
    double r = gsl_matrix_get( D, i, D->size2-2 );
    double eoe = gsl_matrix_get( D, i, D->size2-1 );
    answer += gamma_t*r;
    if( (int)eoe == 1 ){
      gamma_t *= g_dGamma_lstdq;
    }else{
      gamma_t = 1;
      nb_episodes++;
    }
  }
  return answer/(double)nb_episodes;
}
   #+end_src
 
  #+begin_src c :tangle criteria.c :main no
double true_V_diff( gsl_matrix* omega ){
  g_mOmega = omega;
  unsigned int nb_samples_backup = g_iNb_samples;
  gsl_matrix* D = g_fSimulator( PERFECT_MC_LENGTH );
  g_iNb_samples = nb_samples_backup;
  double V_pi = value_func( D );
  double answer = fabs(g_dV_E - V_pi);
  gsl_matrix_free( D );
  return answer;  
}
   #+end_src


* Makefile rules
   Some rules to tangle the source files :
  #+srcname: criteria_code_make
  #+begin_src makefile
criteria.c: criteria.org 
	$(call tangle,"criteria.org")

criteria.h: criteria.org
	$(call tangle,"criteria.org")
  #+end_src

   A rule to create the object file :
   #+srcname: criteria_c2o_make
  #+begin_src makefile
criteria.o: criteria.c criteria.h LSTDQ.h utils.h RL_Globals.h IRL_Globals.h abbeel2004apprenticeship.h
	$(call c2obj,"criteria.c")
  #+end_src

   A rule to clean the mess :
  #+srcname: criteria_clean_make
  #+begin_src makefile
criteria_clean:
	find . -maxdepth 1 -iname "criteria.h"   | xargs -t rm
	find . -maxdepth 1 -iname "criteria.c"   | xargs -t rm 
	find . -maxdepth 1 -iname "criteria.o"   | xargs -t rm
  #+end_src
