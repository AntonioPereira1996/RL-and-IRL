#+TITLE:ANIRL, Pendule, Parfait

Cette expérience s'inscrit dans ne démarche de test plus grande : [[file:../Protocoles.org]]. On va essayer de faire tourner ANIRL sur le pendule.\\

Grâce à l'expérience ayant permi de fixer la longueur du Monte-Carlo ([[file:MCLength.org]]), on sait que la norme 2 de $\mu_E(s_0)$ est à peu près 20. On fixe donc $\epsilon_{ANIRL}$ à $0.2$ comme nous l'avions prévu dans le protocole. Pour passer sous ce seuil, parfois deux itérations suffisent, parfois il en faut jusqu'à 10. On fixe donc le nombre d'itération maximum à 100, comme prévu par le protocole.\\

L'expérience est un succès puisque l'agent parvient systématiquement à balancer le pendule 3000 pas de temps. Pour lancer l'expérience : make ANIRL_Exp1 dans le dossier racine.\\

FIXME: Factoriser ce code

On entraîne l'expert :
#+begin_src c :tangle ANIRL_Exp1.c :main no
#define _POSIX_C_SOURCE 1
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_blas.h>
#include <math.h>
#include "InvertedPendulum.h"
#include "simulator.h"
#include "utils.h"
#include "LSPI.h"
#include "abbeel2004apprenticeship.h"
#include "criteria.h"
#include "greedy.h"
#include "phipsi.h"

#include "RL_Globals.h"
#include "IRL_Globals.h"
#define D_FILE_NAME "Samples.dat"
#define TRANS_WIDTH 7
#define ACTION_FILE "actions.mat"

unsigned int g_iS = 2;
unsigned int g_iA = 1;
unsigned int g_iIt_max_lspi = 50;
gsl_matrix* (*g_fPhi)(gsl_matrix*) = &phi;
gsl_matrix* g_mOmega = NULL;
double g_dLambda_lstdQ = 0.1;
double g_dGamma_lstdq =  0.9;
double g_dEpsilon_lspi = 0.01;
double g_dLambda_lstdmu = 0.1;
double g_dGamma_anirl = 0.9;
double g_dEpsilon_anirl = 0.2;
unsigned int g_iIt_max_anirl = 100;
gsl_matrix* g_mActions = NULL; 
gsl_matrix* (*g_fPsi)(gsl_matrix*) = &psi;
gsl_matrix* (*g_fSimulator)(int) = &inverted_pendulum_simulator;
gsl_matrix* (*g_fS_0)(void) = NULL;
//L_{MCip}
unsigned int g_iMax_episode_len = 30;
unsigned int M = 1; //M_{MCip}

//FIXME: Useless but defined anyway in order to compile
double g_dGamma_lafem = -1;
unsigned int g_iNb_episodes = -1;
int main( void ){
  fprintf(stderr,"Training the expert...");
  fflush( NULL );
  gsl_matrix* D = file2matrix( D_FILE_NAME, TRANS_WIDTH );
  g_mActions = file2matrix( ACTION_FILE, g_iA );
  gsl_matrix* omega_0 = gsl_matrix_calloc( g_iK, 1 );
  gsl_matrix* omega_expert = lspi( D, omega_0 );
  g_mOmega = omega_expert;
  g_mOmega_E = omega_expert;
  expert_just_set();
  fprintf(stderr,"done\n");
#+end_src

On génère les données de l'expert :
#+begin_src c :tangle ANIRL_Exp1.c :main no
    gsl_matrix* D_E = inverted_pendulum_simulator( M );
#+end_src

On lance ANIRL dans sa version Monte-Carlo :
#+begin_src c :tangle ANIRL_Exp1.c :main no
    gsl_matrix* omega_mc =
      proj_mc_lspi_ANIRL( D_E, D, 1 );
#+end_src

Puis on vérifie que le contrôle obtenu tient la route :
#+begin_src c :tangle ANIRL_Exp1.c :main no
  g_mOmega = omega_mc;
  g_iMax_episode_len = 3000;
  gsl_matrix* D_agent = inverted_pendulum_simulator( 1 );
  printf("Longueur du run de l'agent : %d\n",D_agent->size1);
  if( D_agent->size1 != 3000 ){
    return 1;
  }
  return 0;
}
#+end_src

Tout cela se compile de la sorte :
#+srcname: ANIRL_Exp1_make
#+begin_src makefile
ANIRL_Exp1.c: ANIRL_Exp1.org InvertedPendulum.h simulator.h ../utils.h ../LSPI.h ../abbeel2004apprenticeship.h ../criteria.h ../greedy.h phipsi.h ../RL_Globals.h ../IRL_Globals.h
	$(call tangle,"ANIRL_Exp1.org")
ANIRL_Exp1.o: ANIRL_Exp1.c
	$(call c2obj,"ANIRL_Exp1.c")
ANIRL_Exp1.exe: ANIRL_Exp1.o ../LSPI.o phipsi.o ../greedy.o ../LSTDQ.o ../abbeel2004apprenticeship.o simulator.o ../utils.o ../criteria.o InvertedPendulum.o
	$(O2EXE) -o ANIRL_Exp1.exe ANIRL_Exp1.o ../LSPI.o phipsi.o ../greedy.o ../LSTDQ.o ../abbeel2004apprenticeship.o ../utils.o simulator.o ../criteria.o InvertedPendulum.o

ANIRL_Exp1: ANIRL_Exp1.exe Samples.dat
	./ANIRL_Exp1.exe
#+end_src

  #+srcname: ANIRL_Exp1_clean_make
  #+begin_src makefile
ANIRL_Exp1_clean:
	find . -maxdepth 1 -iname "ANIRL_Exp1.h"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "ANIRL_Exp1.c"   | xargs $(XARGS_OPT) rm 
	find . -maxdepth 1 -iname "ANIRL_Exp1.o"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "ANIRL_Exp1.exe"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "ANIRL_Exp1.tex"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "ANIRL_Exp1.pdf"   | xargs $(XARGS_OPT) rm
  #+end_src
