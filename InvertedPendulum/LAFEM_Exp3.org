#+TITLE: SCIRL, Pendule, Dégradé

On reprend une expérience précédente pour l'intégrer dans le [[file:../Protocoles.org]].

* Code								       :code:
** Experiment targets
*** Computing $\hat\mu_E$
    We use the LSTD$\mu$ C code to get the $\omega_{\pi_E}$ matrix so that :  $\mu_E(s,a) = \omega^T_{\pi_E}\phi(s,a)$
#+begin_src c :tangle LAFEM_Exp3_LSTDmu.c :main no
#define _POSIX_C_SOURCE 1
#include <gsl/gsl_matrix.h>
#include <math.h>
#include "InvertedPendulum.h"
#include "utils.h"
#include "greedy.h"
#include "phipsi.h"
#include "RL_Globals.h"
#include "IRL_Globals.h"
#include "LSTDmu.h"

#define TRANS_WIDTH 7
#define ACTION_FILE "actions.mat"

unsigned int g_iS = 2;
unsigned int g_iA = 1;
gsl_matrix* g_mOmega = NULL;
gsl_matrix* g_mActions = NULL;
double g_dLambda_lstdmu = 0.1;
double g_dGamma_anirl = 0.9;//FIXME: Ill named. Should be something like g_dGamma_lstdmu
//I suspect it is used also in the monte carlo, hence the name when ANIRL was the only
//implemented IRL algorithm
gsl_matrix* (*g_fPsi)(gsl_matrix*) = psi;
gsl_matrix* (*g_fPhi)(gsl_matrix*) = phi;


//Defined but not used (needed in LSTDmu.o when linking) :
double g_dEpsilon_anirl = -1;
unsigned int g_iIt_max_anirl = -1;
double g_dGamma_lafem = -1;
gsl_matrix* (*g_fS_0)( void ) = NULL;
double g_dBest_error = -1;
double true_diff_norm = -1;
double g_dBest_true_error = -1;
double g_dBest_diff = -1;
gsl_matrix* g_mBest_omega = NULL;
double true_V_diff = -1;
double g_dBest_t = -1;
//dummy lspi
gsl_matrix* lspi(gsl_matrix* D, gsl_matrix* omega){
return NULL;
}


int main( void ){
  g_mOmega = file2matrix( "omega_expert.mat", 1 );
  g_mActions = file2matrix( ACTION_FILE, g_iA );
  gsl_matrix* D = file2matrix( "D_expert.mat", TRANS_WIDTH );

  gsl_matrix* D_mu = gsl_matrix_alloc( D->size1, g_iS + g_iA + g_iS + g_iP + 1 );

  for( int i = 0; i < D->size1 ; i++ ){
    gsl_matrix_view vsasdash_src = gsl_matrix_submatrix( D, i, 0, 1, g_iS + g_iA + g_iS );
    gsl_matrix_view vsasdash_dst = gsl_matrix_submatrix( D_mu, i, 0,
							 1, g_iS + g_iA + g_iS );
    gsl_matrix_memcpy( &(vsasdash_dst.matrix), &(vsasdash_src.matrix) );
    
    gsl_matrix_view vs = gsl_matrix_submatrix( D, i, 0, 1, g_iS );
    gsl_matrix* psi_s = g_fPsi( &(vs.matrix) );
    gsl_matrix_view vpsi_s = gsl_matrix_submatrix( D_mu, i, g_iS + g_iA + g_iS, 1, g_iP );
    gsl_matrix_transpose_memcpy( &(vpsi_s.matrix), psi_s );
    gsl_matrix_free( psi_s );

    gsl_matrix_view eoe_src = gsl_matrix_submatrix( D, i, g_iS + g_iA + g_iS + 1,
						    1, 1 );
    gsl_matrix_view eoe_dst = gsl_matrix_submatrix( D_mu, i, g_iS + g_iA + g_iS + g_iP,
						    1, 1 );
    gsl_matrix_memcpy( &(eoe_dst.matrix), &(eoe_src.matrix) );    
  }
  
  gsl_matrix* omega_pi = lstd_mu_omega( D_mu, &greedy_policy );
  
  for( int i = 0; i < omega_pi->size1; i++ ){
    for( int j = 0; j < omega_pi->size2; j++ ){
      printf("%e ",gsl_matrix_get( omega_pi, i, j ) );
    }
    printf("\n");
  }

  return 0;
}

#+end_src

#+srcname: LAFEM_Exp3_make
#+begin_src makefile
LAFEM_Exp3_LSTDmu.exe: LAFEM_Exp3_LSTDmu.o phipsi.o ../utils.o ../greedy.o  InvertedPendulum.o ../LSTDmu.o
	$(O2EXE) -o LAFEM_Exp3_LSTDmu.exe LAFEM_Exp3_LSTDmu.o phipsi.o ../utils.o ../greedy.o  InvertedPendulum.o  ../LSTDmu.o

LAFEM_Exp3_LSTDmu.o: LAFEM_Exp3_LSTDmu.c InvertedPendulum.h ../LSTDmu.h ../utils.h ../greedy.h ../RL_Globals.h ../IRL_Globals.h phipsi.h
	$(call c2obj,"LAFEM_Exp3_LSTDmu.c")

LAFEM_Exp3_LSTDmu.c: LAFEM_Exp3.org
	$(call tangle,"LAFEM_Exp3.org")

LAFEM_Exp3_omega_mu_E.mat: LAFEM_Exp3_LSTDmu.exe LAFEM_Exp2_omega_expert.mat D_expert.mat
	./LAFEM_Exp3_LSTDmu.exe > LAFEM_Exp3_omega_mu_E.mat

#+end_src

*** Configuring LAFEM
     Using the python code for LAFEM.
#+begin_src python :tangle LAFEM_Exp3.py
import sys
sys.path+=['..']
from a2str import *
from LAFEM import *

class LAFEM_Exp3( LAFEM ):
    omega_mu_E = []
    dicPi_E = {}

    A = [0,1,2]

    def __init__( self ):
        D_E = genfromtxt("D_expert.mat")
        for trans in D_E:
            self.dicPi_E[l2str(trans[0:2])] = trans[2:3][0]
            self.data = self.data +[[ trans[0:2], trans[2:3][0]]]
        self.omega_mu_E = genfromtxt( "LAFEM_Exp3_omega_mu_E.mat" )

#+end_src
     
     It is assumed that the $l$ function will only be evaluated where the expert has been. We compare the action chosen by the expert to the action given in argument and return 1 if there is a mismatch.
     
#+begin_src python :tangle LAFEM_Exp3.py
    def l( self, s, a ):
        if self.dicPi_E[l2str(s)] == a:
            return 0
        else:
            return 1
#+end_src
     
     $\mu_E$ is computed thanks to the data stored earlier by the program using LSTD$\mu$. We first have to redefine $\phi$ in python because it is simpler than wrapping the C code (present in [[file:plot.org]]). 

#+begin_src python :tangle LAFEM_Exp3.py
    def phi( self, s, a ):
        answer = zeros((30,1))
        position = s[0]
        speed = s[1]
        action = a
        index = action*10
        answer[index] = 1.
        index+=1
        for i in range(-1,2):
            for j in range(-1,2):
                d_i = i*3.141592/4.
                d_j = j
                answer[index] = exp(-(pow(position-d_i,2) +
                                      pow(speed-d_j,2))/2.)
                index+=1
        return answer
        
#+end_src
     Then we use the  $\mu_E(s,a) = \omega^T_{\pi_E}\phi(s,a)$ formula :
#+begin_src python :tangle LAFEM_Exp3.py
    def mu_E( self, s, a ):
        answer = dot( self.omega_mu_E.transpose(), self.phi( s, a ) )
        return answer
        #return (zeros((1,10)) + answer).transpose() #Ugly hack to get a column vector and not a line vector

    def alpha( self, t ):
        return 10./(t+1.)

    theta_0 = zeros( (10, 1) ) 

    Threshold = 0.2
    T = 20

#+end_src

*** Running LAFEM
    FIXME: s/omega/theta/avec discernement

 #+begin_src python :tangle LAFEM_Exp3.py
lafem = LAFEM_Exp3()
omega_lafem = lafem.run()
print a2str(omega_lafem)
#+end_src

#+srcname: LAFEM_Exp3_make
#+begin_src makefile
LAFEM_Exp3.py: LAFEM_Exp3.org
	$(call tangle,"LAFEM_Exp3.org")

LAFEM_Exp3_theta_lafem_mu.mat: LAFEM_Exp3.py ../a2str.py ../LAFEM.py LAFEM_Exp3_omega_mu_E.mat D_expert.mat
	python LAFEM_Exp3.py > LAFEM_Exp3_theta_lafem_mu.mat

#+end_src

*** Comparative results between the expert and the agent


#+srcname: LAFEM_Exp3_make
#+begin_src makefile
LAFEM_Exp3_omega_lafem_mu.mat: LAFEM_Exp2_Results.exe LAFEM_Exp3_theta_lafem_mu.mat
	./LAFEM_Exp2_Results.exe LAFEM_Exp3_theta_lafem_mu.mat > LAFEM_Exp3_omega_lafem_mu.mat

#+end_src

*** Plotting
The relevant makefile rules.

#+srcname: LAFEM_Exp3_make
#+begin_src makefile
LAFEM_Exp3_true_R.mat: LAFEM_Exp2_Plot.exe LAFEM_Exp3_theta_lafem_mu.mat LAFEM_Exp3_omega_lafem_mu.mat 
	./LAFEM_Exp2_Plot.exe LAFEM_Exp3_theta_lafem_mu.mat LAFEM_Exp3_omega_lafem_mu.mat LAFEM_Exp3

LAFEM_Exp3_lafem_R.mat: LAFEM_Exp2_Plot.exe LAFEM_Exp3_theta_lafem_mu.mat LAFEM_Exp3_omega_lafem_mu.mat
	./LAFEM_Exp2_Plot.exe LAFEM_Exp3_theta_lafem_mu.mat LAFEM_Exp3_omega_lafem_mu.mat LAFEM_Exp3

LAFEM_Exp3_Vexpert.mat: LAFEM_Exp2_Plot.exe LAFEM_Exp3_theta_lafem_mu.mat LAFEM_Exp3_omega_lafem_mu.mat 
	./LAFEM_Exp2_Plot.exe LAFEM_Exp3_theta_lafem_mu.mat LAFEM_Exp3_omega_lafem_mu.mat LAFEM_Exp3

LAFEM_Exp3_Vagent.mat: LAFEM_Exp2_Plot.exe LAFEM_Exp3_theta_lafem_mu.mat LAFEM_Exp3_omega_lafem_mu.mat 
	./LAFEM_Exp2_Plot.exe LAFEM_Exp3_theta_lafem_mu.mat LAFEM_Exp3_omega_lafem_mu.mat LAFEM_Exp3



#+end_src

The gnuplot instructions to plot all this, along with the relevant makefile rules :
#+begin_src gnuplot :tangle LAFEM_Exp3_true_R.gp
set pm3d map
set output "LAFEM_Exp3_true_R.ps"
set term postscript enhanced color
set xrange [-3.15:3.15]
set yrange [-3.15:3.15]
set xlabel "Position"
set ylabel "Speed"
splot "LAFEM_Exp3_true_R.dat" notitle

#+end_src

#+srcname: LAFEM_Exp3_make
#+begin_src makefile
LAFEM_Exp3_true_R.gp: LAFEM_Exp3.org
	$(call tangle,"LAFEM_Exp3.org")

LAFEM_Exp3_true_R.pdf: LAFEM_Exp3_true_R.gp LAFEM_Exp3_true_R.mat
	gnuplot LAFEM_Exp3_true_R.gp
	ps2pdf LAFEM_Exp3_true_R.ps
	rm LAFEM_Exp3_true_R.ps

#+end_src

#+begin_src gnuplot :tangle LAFEM_Exp3_lafem_R.gp

set output "LAFEM_Exp3_lafem_R.ps"
set term postscript enhanced color
set xrange [-3.15:3.15]
set yrange [-3.15:3.15]
set xlabel "Position"
set ylabel "Speed"
set parametric
set style line 2 lt 1 lw 1 pt 1 linecolor rgb "green"
set pm3d map
splot "LAFEM_Exp3_lafem_R.dat" notitle w pm3d, "D_expert.mat" u 1:2:(0.0) w points ls 2 notitle
#+end_src

#+srcname: LAFEM_Exp3_make
#+begin_src makefile
LAFEM_Exp3_lafem_R.gp: LAFEM_Exp3.org
	$(call tangle,"LAFEM_Exp3.org")

LAFEM_Exp3_lafem_R.pdf: LAFEM_Exp3_lafem_R.gp LAFEM_Exp3_lafem_R.mat
	gnuplot LAFEM_Exp3_lafem_R.gp
	ps2pdf LAFEM_Exp3_lafem_R.ps
	rm LAFEM_Exp3_lafem_R.ps

#+end_src


#+begin_src gnuplot :tangle LAFEM_Exp3_Vexpert.gp
set pm3d map
set output "LAFEM_Exp3_Vexpert.ps"
set term postscript enhanced color
set xrange [-3.15:3.15]
set yrange [-3.15:3.15]
set xlabel "Position"
set ylabel "Speed"
splot "LAFEM_Exp3_Vexpert.dat" notitle

#+end_src

#+srcname: LAFEM_Exp3_make
#+begin_src makefile
LAFEM_Exp3_Vexpert.gp: LAFEM_Exp3.org
	$(call tangle,"LAFEM_Exp3.org")

LAFEM_Exp3_Vexpert.pdf: LAFEM_Exp3_Vexpert.gp LAFEM_Exp3_Vexpert.mat
	gnuplot LAFEM_Exp3_Vexpert.gp
	ps2pdf LAFEM_Exp3_Vexpert.ps
	rm LAFEM_Exp3_Vexpert.ps

#+end_src

#+begin_src gnuplot :tangle LAFEM_Exp3_Vagent.gp
set pm3d map
set output "LAFEM_Exp3_Vagent.ps"
set term postscript enhanced color
set xrange [-3.15:3.15]
set yrange [-3.15:3.15]
set xlabel "Position"
set ylabel "Speed"
splot "LAFEM_Exp3_Vagent.dat" notitle

#+end_src

#+srcname: LAFEM_Exp3_make
#+begin_src makefile
LAFEM_Exp3_Vagent.gp: LAFEM_Exp3.org
	$(call tangle,"LAFEM_Exp3.org")

LAFEM_Exp3_Vagent.pdf: LAFEM_Exp3_Vagent.gp LAFEM_Exp3_Vagent.mat
	gnuplot LAFEM_Exp3_Vagent.gp
	ps2pdf LAFEM_Exp3_Vagent.ps
	rm LAFEM_Exp3_Vagent.ps

#+end_src

** Cleaning
   A rule to clean the mess :
  #+srcname: LAFEM_Exp3_clean_make
  #+begin_src makefile
LAFEM_Exp3_clean:
	find . -maxdepth 1 -iname "LAFEM_Exp3_*"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "LAFEM_Exp3.py"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "LAFEM_Exp3_omega_mu_E.mat"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "LAFEM_Exp3_omega_lafem_mu.mat"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "LAFEM_Exp3_theta_lafem_mu.mat"   | xargs $(XARGS_OPT) rm
  #+end_src

* Résultats
