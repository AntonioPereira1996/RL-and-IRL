#+TITLE: Simulator for the inverted pendulum

* C Implementation
** Simulator
The following functon lets the greedy policy interact with the gridworld. The argument is the number of episodes to simulate, the return value is the matrix containing all the transitions, one per line.
#+begin_src c :tangle simulator.h :main no
/* Simulate nbEpisodes episodes using greedy_policy()*/
gsl_matrix* inverted_pendulum_simulator( int nbEpisodes );
#+end_src

This variable controls how long trajectories should be.
#+begin_src c :tangle simulator.h :main no
extern unsigned int g_iMax_episode_len;
#+end_src

We use the GSL, the code shared with the generator and the code for greedy.
#+begin_src c :tangle simulator.c :main no
#include <time.h>
#include <unistd.h>
#include <gsl/gsl_matrix.h> 
#include <math.h>
#include "utils.h"
#include "simulator.h"
#include "greedy.h"
#include "InvertedPendulum.h"
#include "IRL_Globals.h"
  #+end_src

We set some constants.
#+begin_src c :tangle simulator.c :main no
#define TRANS_WIDTH 7 /* s,a,s',r,e = 7*/
  #+end_src

This variables allow one to know how many samples teh simulation has generated (generally, the lesser the better).
#+begin_src c :tangle simulator.c :main no
unsigned int g_iNb_samples = 0;
#+end_src

The code for the simulation is quite straightforward. We allocate a bigger than necessary matrix and only retrurn the useful portion of it.
#+begin_src c :tangle simulator.c :main no
gsl_matrix* inverted_pendulum_simulator( int nbEpisodes ){
  srand(time(NULL)+getpid()); rand(); rand();rand();
  gsl_matrix* transitions = gsl_matrix_alloc( nbEpisodes*g_iMax_episode_len, TRANS_WIDTH );
  double state_p; //position
  double state_v; //vitesse
  iv_init( &state_p, &state_v );
  gsl_matrix* state = gsl_matrix_alloc( 1, 2 );
  unsigned int j = 0; //Index in transitions
  for( unsigned int i = 0 ; i < nbEpisodes ; i++ ){
    unsigned int nb_steps = 0;
    int eoe = 1;
    while( eoe==1 ){
      nb_steps++;
      g_iNb_samples++;
      gsl_matrix_set( state, 0, 0, (double)state_p );
      gsl_matrix_set( state, 0, 1, (double)state_v );
      double next_state_p;
      double next_state_v;
      gsl_matrix* mAction = greedy_policy( state );
      unsigned int action = 
	(unsigned int)gsl_matrix_get( mAction, 0, 0 );
      gsl_matrix_free( mAction );
      double reward;
      iv_step( state_p, state_v, action, 
	       &next_state_p, &next_state_v, &reward, &eoe );
      if( nb_steps == g_iMax_episode_len ){
	eoe = 0;
      }
      gsl_matrix_set( transitions, j, 0, (double)state_p );
      gsl_matrix_set( transitions, j, 1, (double)state_v );
      gsl_matrix_set( transitions, j, 2, (double)action );
      gsl_matrix_set( transitions, j, 3, (double)next_state_p );
      gsl_matrix_set( transitions, j, 4, (double)next_state_v );
      gsl_matrix_set( transitions, j, 5, (double)reward );
      gsl_matrix_set( transitions, j, 6, (double)eoe );
      j++;
      if( eoe == 1 ){
	state_p = next_state_p;
	state_v = next_state_v;
      }else{
	iv_init( &state_p, &state_v );
      }
    }
  }
  gsl_matrix_free( state );
  gsl_matrix* answer = gsl_matrix_alloc( j, TRANS_WIDTH );
  gsl_matrix_view trans_v = 
    gsl_matrix_submatrix( transitions, 0, 0, j, TRANS_WIDTH );
  gsl_matrix_memcpy( answer, &trans_v.matrix );
  gsl_matrix_free( transitions );
  return answer;
}
  #+end_src

** Monte-Carlo $\mu_E(s,a)$
The following functon computes  $\hat\mu_E(s,a) = {1\over M}\sum\limits_{i=1}^{M}\sum\limits_{t<m}\gamma^t\phi(s_t),s_0=s,a_0=a,\pi_E$
#+begin_src c :tangle simulator.h :main no
/* Computes \mu_E(s,a)*/
gsl_matrix* inverted_pendulum_MC_mu( gsl_matrix* state, int action );
#+end_src

The variable noted as $m$ in the mathematical notation is g_iMax_episode_len, we declare the variable noted as $M$
#+begin_src c :tangle simulator.h :main no
extern unsigned int g_iNb_episodes;
#+end_src


We need to compute $\phi$, so we import the relevant header
#+begin_src c :tangle simulator.c :main no
#include "phipsi.h"
  #+end_src

We use a slightly modified version of the code of the simulator. The differences are that the first action is given in argument and not got from $\pi_E$, and that we compute $\mu_E$ instead of returning the transitions.

#+begin_src c :tangle simulator.c :main no
gsl_matrix* inverted_pendulum_MC_mu( gsl_matrix* s, int a ){
  srand(time(NULL)+getpid()); rand(); rand();rand();
  gsl_matrix* mu_E = gsl_matrix_calloc( g_iP, 1 );
  gsl_matrix* state = gsl_matrix_alloc( 1, 2 );
  for( unsigned int i = 0 ; i < g_iNb_episodes ; i++ ){
    unsigned int nb_steps = 0;
    int eoe = 1;
    double state_p = gsl_matrix_get( s, 0, 0 );
    double state_v = gsl_matrix_get( s, 0, 1 );
    gsl_matrix* mPsi = psi(s);
    gsl_matrix_add( mu_E, mPsi );
    gsl_matrix_free( mPsi );
    double gamma = g_dGamma_lafem;

    double next_state_p;
    double next_state_v;
    double reward;
    iv_step( state_p, state_v, a, 
	     &next_state_p, &next_state_v, &reward, &eoe );
    state_p = next_state_p;
    state_v = next_state_v;
    while( eoe==1 ){
      nb_steps++;
      g_iNb_samples++;
      gsl_matrix_set( state, 0, 0, (double)state_p );
      gsl_matrix_set( state, 0, 1, (double)state_v );
      gsl_matrix* mAction = greedy_policy( state );
      unsigned int action = 
	(unsigned int)gsl_matrix_get( mAction, 0, 0 );
      gsl_matrix_free( mAction );
      iv_step( state_p, state_v, action, 
	       &next_state_p, &next_state_v, &reward, &eoe );
      if( nb_steps == g_iMax_episode_len ){
	eoe = 0;
      }
      mPsi = psi(state);
      gsl_matrix_scale( mPsi, gamma );
      gsl_matrix_add( mu_E, mPsi );
      gsl_matrix_free( mPsi );
      gamma *= gamma;
      
      state_p = next_state_p;
      state_v = next_state_v;
    }
  }
  gsl_matrix_free( state );
  gsl_matrix_scale( mu_E, 1./(double)g_iNb_episodes );
  return mu_E;
}
#+end_src



* Makefile rules
  Some rules to tangle the source files :
  #+srcname: Simulator_code_make
  #+begin_src makefile
simulator.c: simulator.org 
	$(call tangle,"simulator.org")
simulator.h: simulator.org 
	$(call tangle,"simulator.org")
  #+end_src

   A rule to create the object file :
  #+srcname: Simulator_c2o_make
  #+begin_src makefile
simulator.o: simulator.c simulator.h InvertedPendulum.h ../utils.h
	$(call c2obj,"simulator.c")
  #+end_src



   A rule to clean the mess :
  #+srcname: Simulator_clean_make
  #+begin_src makefile
Simulator_clean:
	find . -maxdepth 1 -iname "simulator.h"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "simulator.c"   | xargs $(XARGS_OPT) rm 
	find . -maxdepth 1 -iname "simulator.o"   | xargs $(XARGS_OPT) rm
  #+end_src

