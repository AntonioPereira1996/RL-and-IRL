#+TITLE: Pendule, SCIRL, Parfait
* Description
  
  On modifie une expérience qui existait déjà pour comléter le [[file:../Protocoles.org]]. 

    
* Code								       :code:
** Parent Dir targets
#+srcname: LAFEM_Exp2_make
#+begin_src makefile
../LAFEM.py:
	make -C .. LAFEM.py

../a2str.py:
	make -C .. a2str.py

#+end_src

** Experiment targets

*** Training the expert, checking for its quality and creating $D_E$

*** Computing $\hat\mu_E$
     FIXME: Il faut utiliser la fonction monte_carlo_mu créée pour le test sur LSTDmu. La configuration actuelle duplique du code et mélange deux codes qui ne devraient pas l'être, celui du simulateur et celui de l'IRL.

     We use some code we put in [[file:simulator.org][the simulator]] to compute $\mu_E(s,a)$ for all $s\in D$ and for all $a\in A$.

     The method is straigtforward : for every $s\in D$, we compute $\mu_E(s,LEFT)$, $\mu_E(s,NONE)$ and $\mu_E(s,RIGHT)$. The results are stored in three files : mu_E_Left.mat, mu_E_None.mat and mu_E_Right.mat. The format of these files is one vector per line, the first two components are the state, the $p=10$ last ones are $\mu_E(s,a)$.
#+begin_src c :tangle LAFEM_Exp2_MuMC.c :main no
#define _POSIX_C_SOURCE 1
#include <gsl/gsl_matrix.h>
#include <math.h>
#include "InvertedPendulum.h"
#include "simulator.h"
#include "utils.h"
#include "greedy.h"
#include "phipsi.h"
#include "RL_Globals.h"
#include "IRL_Globals.h"

#define TRANS_WIDTH 7
#define ACTION_FILE "actions.mat"

unsigned int g_iS = 2;
unsigned int g_iA = 1;
gsl_matrix* g_mOmega = NULL;
double g_dGamma_lafem =  0.9;
gsl_matrix* (*g_fPhi)(gsl_matrix*) = &phi;
gsl_matrix* g_mActions = NULL;

unsigned int g_iMax_episode_len = 30;
unsigned int g_iNb_episodes = 1;

int main( void ){
  g_mOmega = file2matrix( "omega_E.mat", 1 );
  g_mActions = file2matrix( ACTION_FILE, g_iA );
  gsl_matrix* D = file2matrix( "DE.mat", TRANS_WIDTH );

  FILE* f_RIGHT = fopen( "mu_E_Right.mat", "w" );
  FILE* f_NONE = fopen( "mu_E_None.mat", "w" );
  FILE* f_LEFT = fopen( "mu_E_Left.mat", "w" );

  for( int i = 0; i < D->size1 ; i++ ){
    printf("Line %d/%d\n",i,D->size1);
    gsl_matrix_view vs = gsl_matrix_submatrix( D, i, 0, 1, 2 );
    gsl_matrix* mu_LEFT = inverted_pendulum_MC_mu( &(vs.matrix), LEFT );
    gsl_matrix* mu_RIGHT = inverted_pendulum_MC_mu( &(vs.matrix), RIGHT );
    gsl_matrix* mu_NONE = inverted_pendulum_MC_mu( &(vs.matrix), NONE );
    
    fprintf( f_RIGHT, "%e %e ", gsl_matrix_get( &(vs.matrix), 0, 0 ), 
	     gsl_matrix_get( &(vs.matrix), 0, 1 ) );
    fprintf( f_NONE, "%e %e ", gsl_matrix_get( &(vs.matrix), 0, 0 ), 
	     gsl_matrix_get( &(vs.matrix), 0, 1 ) );
    fprintf( f_LEFT, "%e %e ", gsl_matrix_get( &(vs.matrix), 0, 0 ), 
	     gsl_matrix_get( &(vs.matrix), 0, 1 ) );
    for( int j = 0; j< g_iP ; j++ ){
      fprintf( f_RIGHT, "%e ", gsl_matrix_get( mu_RIGHT, j, 0 ) );
      fprintf( f_NONE, "%e ", gsl_matrix_get( mu_NONE, j, 0 ) );
      fprintf( f_LEFT, "%e ", gsl_matrix_get( mu_LEFT, j, 0 ) );
    }
    fprintf( f_RIGHT, "\n" );
    fprintf( f_NONE, "\n" );
    fprintf( f_LEFT, "\n" );

    gsl_matrix_free( mu_LEFT );
    gsl_matrix_free( mu_RIGHT );
    gsl_matrix_free( mu_NONE );
  }
  
  fclose( f_RIGHT );
  fclose( f_LEFT );
  fclose( f_NONE );
  
  return 0;
}

#+end_src

#+srcname: LAFEM_Exp2_make
#+begin_src makefile
LAFEM_Exp2_MuMC.exe: LAFEM_Exp2_MuMC.o phipsi.o ../utils.o ../greedy.o  InvertedPendulum.o simulator.o
	$(O2EXE) -o LAFEM_Exp2_MuMC.exe LAFEM_Exp2_MuMC.o phipsi.o ../utils.o ../greedy.o  InvertedPendulum.o  simulator.o

LAFEM_Exp2_MuMC.o: LAFEM_Exp2_MuMC.c InvertedPendulum.h simulator.h ../utils.h ../greedy.h ../RL_Globals.h ../IRL_Globals.h
	$(call c2obj,"LAFEM_Exp2_MuMC.c")

LAFEM_Exp2_MuMC.c: LAFEM_Exp2.org
	$(call tangle,"LAFEM_Exp2.org")

#+end_src

*** Configuring LAFEM
     Using the python code for LAFEM.
#+begin_src python :tangle LAFEM_Exp2.py
import sys
sys.path+=['..']
from a2str import *
from LAFEM import *
from subprocess import call

class LAFEM_Exp2( LAFEM ):
    dicPi_E = {}
    dicMu_Left = {}
    dicMu_Right = {}
    dicMu_None = {}

    A = [0,1,2]

    def __init__( self ):
        D_E = genfromtxt(sys.argv[1])
        for trans in D_E:
            self.dicPi_E[l2str(trans[0:2])] = trans[2:3][0]
            self.data = self.data +[[ trans[0:2], trans[2:3][0]]]

        mu_Left = genfromtxt("mu_E_Left.mat")
        for line in mu_Left:
            self.dicMu_Left[l2str( line[0:2] )] = line[2:].copy()

        mu_Right = genfromtxt("mu_E_Right.mat")
        for line in mu_Right:
            self.dicMu_Right[l2str( line[0:2] )] = line[2:].copy()

        mu_None = genfromtxt("mu_E_None.mat")
        for line in mu_None:
            self.dicMu_None[l2str( line[0:2] )] = line[2:].copy()

#+end_src
     
     It is assumed that the $l$ function will only be evaluated where the expert has been. We compare the action chosen by the expert to the action given in argument and return 1 if there is a mismatch.
     
#+begin_src python :tangle LAFEM_Exp2.py
    def l( self, s, a ):
        if self.dicPi_E[l2str(s)] == a:
            return 0
        else:
            return 1
#+end_src
     
     $\mu_E$ is computed thanks to the data stored earlier by the Monte-Carlo simulation.
     
#+begin_src python :tangle LAFEM_Exp2.py
    def mu_E( self, s, a ):
        mu_a = array([])
        if a == 2: #Taken from InvertedPendulum.org
            mu_a = self.dicMu_Right
        elif a == 0:
            mu_a = self.dicMu_Left
        elif a == 1:
            mu_a = self.dicMu_None
        else:
            print "On calcule mu sur une action qui nexiste pas"
            print a
            exit(-1)
        return (zeros((1,10)) + mu_a[l2str( s )]).transpose() #Ugly hack to get a column vector and not a line vector

    def alpha( self, t ):
        return 10./(t+1.)

    theta_0 = zeros( (10, 1) ) 

    Threshold = 0.2

    T = 20

#+end_src

*** Running LAFEM
 #+begin_src python :tangle LAFEM_Exp2.py
lafem = LAFEM_Exp2()
theta_lafem = lafem.run()
savetxt( "LAFEM_Exp2_theta.mat", theta_lafem, "%e", "\n" );

print "%d\t"%len( lafem.data ),
sys.stdout.flush()
call([ "./Evaluate_theta.exe","LAFEM_Exp2_theta.mat"])
print
#+end_src

#+srcname: LAFEM_Exp2_make
#+begin_src makefile
LAFEM_Exp2.py: LAFEM_Exp2.org
	$(call tangle,"LAFEM_Exp2.org")

LAFEM_Exp2: LAFEM_Exp2.py ../a2str.py ../LAFEM.py LAFEM_Exp2_MuMC.exe DE.exe omega_E.mat
	for i in $(LM_VALUES); \
	do \
	./DE.exe $$i > DE.mat; \
	./LAFEM_Exp2_MuMC.exe; \
	python LAFEM_Exp2.py DE.mat >> LAFEM_Exp2.mat; \
	done
#+end_src


*** Plotting
#+begin_src python :tangle LAFEM_Exp2_plot.py
from matplotlib import rc
rc('text', usetex=True)
import sys
sys.path+=['..']
from numpy import *
import scipy
import pylab as pylab
from Plot import *

D = genfromtxt( "LAFEM_Exp2.mat" )
myPlot = Plot()
myPlot.Expert = 4.11057591 #python Expert.py to get this value
myPlot.Random_mean = 0.48848324670295395#See Highway.org about Random.py for information on these values
myPlot.Random_min = 0.069469005947400006#python Random.py to get this value
myPlot.Random_max = 3.2720195801399998#python Random.py to get this value
myPlot.Random_var = 0.57868038965027513#python Random.py to get this value

myPlot.ymin = -1
myPlot.ymax = 5

myPlot.plot( D, 'red', 'LAFEM_Exp2_fig1.pdf' )

#+end_src

#+srcname: LAFEM_Exp2_make
#+begin_src makefile
LAFEM_Exp2_plot.py: LAFEM_Exp2.org
	$(call tangle,"LAFEM_Exp2.org")

LAFEM_Exp2_fig1.pdf: LAFEM_Exp2_plot.py LAFEM_Exp2.mat ../Plot.py
	python LAFEM_Exp2_plot.py
#+end_src


** Cleaning
   A rule to clean the mess :
  #+srcname: LAFEM_Exp2_clean_make
  #+begin_src makefile
LAFEM_Exp2_clean:
	find . -maxdepth 1 -iname "LAFEM_Exp2_*"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "LAFEM_Exp2.py"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "LAFEM_Exp2_omega_lafem.mat"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "LAFEM_Exp2_theta_lafem.mat"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "LAFEM_Exp2_omega_expert.mat"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "D_expert.mat"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "mu_E_Left.mat"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "mu_E_Right.mat"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "mu_E_None.mat"   | xargs $(XARGS_OPT) rm
  #+end_src

* Résultats
