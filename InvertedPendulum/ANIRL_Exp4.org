#+TITLE:ANIRL, Pendule, Dégradé

Cette expérience s'inscrit dans une démarche de test plus grande : [[file:../Protocoles.org]].


Début du code C pour cette expérience :
#+begin_src c :tangle ANIRL_Exp4.c :main no
#define _POSIX_C_SOURCE 1
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_blas.h>
#include <math.h>
#include "InvertedPendulum.h"
#include "simulator.h"
#include "utils.h"
#include "LSPI.h"
#include "abbeel2004apprenticeship.h"
#include "ANIRL.h"
#include "LSTDmu.h"
#include "greedy.h"
#include "phipsi.h"

#include "RL_Globals.h"
#include "IRL_Globals.h"
#define D_FILE_NAME "Samples.dat"
#define TRANS_WIDTH 7
#define ACTION_FILE "actions.mat"
#define EXPERT_FILE "D_expert.mat"

unsigned int g_iS = 2;
unsigned int g_iA = 1;
unsigned int g_iIt_max_lspi = 50;
gsl_matrix* (*g_fPhi)(gsl_matrix*) = &phi;
gsl_matrix* g_mOmega = NULL;
double g_dLambda_lstdQ = 0.1;
double g_dGamma_lstdq =  0.9;
double g_dEpsilon_lspi = 0.01;
double g_dLambda_lstdmu = 0.1;
double g_dGamma_anirl = 0.9;
double g_dEpsilon_anirl = 0.2;
unsigned int g_iIt_max_anirl = 100;
gsl_matrix* g_mActions = NULL; 
gsl_matrix* (*g_fPsi)(gsl_matrix*) = &psi;
gsl_matrix* (*g_fSimulator)(int) = &inverted_pendulum_simulator;
//L_{MCip}
unsigned int g_iMax_episode_len = 30;
gsl_matrix* D_E = NULL;
gsl_matrix* D_mu = NULL;
unsigned int M = 1; //M_{MCip}

//FIXME: Useless but defined anyway in order to compile
double g_dGamma_lafem = -1;
unsigned int g_iNb_episodes = -1;
#+end_src

Les sous routines utilisées pour ANIRL sont :
 - LSTD$\mu$ pour le calcul des /feature expectations/ :
   #+begin_src c :tangle ANIRL_Exp4.c :main no
gsl_matrix* S_0(){
  gsl_matrix* s_0 = gsl_matrix_alloc( 1, 2 );
  gsl_matrix_set( s_0, 0, 0, 0. ); //The RBF is so wide, no need to do a mean.
  gsl_matrix_set( s_0, 0, 1, 0. );
  return s_0;
}

gsl_matrix* mu_pi(gsl_matrix* omega){
  g_mOmega = omega;
  return lstd_mu( D_mu, &greedy_policy );
}

gsl_matrix* mu_E(){
  return lstd_mu_op( D_mu );
}

gsl_matrix* (*g_fS_0)(void) = &S_0;
gsl_matrix* (*g_fMu_pi)(gsl_matrix*) = &mu_pi;
gsl_matrix* (*g_fMu_E)() = &mu_E;


   #+end_src
 - LSPI en tant que solveur de MDP :
   #+begin_src c :tangle ANIRL_Exp4.c :main no
gsl_matrix* lspi_wrapper(gsl_matrix* theta){
  for( unsigned int i = 0 ; i < D_E->size1 ; i++ ){
    gsl_matrix_view state = 
      gsl_matrix_submatrix( D_E, i, 0, 1, g_iS );
    gsl_matrix* psi_s = g_fPsi( &state.matrix );
    gsl_matrix_view r = 
      gsl_matrix_submatrix( D_E, i, 2*g_iS+g_iA, 1, 1 );
    gsl_blas_dgemm( CblasTrans, CblasNoTrans, 1.0, 
		    theta, psi_s, 0.0, &r.matrix );
    gsl_matrix_free( psi_s );
    }
  gsl_matrix* omega_0 = gsl_matrix_calloc( g_iK, 1 );
  gsl_matrix* omega = lspi( D_E, omega_0 );
  gsl_matrix_free( omega_0 );
  return omega;
}

gsl_matrix* (*g_fMDP_solver)(gsl_matrix*) = &lspi_wrapper;
   #+end_src



#+begin_src c :tangle ANIRL_Exp4.c :main no
int main( void ){
  g_mActions = file2matrix( ACTION_FILE, g_iA );
  D_E = file2matrix( EXPERT_FILE, TRANS_WIDTH );
  D_mu = gsl_matrix_alloc( D_E->size1, g_iS + g_iA + g_iS + g_iP + 1 );

  for( int i = 0; i < D_E->size1 ; i++ ){
    gsl_matrix_view vsasdash_src = gsl_matrix_submatrix( D_E, i, 0, 1, g_iS + g_iA + g_iS );
    gsl_matrix_view vsasdash_dst = gsl_matrix_submatrix( D_mu, i, 0,
							 1, g_iS + g_iA + g_iS );
    gsl_matrix_memcpy( &(vsasdash_dst.matrix), &(vsasdash_src.matrix) );
    
    gsl_matrix_view vs = gsl_matrix_submatrix( D_E, i, 0, 1, g_iS );
    gsl_matrix* psi_s = g_fPsi( &(vs.matrix) );
    gsl_matrix_view vpsi_s = gsl_matrix_submatrix( D_mu, i, g_iS + g_iA + g_iS, 1, g_iP );
    gsl_matrix_transpose_memcpy( &(vpsi_s.matrix), psi_s );
    gsl_matrix_free( psi_s );

    gsl_matrix_view eoe_src = gsl_matrix_submatrix( D_E, i, g_iS + g_iA + g_iS + 1,
						    1, 1 );
    gsl_matrix_view eoe_dst = gsl_matrix_submatrix( D_mu, i, g_iS + g_iA + g_iS + g_iP,
						    1, 1 );
    gsl_matrix_memcpy( &(eoe_dst.matrix), &(eoe_src.matrix) );    
  }

#+end_src
FIXME: Le code pour la création de D_mu se retrouve un peu partout il faudrait le factoriser de manière élégante

On lance ANIRL :
#+begin_src c :tangle ANIRL_Exp4.c :main no
    gsl_matrix* omega_mc =proj_ANIRL();
#+end_src

Puis on vérifie que le contrôle obtenu tient la route :
#+begin_src c :tangle ANIRL_Exp4.c :main no
  g_mOmega = omega_mc;
  g_iMax_episode_len = 3000;
  gsl_matrix* D_agent = inverted_pendulum_simulator( 1 );
  printf("Longueur du run de l'agent : %d\n",D_agent->size1);
  if( D_agent->size1 != 3000 ){
    return 0; //Failure is the expected behavior
  }
  return 1;
}
#+end_src

Tout cela se compile de la sorte :
#+srcname: ANIRL_Exp4_make
#+begin_src makefile
ANIRL_Exp4.c: ANIRL_Exp4.org 
	$(call tangle,"ANIRL_Exp4.org")
ANIRL_Exp4.o: ANIRL_Exp4.c InvertedPendulum.h simulator.h ../utils.h ../LSPI.h ../abbeel2004apprenticeship.h ../criteria.h ../greedy.h phipsi.h ../RL_Globals.h ../IRL_Globals.h ../ANIRL.h ../LSTDmu.h
	$(call c2obj,"ANIRL_Exp4.c")
ANIRL_Exp4.exe: ANIRL_Exp4.o ../LSPI.o phipsi.o ../greedy.o ../LSTDQ.o ../abbeel2004apprenticeship.o simulator.o ../utils.o ../criteria.o InvertedPendulum.o ../ANIRL.o ../LSTDmu.o
	$(O2EXE) -o ANIRL_Exp4.exe ANIRL_Exp4.o ../LSPI.o phipsi.o ../greedy.o ../LSTDQ.o ../abbeel2004apprenticeship.o ../utils.o simulator.o ../criteria.o InvertedPendulum.o ../ANIRL.o ../LSTDmu.o

ANIRL_Exp4: ANIRL_Exp4.exe Samples.dat D_expert.mat
	./ANIRL_Exp4.exe

#+end_src

  #+srcname: ANIRL_Exp4_clean_make
  #+begin_src makefile
ANIRL_Exp4_clean:
	find . -maxdepth 1 -iname "ANIRL_Exp4.h"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "ANIRL_Exp4.c"   | xargs $(XARGS_OPT) rm 
	find . -maxdepth 1 -iname "ANIRL_Exp4.o"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "ANIRL_Exp4.exe"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "ANIRL_Exp4.tex"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "ANIRL_Exp4.pdf"   | xargs $(XARGS_OPT) rm
  #+end_src
