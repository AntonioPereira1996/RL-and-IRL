#+TITLE:Using a pure supervised approach for imitation
* Principe
L'un des arguments développés dans la dérivation de [[file:../NouveauxAlgos.org][LAFEM/SCIRL]] est qu'utiliser une approximation de $Q^*$ de la forme $Q^*(s,a) = \theta^T\mu_E(s,a)$ permet d'introduire la structure du MDP dans l'algorithme et que de fait nous ne nous contentons pas d'utiliser une méthode supervisée pure.

Nous allons essayer de démontrer empiriquement le bien fondé de cet argument en approximant $Q^*$ sous la forme $Q^*(s) = \omega^T\phi(s,a)$ grâce à la même descente de gradient que notre algorithme. Nous allons juste supprimer l'information apportée par $\mu_E$.

Cette fonction nous permettra de contrôler le pendule, nous pourrons également comparer sa forme avec celle des autres fonctions de valeurs que l'on trace dans [[file:LAFEM_Exp3.org]], à savoir celle de l'expert et celle de l'agent entrâiné sur la récompense trouvée par LAFEM.

Seul avantage de cette approche : elle ne nécessite pas de résoudre le problème direct du tout. Même à la fon, lorsqu'une récompense est obtenue.


* Code :code:
  Pour implémenter ce que nous venons de décrire, nous allons vendre notre âme à Satan et utiliser le code de LAFEM en remplaçant $\mu_E$ par $\phi$ dans la sous classe, ce qui devrait produire le vecteur $\omega$ que nous recherchons. C'est assez sale comme approche, mais peu importe on est pressés.

  On fait plus ou moins un copier/coller du code de [[file:LAFEM_Exp3.org]], seule la fonction =mu_E= change, puisqu'on renvoie =phi(s,a)=. Il y a aussi =theta_0= qui change, pour avoir la bonne taille.

** Configuring LAFEM
#+begin_src python :tangle LAFEM_Exp7.py
import sys
sys.path+=['..']
from a2str import *
from LAFEM import *

class LAFEM_Exp7( LAFEM ):
    dicPi_E = {}

    A = [0,1,2]

    def __init__( self ):
        D_E = genfromtxt("D_expert.mat")
        for trans in D_E:
            self.dicPi_E[l2str(trans[0:2])] = trans[2:3][0]
            self.data = self.data +[[ trans[0:2], trans[2:3][0]]]

#+end_src
     
     It is assumed that the $l$ function will only be evaluated where the expert has been. We compare the action chosen by the expert to the action given in argument and return 1 if there is a mismatch.
     
#+begin_src python :tangle LAFEM_Exp7.py
    def l( self, s, a ):
        if self.dicPi_E[l2str(s)] == a:
            return 0
        else:
            return 1
#+end_src
     
     Le code présent dans [[file:LAFEM_Exp3.org]] redéfinissait =phi= (déjà implémentée en C) pour pouvoir calculer =mu_E=. On va garder le code de =phi= mais on va l'appeler =mu_E= et on va supprimer le =mu_E= original.

#+begin_src python :tangle LAFEM_Exp7.py
    def mu_E( self, s, a ):
        answer = zeros((30,1))
        position = s[0]
        speed = s[1]
        action = a
        index = action*10
        answer[index] = 1.
        index+=1
        for i in range(-1,2):
            for j in range(-1,2):
                d_i = i*3.141592/4.
                d_j = j
                answer[index] = exp(-(pow(position-d_i,2) +
                                      pow(speed-d_j,2))/2.)
                index+=1
        return answer
        
#+end_src

     La fonction =alpha= est modifiée après quelques essais/erreurs pour donner une valeur finale du gradient la plus petite possible, =theta_0= change de taille afin de ceorrespondre à la taille des vecteurs retournés par =phi=. Les autres paramètres, =Threshold= et =T=, restent les mêmes.

#+begin_src python :tangle LAFEM_Exp7.py
    def alpha( self, t ):
        return 30./(t+1.)

    theta_0 = zeros( (30, 1) ) - 1.

    Threshold = 0.1
    T = 20

#+end_src
** Running LAFEM


 #+begin_src python :tangle LAFEM_Exp7.py
lafem = LAFEM_Exp7()
omega_lafem = lafem.run()
print a2str(omega_lafem)
#+end_src

#+srcname: LAFEM_Exp7_make
#+begin_src makefile
LAFEM_Exp7.py: LAFEM_Exp7.org
	$(call tangle,"LAFEM_Exp7.org")

omega_lafem_phi.mat: LAFEM_Exp7.py ../a2str.py ../LAFEM.py D_expert.mat
	python LAFEM_Exp7.py > omega_lafem_phi.mat

#+end_src

** Plotting and testing

En s'inspirant du code présent dans [[file:LAFEM_Exp2.org]], l'on va tester le contrôle induit par notre approximation de $Q^*$ et tracer la fonction $V^*$ correspondante. On fait cela en une seule passe, tandis que dans le fichier susmentionné, cela est fait en 2. On va de plus comparer avec l'approximation produite par $Q^*(s,a) = \theta^T \mu_E(s,a) = \theta^T\omega_{LSTD\mu}^T\phi(s,a)$. Pour obtenir ces deux matrices on réutilise les règles du Makefile et le code défini dans [[file:LAFEM_Exp3.org]].

#+begin_src c :tangle LAFEM_Exp7_Results.c
#define _POSIX_C_SOURCE 1
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_blas.h>
#include <math.h>
#include "InvertedPendulum.h"
#include "simulator.h"
#include "utils.h"
#include "greedy.h"
#include "phipsi.h"
#include "RL_Globals.h"
#include "IRL_Globals.h"
#define ACTION_FILE "actions.mat"

#define GRID_V_SIZE 20
#define GRID_P_SIZE 20
#define P_MIN (-PI/3.)
#define P_MAX (PI/3.)
#define V_MIN (-PI/2.)
#define V_MAX (PI/2.)


//FIXME : those are not useful here, but it won't compile without
double g_dGamma_lafem = 0;
unsigned int g_iNb_episodes = -1;

unsigned int g_iS = 2;
unsigned int g_iA = 1;
gsl_matrix* (*g_fPhi)(gsl_matrix*) = &phi;
double g_dLambda_lstdQ = 0.1;
double g_dGamma_lstdq =  0.9;
gsl_matrix* g_mOmega = NULL;
gsl_matrix* g_mActions = NULL; 

unsigned int g_iMax_episode_len = 3000;

int main (int argc, char *argv[]){
  if (argc != 4){
    printf("usage : %s <name of file with omega_lafem_phi inside> <name of file for theta_lafem_mu> <name of file for omega_LSTDmu>\n (%d arguments given) ",argv[0],argc);
    exit( 1 );
  }
  char* omega_phi_file = argv[1];
  char* theta_file = argv[2];
  char* omega_lstdmu_file = argv[3];

  gsl_matrix* omega_lafem_phi = file2matrix( omega_phi_file, 1 );
  gsl_matrix* theta_lafem = file2matrix( theta_file, 1 );
  gsl_matrix* omega_lstdmu = file2matrix( omega_lstdmu_file, g_iP );

  g_mActions = file2matrix( ACTION_FILE, g_iA );
  g_mOmega = omega_lafem_phi;
  gsl_matrix* D_lafem = inverted_pendulum_simulator( 1 );
  fprintf(stderr,"Longueur d'un run de l'agent entrainé sur Lafem(phi): %d\n",D_lafem->size1);
  //if( D_lafem->size1 < g_iMax_episode_len ){
  //  return 1;
  //}
  gsl_matrix_free( D_lafem );

  gsl_matrix* omega_composite = gsl_matrix_calloc( 1, g_iK );
  gsl_blas_dgemm( CblasTrans, CblasTrans, 1.0, theta_lafem, omega_lstdmu, 0., omega_composite );
  gsl_matrix* tmp = gsl_matrix_calloc( g_iK, 1 );
  gsl_matrix_transpose_memcpy( tmp, omega_composite );
  gsl_matrix_free( omega_composite );
  omega_composite = tmp;
  g_mOmega = omega_composite;
  D_lafem = inverted_pendulum_simulator( 1 );
  fprintf(stderr,"Longueur d'un run de l'agent entrainé sur Lafem(mu): %d\n",D_lafem->size1);
  //if( D_lafem->size1 < g_iMax_episode_len ){
  //  return 1;
  //}
  gsl_matrix_free( D_lafem );
  
  gsl_matrix* omega_rand = gsl_matrix_alloc( g_iK, 1 );
  for( int i=0; i< g_iK; i++ ){
    gsl_matrix_set( omega_rand, i, 0, rand()/RAND_MAX-0.5 );
  }
  g_mOmega = omega_rand;
  gsl_matrix* D_rand = inverted_pendulum_simulator( 1 );
  fprintf(stderr,"Longueur d'un run aléatoire : %d\n",D_rand->size1);
  gsl_matrix_free( D_rand );
  

  

  //Plotting
  double V_phi[GRID_V_SIZE][GRID_P_SIZE];
  double V_mu[GRID_V_SIZE][GRID_P_SIZE];
  gsl_matrix* sa = gsl_matrix_alloc( 1,3 );
  gsl_matrix* Q = gsl_matrix_alloc( 1, 1 );
  gsl_matrix* state = gsl_matrix_alloc( 1, 2 );

  g_mOmega = omega_lafem_phi;
  for( int i=0; i<GRID_V_SIZE; i++ ){
    double v = V_MIN + ((double)i)*( (V_MAX-V_MIN)/((double)GRID_V_SIZE - 1.) );
    for( int j=0; j< GRID_P_SIZE; j++){
      double p = P_MIN + ((double)j)*( (P_MAX-P_MIN)/((double)GRID_P_SIZE - 1.) );
      gsl_matrix_set( sa, 0, 0, p );
      gsl_matrix_set( sa, 0, 1, v );
      gsl_matrix* mAction = greedy_policy( state );
      gsl_matrix_set( sa, 0, 2, gsl_matrix_get( mAction, 0, 0 ) );
      gsl_matrix* mPhi = phi( sa );
      gsl_blas_dgemm( CblasTrans, CblasNoTrans, 1.0, omega_lafem_phi, mPhi, 0., Q );
      V_phi[i][j] = gsl_matrix_get( Q, 0, 0 );
      gsl_matrix_free( mPhi );
    }
  }

  g_mOmega = omega_composite;
  for( int i=0; i<GRID_V_SIZE; i++ ){
    double v = V_MIN + ((double)i)*( (V_MAX-V_MIN)/((double)GRID_V_SIZE - 1.) );
    for( int j=0; j< GRID_P_SIZE; j++){
      double p = P_MIN + ((double)j)*( (P_MAX-P_MIN)/((double)GRID_P_SIZE - 1.) );
      gsl_matrix_set( sa, 0, 0, p );
      gsl_matrix_set( sa, 0, 1, v );
      gsl_matrix* mAction = greedy_policy( state );
      gsl_matrix_set( sa, 0, 2, gsl_matrix_get( mAction, 0, 0 ) );
      gsl_matrix* mPhi = phi( sa );
      gsl_blas_dgemm( CblasTrans, CblasNoTrans, 1.0, omega_composite, mPhi, 0., Q );
      V_mu[i][j] = gsl_matrix_get( Q, 0, 0 );
      gsl_matrix_free( mPhi );
    }
  }

  gsl_matrix_free( state );
  gsl_matrix_free( sa );
  gsl_matrix_free( Q );

  FILE* f_V_phi = fopen( "LAFEM_Exp7_Vphi.dat", "w" );
  FILE* f_V_mu = fopen( "LAFEM_Exp7_Vmu.dat", "w" );
  for( int i=0; i<GRID_V_SIZE; i++ ){
    double v = V_MIN + ((double)i)*( (V_MAX-V_MIN)/((double)GRID_V_SIZE - 1.) );
    for( int j=0; j< GRID_P_SIZE; j++){
      double p = P_MIN + ((double)j)*( (P_MAX-P_MIN)/((double)GRID_P_SIZE - 1.) );
      fprintf( f_V_phi, "%e %e %e\n", p, v, V_phi[i][j]);
      fprintf( f_V_mu, "%e %e %e\n", p, v, V_mu[i][j]);
    }
    fprintf( f_V_phi, "\n" );
    fprintf( f_V_mu, "\n" );
  }
  
  fclose( f_V_phi );
  fclose( f_V_mu );

  return 0;
}

#+end_src


#+srcname: LAFEM_Exp7_make
#+begin_src makefile
LAFEM_Exp7_Results.exe: LAFEM_Exp7_Results.o phipsi.o ../utils.o ../greedy.o  InvertedPendulum.o simulator.o ../LSTDQ.o
	$(O2EXE) -o LAFEM_Exp7_Results.exe LAFEM_Exp7_Results.o phipsi.o ../utils.o ../greedy.o  InvertedPendulum.o  simulator.o ../LSTDQ.o

LAFEM_Exp7_Results.o: LAFEM_Exp7_Results.c InvertedPendulum.h simulator.h ../utils.h ../greedy.h ../RL_Globals.h ../IRL_Globals.h  phipsi.h
	$(call c2obj,"LAFEM_Exp7_Results.c")

LAFEM_Exp7_Results.c: LAFEM_Exp7.org
	$(call tangle,"LAFEM_Exp7.org")

#+end_src

#+srcname: LAFEM_Exp7_make
#+begin_src makefile
LAFEM_Exp7_Vphi.dat: LAFEM_Exp7_Results.exe omega_lafem_phi.mat omega_mu_E.mat theta_lafem_mu.mat
	./LAFEM_Exp7_Results.exe omega_lafem_phi.mat theta_lafem_mu.mat omega_mu_E.mat

LAFEM_Exp7_Vmu.dat: LAFEM_Exp7_Results.exe omega_lafem_phi.mat omega_mu_E.mat theta_lafem_mu.mat
	./LAFEM_Exp7_Results.exe omega_lafem_phi.mat theta_lafem_mu.mat omega_mu_E.mat

#+end_src

The gnuplot instructions to plot all this, along with the relevant makefile rules :

#+begin_src gnuplot :tangle LAFEM_Exp7_Vphi.gp
set pm3d map
set output "LAFEM_Exp7_Vphi.ps"
set term postscript enhanced color
set xrange [-1.05:1.05]
set yrange [-1.55:1.55]
set xlabel "Position"
set ylabel "Speed"
splot "LAFEM_Exp7_Vphi.dat" notitle,  "D_expert.mat" u 1:2:(0.0) w points ls 2 notitle

#+end_src

#+begin_src gnuplot :tangle LAFEM_Exp7_Vmu.gp
set pm3d map
set output "LAFEM_Exp7_Vmu.ps"
set term postscript enhanced color
set xrange [-1.05:1.05]
set yrange [-1.55:1.55]
set xlabel "Position"
set ylabel "Speed"
splot "LAFEM_Exp7_Vmu.dat" notitle,  "D_expert.mat" u 1:2:(0.0) w points ls 2 notitle

#+end_src

#+srcname: LAFEM_Exp7_make
#+begin_src makefile
LAFEM_Exp7_Vphi.gp: LAFEM_Exp7.org
	$(call tangle,"LAFEM_Exp7.org")
LAFEM_Exp7_Vmu.gp: LAFEM_Exp7.org
	$(call tangle,"LAFEM_Exp7.org")

LAFEM_Exp7_Vphi.pdf: LAFEM_Exp7_Vphi.gp LAFEM_Exp7_Vphi.dat
	gnuplot LAFEM_Exp7_Vphi.gp
	ps2pdf LAFEM_Exp7_Vphi.ps
	rm LAFEM_Exp7_Vphi.ps

LAFEM_Exp7_Vmu.pdf: LAFEM_Exp7_Vagent.gp LAFEM_Exp7_Vmu.dat
	gnuplot LAFEM_Exp7_Vmu.gp
	ps2pdf LAFEM_Exp7_Vmu.ps
	rm LAFEM_Exp7_Vmu.ps

#+end_src



** Cleaning
   A rule to clean the mess :
  #+srcname: LAFEM_Exp7_clean_make
  #+begin_src makefile
LAFEM_Exp7_clean: LAFEM_Exp3_clean LAFEM_Exp2_clean
	find . -maxdepth 1 -iname "LAFEM_Exp7_*"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "LAFEM_Exp7.py"   | xargs $(XARGS_OPT) rm
  #+end_src
