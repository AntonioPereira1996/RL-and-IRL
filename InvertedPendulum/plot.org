#+TITLE: Plots for the paper about LSTD-\mu
* Introduction
   The inverted pendulum has been used as a benchmark in a paper about LSTD-$\mu$.

   This directory contains the code to generate some of the plots used in the forementionned paper. One single executable generates all the data, which is then selected and plotted.

* C program
This programs outputs the data needed to plot the figure 2 and 3 of the paper about LSTD-$\mu$. More precisely, it outputs the data for only one plot (Figure 2) but is then ran a lot of times by the ErrorBars.py script (figure 3).

We use the GSL, the LSPI algorithm, Abbeel and Ng's IRL algorithm and our LSPI variant.
#+begin_src c :tangle plot.c :main no
#define _POSIX_C_SOURCE 1
#include <gsl/gsl_matrix.h>
#include <math.h>
#include "InvertedPendulum.h"
#include "simulator.h"
#include "utils.h"
#include "LSPI.h"
#include "abbeel2004apprenticeship.h"
#include "LSTDmu.h"
#include "criteria.h"
#include "greedy.h"
#+end_src

We set some constants
#+begin_src c :tangle plot.c :main no
#include "RL_Globals.h"
#include "IRL_Globals.h"
#define D_FILE_NAME "Samples.dat"
#define TRANS_WIDTH 7
#define ACTION_FILE "actions.mat"
#+end_src

We define both feature functions : $\phi: S\times A \rightarrow \mathbb{R}^p$ and $\phi: S\rightarrow \mathbb{R}^p$.
#+begin_src c :tangle plot.c :main no
unsigned int g_iK = (30); /* dim(\phi) */
unsigned int g_iP = (10); /* dim(\psi) */

gsl_matrix* phi( gsl_matrix* sa ){
  gsl_matrix* answer = gsl_matrix_calloc( g_iK, 1 );
  double position = gsl_matrix_get( sa, 0, 0 );
  double speed = gsl_matrix_get( sa, 0, 1 );
  unsigned int action = (unsigned int)gsl_matrix_get( sa, 0, 2 );
  unsigned int index = action*10;
  gsl_matrix_set( answer, index, 0, 1.0 );
  index++;
  for( int i = -1. ; i <= 1 ; i++ ){
    for( int j = -1 ; j <= 1 ; j++ ){
      double d_i = (double)i * PI/4.;
      double d_j = (double)j;
      gsl_matrix_set( answer, index, 0, 
		      exp(-(pow(position-d_i,2) + 
			    pow(speed-d_j,2))/2.));
      index++;
    }
  }
  return answer;
}

gsl_matrix* psi( gsl_matrix* s ){
  gsl_matrix* answer = gsl_matrix_calloc( g_iP, 1 );
  double position = gsl_matrix_get( s, 0, 0 );
  double speed = gsl_matrix_get( s, 0, 1 );
  unsigned int index = 0;
  gsl_matrix_set( answer, index, 0, 1.0 );
  index++;
  for( int i = -1. ; i <= 1 ; i++ ){
    for( int j = -1 ; j <= 1 ; j++ ){
      double d_i = (double)i * PI/4.;
      double d_j = (double)j;
      gsl_matrix_set( answer, index, 0,
		      exp(-(pow(position-d_i,2) + 
			    pow(speed-d_j,2))/2.));
      index++;
    }
  }
  return answer;
}
#+end_src

We use the shared code to reinitialize at the beginning of each episode. 
#+begin_src c :tangle plot.c :main no
gsl_matrix* initial_state( void ){
  gsl_matrix* answer = gsl_matrix_alloc( 1, 2 );
  double pos;
  double speed;
  for( unsigned int i=0; i<1; i++ ){
    iv_init( &pos, &speed );
    gsl_matrix_set( answer, i, 0, pos );
    gsl_matrix_set( answer, i, 1, speed );
  }
  return answer;
}
#+end_src

We set the global variables needed by LSPI and the IRL algorithms.
#+begin_src c :tangle plot.c :main no
unsigned int g_iS = 2;
unsigned int g_iA = 1;
unsigned int g_iIt_max_lspi = 50;
gsl_matrix* (*g_fPhi)(gsl_matrix*) = &phi;
gsl_matrix* g_mOmega = NULL;
double g_dLambda_lstdQ = 0.1;
double g_dGamma_lstdq =  0.9;
double g_dEpsilon_lspi = 0.01;
double g_dLambda_lstdmu = 0.1;
double g_dGamma_anirl = 0.9;
double g_dEpsilon_anirl = 0.01;
unsigned int g_iIt_max_anirl = 2;
gsl_matrix* g_mActions = NULL; 
gsl_matrix* (*g_fPsi)(gsl_matrix*) = &psi;
gsl_matrix* (*g_fSimulator)(int) = &inverted_pendulum_simulator;
gsl_matrix* (*g_fS_0)(void) = &initial_state;
unsigned int g_iMax_episode_len = 30; //Shorter episodes are 
//better for MC, as s_0 is seen more often
#+end_src

We use the answer from LSPI as an expert. LSPI is fed with quite a large number of samples and thus is successful at solving the MDP.
#+begin_src c :tangle plot.c :main no
int main( void ){
  fprintf(stderr,"Training the expert...");
  fflush( NULL );
  gsl_matrix* D = file2matrix( D_FILE_NAME, TRANS_WIDTH );
  g_mActions = file2matrix( ACTION_FILE, g_iA );
  gsl_matrix* omega_0 = gsl_matrix_calloc( g_iK, 1 );
  gsl_matrix* omega_expert = lspi( D, omega_0 );
  g_mOmega_E = omega_expert;
  expert_just_set();
  fprintf(stderr,"done\n");
#+end_src
  
We the analyze the behavior of both variants of the IRL algorithm, with respect of the number of samples fed to LSPI.
#+begin_src c :tangle plot.c :main no
  gsl_matrix* D_expert;
  int D_len[] = {1,200,300,400,500,600,700,800,900,1000,1100,1200,1300,1400,1500,1600,1700,1800,1900,2000,3000};
  //Cette courbe illustre l'influence de
  // la taille de D sur les deux variantes
  for( int j=0; j<21;j++){
    g_iNb_samples = 0;
    g_mOmega =  omega_expert;
    g_iMax_episode_len = 100;
    D_expert = inverted_pendulum_simulator( 1 );
    unsigned int nb_samples_exp = g_iNb_samples;
    gsl_matrix_view sub_D = 
      gsl_matrix_submatrix( D, 0, 0, D_len[j], TRANS_WIDTH );
    g_iMax_episode_len = 100;
    gsl_matrix* omega_lstd =
      proj_lstd_lspi_ANIRL( D_expert, &sub_D.matrix );
    g_mOmega = omega_lstd;
    g_iNb_samples = 0;
    g_iMax_episode_len = 3000;
    gsl_matrix* discard = inverted_pendulum_simulator( 100 );
    gsl_matrix_free( discard );
    unsigned int mean_control_steps = g_iNb_samples/100;
    gsl_matrix_free( omega_lstd );
    printf("LSTD %d %d %d\n", nb_samples_exp,
	   D_len[j],  mean_control_steps );
    g_iMax_episode_len = 100;
    gsl_matrix* omega_mc =
      proj_mc_lspi_ANIRL( D_expert, &sub_D.matrix, 2000 );
    g_mOmega = omega_mc;
    g_iNb_samples = 0;
    g_iMax_episode_len = 3000;
    discard = inverted_pendulum_simulator( 100 );
    gsl_matrix_free( discard );
    mean_control_steps = g_iNb_samples/100;
    gsl_matrix_free( omega_mc );
    printf("MC %d %d %d\n", nb_samples_exp,
	   D_len[j],  mean_control_steps );
    
    gsl_matrix_free( D_expert );    
    } 
  
  gsl_matrix_free( g_mActions );
  gsl_matrix_free( omega_expert );
  expert_free();
  gsl_matrix_free( D );
  gsl_matrix_free( omega_0 );
  return 0;
}
#+end_src

* Gnuplot instructions
  The different figures are made thanks to the following snippets :
** Sensitivity of the quality of the policy to the number of samples fed to LSPI (No error bars)
  #+begin_src gnuplot :tangle threshold.gp
#Plot showing the threshold at which LSTDmu starts working
set term epslatex color
set output 'threshold.eps'
set grid
set xlabel 'Number of sub-optimal samples given to LSPI'
set ylabel 'Number of balancing steps for the best policy'
set key width -100
plot 'threshold_lstd.dat' u 1:2 w lines title 'LSTD' ls 1, 'threshold_lstd.dat' u 1:2 w points ls 1 notitle,\
'threshold_mc.dat' u 1:2 w lines title 'MC' ls 2, 'threshold_mc.dat' u 1:2 w points ls 2 notitle
  #+end_src
** Sensitivity of the quality of the policy to the number of samples fed to LSPI (With error bars)
  #+begin_src gnuplot :tangle threshold_EB.gp
#Plot showing the threshold at which LSTDmu starts working
set term epslatex color
set output 'threshold_EB.eps'
set grid
set xlabel 'Number of sub-optimal samples given to LSPI'
set ylabel 'Number of balancing steps for the best policy'
set key width -100
plot 'threshold_lstd.dat-0' u 1:2 w lines title 'LSTD' ls 1, 'threshold_lstd.dat-0' u 1:2:3 w errorbars ls 1 notitle,\
'threshold_mc.dat-0' u 1:2 w lines title 'MC' ls 2, 'threshold_mc.dat-0' u 1:2:3 w errorbars ls 2 notitle
#+end_src
* Error Bars
  Making graphs with error bars is a process that can be automated thanks to a python script I wrote.
  The makefile rule to call this script is :
  #+srcname: LSTDmu_Exp_make
  #+begin_src makefile

ErrorBars: conf.py threshold_lstd.dat threshold_mc.dat
	../../Utils/ErrorBars.py
  #+end_src

  The python file that configures this script for our setting is :
  #+begin_src python :tangle conf.py
g_nlInput = ['threshold_lstd.dat', ['-d" " -f\'1 2\''], [],
             'threshold_mc.dat', ['-d" " -f\'1 2\''], []]
g_iN = 100
  #+end_src
  
  Removing the data generated by the ErrorBars script is called nuking. It is not put in the clean target because to do it, you should really want to do it.
  #+srcname:LSTDmu_Exp_nuke_make
    #+begin_src makefile
nuke: #You probably don't want to make this one
	find ErrorBars/ -maxdepth 1 -iname "*.dat*" | xargs $(XARGS_OPT) rm
    #+end_src

* Makefile Rules
** Tangling
   #+srcname: LSTDmu_Exp_code_make
#+begin_src makefile
plot.c: plot.org 
	$(call tangle,"plot.org")
threshold.gp: plot.org 
	$(call tangle,"plot.org")
threshold_EB.gp: plot.org 
	$(call tangle,"plot.org")
conf.py: LSTDmu_Exp.org 
	$(call tangle,"LSTDmu_Exp.org")
#+end_src
** Parent Dir targets
       On a besoin de code se trouvant dans des fichiers du répertoire parent de celui-ci. Les quelques règles Makefile ci dessous permettent de s'assurer que ces fichiers sont bien là.
#+srcname: LSTDmu_Exp_make
#+begin_src makefile
../utils.o:
	make -C .. utils.o

../greedy.o:
	make -C .. greedy.o

../LSTDQ.o:
	make -C .. LSTDQ.o

../abbeel2004apprenticeship.o:
	make -C .. abbeel2004apprenticeship.o

../LSTDmu.o:
	make -C .. LSTDmu.o

../criteria.o:
	make -C .. criteria.o

../LSPI.o:
	make -C .. LSPI.o

../utils.h:
	make -C .. utils.h

../greedy.h:
	make -C .. greedy.h

../LSTDQ.h:
	make -C .. LSTDQ.h

../abbeel2004apprenticeship.h:
	make -C .. abbeel2004apprenticeship.h

../LSTDmu.h:
	make -C .. LSTDmu.h

../criteria.h:
	make -C .. criteria.h

../LSPI.h:
	make -C .. LSPI.h

../RL_Globals.h:
	make -C .. RL_Globals.h

../IRL_Globals.h:
	make -C .. IRL_Globals.h

#+end_src
** C source to .o files
#+srcname: LSTDmu_Exp_c2o_make
#+begin_src makefile
plot.o: plot.c InvertedPendulum.h ../utils.h ../LSPI.h ../greedy.h simulator.h ../abbeel2004apprenticeship.h ../LSTDmu.h ../criteria.h ../RL_Globals.h ../IRL_Globals.h
	$(call c2obj,"plot.c")
#+end_src
** .o to .exe
#+srcname: LSTDmu_Exp_o2exe_make
#+begin_src makefile
plot.exe: plot.o ../utils.o ../LSPI.o simulator.o ../greedy.o ../LSTDQ.o ../abbeel2004apprenticeship.o ../LSTDmu.o ../criteria.o InvertedPendulum.o
	$(O2EXE) -o plot.exe plot.o ../utils.o ../LSPI.o simulator.o ../greedy.o ../LSTDQ.o ../abbeel2004apprenticeship.o ../LSTDmu.o ../criteria.o InvertedPendulum.o
#+end_src
   
** Experiment targets
*** Generating the data :
  #+srcname: LSTDmu_Exp_make
  #+begin_src makefile
plot.dat: plot.samples plot.exe
	./plot.exe > plot.dat

plot.samples: generator.exe 
	./generator.exe > Samples.dat && touch plot.samples
#+end_src
*** Sensitivity of the quality of the policy to the number of samples fed to LSPI (No error bars)
    #+srcname: LSTDmu_Exp_make
  #+begin_src makefile
threshold.tex: threshold.pdf
	cat threshold.tex | sed "s|threshold|../Code/InvertedPendulum/threshold|g" > tmp.tex && mv tmp.tex threshold.tex

threshold.pdf: threshold.eps
	epstopdf threshold.eps

threshold.eps: threshold_lstd.dat threshold_mc.dat threshold.gp
	gnuplot threshold.gp

threshold_lstd.dat: plot.dat
	cat plot.dat | grep "^LSTD" | sed 's/LSTD //' | cut -d' ' -f'2 3' > threshold_lstd.dat

threshold_mc.dat: plot.dat
	cat plot.dat | grep "MC" | sed 's/MC //' | cut -d' ' -f'2 3' > threshold_mc.dat


  #+end_src

*** Sensitivity of the quality of the policy to the number of samples fed to LSPI (With error bars)
  #+srcname: LSTDmu_Exp_make
  #+begin_src makefile
threshold_EB.tex: threshold_EB.pdf
	cat threshold_EB.tex | sed "s|threshold_EB|../Code/InvertedPendulum/threshold_EB|g" > tmp.tex && mv tmp.tex threshold_EB.tex

threshold_EB.pdf: threshold_EB.eps
	epstopdf threshold_EB.eps

threshold_EB.eps: threshold_lstd.dat-0 threshold_mc.dat-0 threshold_EB.gp ErrorBars
	gnuplot threshold_EB.gp

threshold_lstd.dat-0: ErrorBars

threshold_mc.dat-0: ErrorBars

#+end_src

** Cleaning
  #+srcname: LSTDmu_Exp_clean_make
  #+begin_src makefile
LSTDmu_Exp_clean:
	find . -maxdepth 1 -iname "threshold.gp"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "threshold_EB.gp"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "plot.c"   | xargs $(XARGS_OPT) rm 
	find . -maxdepth 1 -iname "plot.o"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "plot.exe"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "plot.dat"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "plot.samples"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "Samples.dat"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "threshold.tex"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "threshold.pdf"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "threshold.eps"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "threshold_lstd.dat"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "threshold_mc.dat"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "threshold_EB.tex"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "threshold_EB.pdf"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "threshold_EB.eps"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "threshold_lstd.dat-0"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "threshold_mc.dat-0"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "conf.py"   | xargs $(XARGS_OPT) rm

  #+end_src
