#+TITLE: Expérience pour quantifier empiriquement la qualité de LAFEM
* Description

  Dans cette quatrième expérience, un expert est entraîné sur le problème du pendule inversé. Il fournit quelques transitions, le calcul de $\mu_E$ est est effectué grâce à LSTD$\mu$, une fonction de perte simple ($1$ en cas de désaccord avec l'expert, $0$ sinon), une initialisation de la récompense à une valeur négative partout.

  Le but de l'expérience est, sachant que l'[[file:LAFEM_Exp3.org][expérience 3]] a fonctionné, de quantifier la qualité de la récompense fournie par l'algorithme en fonction de la quantitié de données disponibles.

  Il y a beaucoup de code commun avec la [[file:LAFEM_Exp2.org][seconde expérience]] et [[file:LAFEM_Exp3.org][troisième expérience]], on reprend notamment certains targets du Makefile.

  L'expérience se déroule comme suit :
  - [ ] Créer une base de données $D_0$ de transitions aléatoires.
  - [ ] Entraîner un expert en utilisant LSPI nourri avec ces transitions ($\pi_E : S\rightarrow A$)
  - [ ] Vérifier que l'expert est en mesure de balancer le pendule durant 3000 pas de temps
  - [ ] Créer une base de données $D_E$ de transitions de l'expert. On la crée de 10 trajectoires de 300 transitions chacune.
  - [ ] Définir $l$ telle que $l(s,a) = 0$ si $a=\pi_E(s)$, $1$ sinon, $l$ est définie sur les états présents dans $D_E$.
  - [ ] Définir $\alpha(t) = 0.1,\forall t$ (pifomètre)
  - [ ] Fixer $T=20$ (pifomètre)
  - [ ] Pour différentes quantités de données $N$,
    - [ ] Définir $D_E^N$ en tronquant $D_E$ à ses $N$ premières transitions
    - [ ] Définir $D$ à partir des de $D_E^N$ en enlevant l'état d'arrivée
    - [ ] Définir $\mu_E(s,a) = E\left.\left[\sum\limits_{t=0}^\infty \gamma^t \phi(s)\right|s_0 = s, a_0 = a, \pi_E\right]$ comme étant en pratique $\hat\mu_E(s,a) =  \omega^T_{\pi_E}\phi(s,a), \omega_{\pi_E} = LSTD\mu(D_E^N)$
    - [ ] Initialiser $\omega_0 = [-1...-1]^T$
    - [ ] Faire tourner LAFEM
    - [ ] Entrainer un agent sur le problème du pendule inversé, avec la récompense trouvée par LAFEM : définir $\pi : S\rightarrow A$
    - [ ] Regarder durant combien de pas de temps l'agent arrrive à faire tenir le pendule.
    - [ ] Tracer la courbe donnant la qualité du contrôle (nombre de pas de temps durant lequel l'agent balance le pendule) en fonction de la quantitié de données disponible ($N$)
  - [ ] Utiliser le script ErrorBars pour faire tourner le code précédent un grand nombre de fois et obtenir une courbe avec des barres d'erreur

* Code								       :code:
** Experiment targets
*** Single pass experiment
   The first task is to build the variable length data files from the expert. This is doable with the code from the [[file:LAFEM_Exp2.org][second experiment]], but it has the drawback of linking the values used in this experiment and the one used in this one. The alnertative solution would duplicate code.

   A makefile rule will take care of the creation of the data files

#+srcname: LAFEM_Exp4_make
#+begin_src makefile
N_VALUES=300 600 900 1500 3000
D_expert_X.mat: D_expert.mat #Dummy target
	for i in $(N_VALUES); do head -n $$i D_expert.mat > D_expert_$$i.mat; done
	touch D_expert_X.mat
#+end_src

   Now, using code from the [[file:LAFEM_Exp3.org][third experiment]], we can create the files containing the matrices output by the $LSTD\mu$ algorithm. The code reads the =D_expert.mat= and =omega_expert.mat= files (this is hard coded) and outuput the matrix on its standard output. The following makefile rule handles this.

#+srcname: LAFEM_Exp4_make
#+begin_src makefile
omega_mu_E_X.mat: D_expert_X.mat LAFEM_Exp3_LSTDmu.exe omega_expert.mat#Dummy target
	for i in $(N_VALUES); do\
		cp D_expert_$$i.mat D_expert.mat &&\
		./LAFEM_Exp3_LSTDmu.exe > omega_mu_E_$$i.mat;\
	done;
	touch omega_mu_E_X.mat
#+end_src


Now, we will run LAFEM using without modification the code from the [[file:LAFEM_Exp3.org][third experiment]] again. The files =D_expert.mat= and =omega_mu_E.mat= whose name are hard coded in =LAFEM_Exp3.py= are read. The following makefile rule generates the =theta_lafem_*.mat= files from the =D_expert_*.mat= and =omega_mu_E_*.mat= files.

#+srcname: LAFEM_Exp4_make
#+begin_src makefile
theta_lafem_X.mat: D_expert_X.mat omega_mu_E_X.mat ../LAFEM.py LAFEM_Exp3.py ../a2str.py #Dummy target
	for i in $(N_VALUES); do\
		cp D_expert_$$i.mat D_expert.mat &&\
		cp omega_mu_E_$$i.mat omega_mu_E.mat &&\
		python LAFEM_Exp3.py > theta_lafem_$$i.mat;\
	done;
	touch omega_mu_E_X.mat
#+end_src

One of the last steps is to try each and every of these reward vectors and see how well an agent trained with these is able to balance the pendulum. Code from [[file:LAFEM_Exp2.org][second experiment]] does just that as it outputs the length of one run on the standard error. It takes the reward vector as an argument. On its standard output it puts the $\omega$ vector of the $Q$ function for the agent, which we discard because we won't use it here.

#+srcname: LAFEM_Exp4_make
#+begin_src makefile
LAFEM_Exp4_quality.dat: theta_lafem_X.mat LAFEM_Exp2_Samples.dat LAFEM_Exp2_Results.exe
	touch LAFEM_Exp4_quality.dat
	rm LAFEM_Exp4_quality.dat #The use of >> makes it necessary to RAZ the file
	for i in $(N_VALUES); do\
		(echo -n "$$i " && ./LAFEM_Exp2_Results.exe theta_lafem_$$i.mat >/dev/null)>> LAFEM_Exp4_quality.dat 2>> LAFEM_Exp4_quality.dat;\
	done;
#+end_src

A bit of greping, tring and seding later and we have a plottable file :

#+srcname: LAFEM_Exp4_make
#+begin_src makefile
	cat LAFEM_Exp4_quality.dat | grep agent | tr "[:punct:]" " " | sed 's/ Longueur d un run de l agent  //' > toto
	mv toto LAFEM_Exp4_quality.dat
#+end_src

It can be plot using these GNUPlot instructions :
#+begin_src gnuplot :tangle LAFEM_Exp4_quality.gp
set output "LAFEM_Exp4_quality.ps"
set term postscript enhanced color
set yrange [0:3100]
set xlabel "Number of samples from the expert"
set ylabel "Number of time steps the agent can balance the pendulum"
plot "LAFEM_Exp4_quality.dat" notitle w line
#+end_src

Which are activated by the following makefile rule:
#+srcname: LAFEM_Exp4_make
#+begin_src makefile
LAFEM_Exp4_quality.gp: LAFEM_Exp4.org
	$(call tangle,"LAFEM_Exp4.org")

LAFEM_Exp4_quality.pdf: LAFEM_Exp4_quality.gp LAFEM_Exp4_quality.dat
	gnuplot LAFEM_Exp4_quality.gp
	ps2pdf LAFEM_Exp4_quality.ps
	rm LAFEM_Exp4_quality.ps
#+end_src

*** Error bars
    To generate error bars, we use the ErrorBars.py script (as in the experiment about LSTD$\mu$).

    The first thing to do is to define a clean rule to remove the file to plot and all the other files that have been used to create it, so that making it again will be a statistically independant experiment.
  #+srcname: LAFEM_Exp4_clean_make
  #+begin_src makefile
clean_LAFEM_Exp4_quality.dat: 
	find . -maxdepth 1 -iname "D_expert.mat"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "D_expert_*.mat"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "omega_mu_E_*.mat"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "theta_lafem_*.mat"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "LAFEM_Exp4_quality.*"   | xargs $(XARGS_OPT) rm

  #+end_src

    Then we make the configuration script for the error bars script :
  #+begin_src python :tangle LAFEM_Exp4_conf.py
g_nlInput = ['LAFEM_Exp4_quality.dat', ['-d" " -f\'1 2\''], []]
g_iN = 1000
  #+end_src
    Which can be tangled using :
  #+srcname: LAFEM_Exp4_make
  #+begin_src makefile
LAFEM_Exp4_conf.py: LAFEM_Exp4.org 
	$(call tangle,"LAFEM_Exp4.org")
  #+end_src


    Finally the makefile rule :
  #+srcname: LAFEM_Exp4_make
  #+begin_src makefile
LAFEM_Exp4_ErrorBars: LAFEM_Exp4_conf.py LAFEM_Exp4_quality.dat
	mv LAFEM_Exp4_conf.py conf.py
	../../Utils/ErrorBars.py
	rm conf.py
  #+end_src

The file used to plot this with the errorbars is :
  #+begin_src gnuplot :tangle LAFEM_Exp4_quality_EB.gp
set output "LAFEM_Exp4_quality_EB.ps"
set term postscript enhanced color
set yrange [0:3100]
set xlabel "Number of samples from the expert"
set ylabel "Number of time steps the agent can balance the pendulum"
plot 'LAFEM_Exp4_quality.dat-0' u 1:2 w lines ls 1 notitle, 'LAFEM_Exp4_quality.dat-0' u 1:2:3 w errorbars ls 1 notitle
#+end_src

It is activated by :
Which are activated by the following makefile rule:
#+srcname: LAFEM_Exp4_make
#+begin_src makefile
LAFEM_Exp4_quality_EB.gp: LAFEM_Exp4.org
	$(call tangle,"LAFEM_Exp4.org")

LAFEM_Exp4_quality_EB.pdf: LAFEM_Exp4_quality_EB.gp LAFEM_Exp4_ErrorBars
	gnuplot LAFEM_Exp4_quality_EB.gp
	ps2pdf LAFEM_Exp4_quality_EB.ps
	rm LAFEM_Exp4_quality_EB.ps
#+end_src


** Cleaning
   A rule to clean the mess :
  #+srcname: LAFEM_Exp4_clean_make
  #+begin_src makefile
LAFEM_Exp4_clean: LAFEM_Exp3_clean LAFEM_Exp2_clean
	find . -maxdepth 1 -iname "D_expert_*.mat"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "omega_mu_E_*.mat"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "theta_lafem_*.mat"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "LAFEM_Exp4_quality.*"   | xargs $(XARGS_OPT) rm
  #+end_src

* Résultats
