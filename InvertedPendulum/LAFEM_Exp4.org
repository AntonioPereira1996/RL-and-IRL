#+TITLE: Expérience pour quantifier empiriquement la qualité de LAFEM
* Description

  Dans cette quatrième expérience, un expert est entraîné sur le problème du pendule inversé. Il fournit quelques transitions, le calcul de $\mu_E$ est est effectué grâce à LSTD$\mu$, une fonction de perte simple ($1$ en cas de désaccord avec l'expert, $0$ sinon), une initialisation de la récompense à une valeur négative partout.

  Le but de l'expérience est, sachant que l'[[file:LAFEM_Exp3.org][expérience 3]] a fonctionné, de quantifier la qualité de la récompense fournie par l'algorithme en fonction de la quantitié de données disponibles.

  Il y a beaucoup de code commun avec la [[file:LAFEM_Exp2.org][seconde expérience]] et [[file:LAFEM_Exp3.org][troisième expérience]], on reprend notamment certains targets du Makefile.

  L'expérience se déroule comme suit :
  - [ ] Créer une base de données $D_0$ de transitions aléatoires.
  - [ ] Entraîner un expert en utilisant LSPI nourri avec ces transitions ($\pi_E : S\rightarrow A$)
  - [ ] Vérifier que l'expert est en mesure de balancer le pendule durant 3000 pas de temps
  - [ ] Créer une base de données $D_E$ de transitions de l'expert. On la crée de 10 trajectoires de 300 transitions chacune.
  - [ ] Définir $l$ telle que $l(s,a) = 0$ si $a=\pi_E(s)$, $1$ sinon, $l$ est définie sur les états présents dans $D_E$.
  - [ ] Définir $\alpha(t) = 0.1,\forall t$ (pifomètre)
  - [ ] Fixer $T=20$ (pifomètre)
  - [ ] Pour différentes quantités de données $N$,
    - [ ] Définir $D_E^N$ en tronquant $D_E$ à ses $N$ premières transitions
    - [ ] Définir $D$ à partir des de $D_E^N$ en enlevant l'état d'arrivée
    - [ ] Définir $\mu_E(s,a) = E\left.\left[\sum\limits_{t=0}^\infty \gamma^t \phi(s)\right|s_0 = s, a_0 = a, \pi_E\right]$ comme étant en pratique $\hat\mu_E(s,a) =  \omega^T_{\pi_E}\phi(s,a), \omega_{\pi_E} = LSTD\mu(D_E^N)$
    - [ ] Initialiser $\omega_0 = [-1...-1]^T$
    - [ ] Faire tourner LAFEM
    - [ ] Entrainer un agent sur le problème du pendule inversé, avec la récompense trouvée par LAFEM : définir $\pi : S\rightarrow A$
    - [ ] Regarder durant combien de pas de temps l'agent arrrive à faire tenir le pendule.
    - [ ] Tracer la courbe donnant la qualité du contrôle (nombre de pas de temps durant lequel l'agent balance le pendule) en fonction de la quantitié de données disponible ($N$)
  - [ ] Utiliser le script ErrorBars pour faire tourner le code précédent un grand nombre de fois et obtenir une courbe avec des barres d'erreur

* Code								       :code:
** Experiment targets
   The first task is to build the variable length data files from the expert. This is doable with the code from the [[file:LAFEM_Exp2.org][second experiment]], but it has the drawback of linking the values used in this experiment and the one used in this one. The alnertative solution would duplicate code.

   A makefile rule will take care of the creation of the data files

#+srcname: LAFEM_Exp4_make
#+begin_src makefile
N_VALUES=300 600 900 1500 3000
D_expert_X.mat: D_expert.mat #Dummy target
	for i in $(N_VALUES); do head -n $$i D_expert.mat > D_expert_$$i.mat; done
	touch D_expert_X.mat
#+end_src

   Now, using code from the [[file:LAFEM_Exp3.org][third experiment]], we can create the files containing the matrices output by the $LSTD\mu$ algorithm. The code reads the =D_expert.mat= and =omega_expert.mat= files (this is hard coded) and outuput the matrix on its standard output. The following makefile rule handles this.

#+srcname: LAFEM_Exp4_make
#+begin_src makefile
omega_mu_E_X.mat: D_expert_X.mat LAFEM_Exp3_LSTDmu.exe omega_expert.mat#Dummy target
	for i in $(N_VALUES); do\
		cp D_expert_$$i.mat D_expert.mat &&\
		./LAFEM_Exp3_LSTDmu.exe > omega_mu_E_$$i.mat;\
	done;
	rm D_expert.mat
	touch omega_mu_E_X.mat
#+end_src


Now, we will run LAFEM using without modification the code from the [[file:LAFEM_Exp3.org][third experiment]] again. The files =D_expert.mat= and =omega_mu_E.mat= whose name are hard coded in =LAFEM_Exp3.py= are read. The following makefile rule generates the =theta_lafem_*.mat= files from the =D_expert_*.mat= and =omega_mu_E_*.mat= files.

#+srcname: LAFEM_Exp4_make
#+begin_src makefile
theta_lafem_X.mat: D_expert_X.mat omega_mu_E_X.mat ../LAFEM.py LAFEM_Exp3.py ../a2str.py #Dummy target
	for i in $(N_VALUES); do\
		cp D_expert_$$i.mat D_expert.mat &&\
		cp omega_mu_E_$$i.mat omega_mu_E.mat &&\
		python LAFEM_Exp3.py > theta_lafem_$$i.mat;\
	done;
	rm D_expert.mat
	rm omega_mu_E.mat
	touch omega_mu_E_X.mat
#+end_src

One of the last steps is to try each and every of these reward vectors and see how well an agent trained with these is able to balance the pendulum. Code from [[file:LAFEM_Exp2.org][second experiment]] does just that as it outputs the length of one run on the standard error. It takes the reward vector as an argument. On its standard output it puts the $\omega$ vector of the $Q$ function for the agent, which we discard because we won't use it here.

#+srcname: LAFEM_Exp4_make
#+begin_src makefile
LAFEM_Exp4_quality.dat: theta_lafem_X.mat LAFEM_Exp2_Samples.dat LAFEM_Exp2_Results.exe
	touch LAFEM_Exp4_quality.dat
	rm LAFEM_Exp4_quality.dat #The use of >> makes it necessary to RAZ the file
	for i in $(N_VALUES); do\
		(echo -n "$$i " && ./LAFEM_Exp2_Results.exe theta_lafem_$$i.mat >/dev/null)>> LAFEM_Exp4_quality.dat 2>> LAFEM_Exp4_quality.dat;\
	done;
#+end_src





** Cleaning
   A rule to clean the mess :
  #+srcname: LAFEM_Exp3_clean_make
  #+begin_src makefile
LAFEM_Exp4_clean: LAFEM_Exp3_clean LAFEM_Exp2_clean
	find . -maxdepth 1 -iname "D_expert_*.mat"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "omega_mu_E_*.mat"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "theta_lafem_*.mat"   | xargs $(XARGS_OPT) rm
  #+end_src

* Résultats
