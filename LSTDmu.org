#+TITLE: Abbeel and Ng's IRL algorithm with LSTD estimation of the feature expectation

FIXME: Il faudrait séparer le code de LSTDmu utilisable par tous les algos d'IRL et le code de l'ANIRL (qui a besoin de LSPI and co).

  In their paper, \cite{abbeel2004apprenticeship}, Ng and Abbeel present an IRL algorithm. This file is an implementation of this algorithm in its projection form, but using a LSTD method to estimate $\mu_E$ and $\mu$ and using LSPI to solve the MDP.
* LSTD$\mu$ header
** On policy estimation of $E[\mu(s_0)]$
*** Détails techniques
#+begin_src C
#include "LSTDmu.h"

unsigned int g_iP = -1;
unsigned int g_iA = -1;
unsigned int g_iS = -1;
gsl_matrix* (g_fPsi)(gsl_matrix*) = NULL;
double g_dGamma_anirl = -1;
double g_dLambda_lstdmu = -1;
gsl_matrix* (g_fS_0)() = NULL;

gsl_matrix* mu_s0 = lstd_mu_op(  gsl_matrix* D_mu );
#+end_src
*** Entrées
    - =D_mu= : Matrice dont chaque ligne a la forme  $(s,a,s',\psi(s)^T,eoe)$
*** Sorties
    - Une estimation de $E[\mu(s_0)]$ pour la politique ayant créé les données fournies en entrée
*** Paramètres
    - =g_fPsi= : fonction de feature de $S$ dans $\mathbf{R}^p$
    - =g_dGamma_anirl= : Coefficient d'amortissement FIXME: le nom (*_anirl) est mal choisi
    - =g_dLambda_lstdmu= : Coefficient de régularisation utilisé dans l'expression : $\tilde \omega^\pi \leftarrow (\tilde A + \lambda Id) ^{-1}\tilde b$
    - =g_fS_0= : Fonction renvoyant la matrice des états initiaux (un par ligne) sur lesquels l'estimation de monte carlo de l'espérance sera caclculée.

** On policy estimation of $\mu(s,a)$
*** Détails techniques
#+begin_src C
#include "LSTDmu.h"

unsigned int g_iP = -1;
unsigned int g_iK = -1;
unsigned int g_iA = -1;
unsigned int g_iS = -1;
gsl_matrix* (g_fPhi)(gsl_matrix*) = NULL;
double g_dGamma_anirl = -1;
double g_dLambda_lstdmu = -1;

gsl_matrix* omega_mu = lstd_mu_op_omega(  gsl_matrix* D_mu );
#+end_src
*** Entrées
    - =D_mu= : Matrice dont chaque ligne a la forme  $(s,a,s',\psi(s)^T,eoe)$
*** Sorties
    - Une matrice $\omega_\mu$ telle que $\hat \mu(s,a) = \omega_\mu^T\phi(s,a)$
*** Paramètres
    - =g_fPhi= : fonction de feature de $S\times A$ dans $\mathbf{R}^p$
    - =g_dGamma_anirl= : Coefficient d'amortissement FIXME: le nom (*_anirl) est mal choisi
    - =g_dLambda_lstdmu= : Coefficient de régularisation utilisé dans l'expression : $\tilde \omega^\pi \leftarrow (\tilde A + \lambda Id) ^{-1}\tilde b$

** Off policy estimation of $\mu(s,a)$
*** Détails techniques
#+begin_src C
#include "LSTDmu.h"

unsigned int g_iP = -1;
unsigned int g_iK = -1;
unsigned int g_iA = -1;
unsigned int g_iS = -1;
gsl_matrix* (g_fPhi)(gsl_matrix*) = NULL;
double g_dGamma_anirl = -1;
double g_dLambda_lstdmu = -1;

gsl_matrix* omega_mu = lstd_mu_omega(  gsl_matrix* D_mu, 
 		      gsl_matrix* (*pi)(gsl_matrix*));

#+end_src
*** Entrées
    - =D_mu= : Matrice dont chaque ligne a la forme  $(s,a,s',\psi(s)^T,eoe)$
    - =pi= : Politique associant une action à un état
*** Sorties
    - Une matrice $\omega_\mu$ telle que $\hat \mu(s,a) = \omega_\mu^T\phi(s,a)$ pour la politique fournie en argument
*** Paramètres
    - =g_fPhi= : fonction de feature de $S\times A$ dans $\mathbf{R}^p$
    - =g_dGamma_anirl= : Coefficient d'amortissement FIXME: le nom (*_anirl) est mal choisi
    - =g_dLambda_lstdmu= : Coefficient de régularisation utilisé dans l'expression : $\tilde \omega^\pi \leftarrow (\tilde A + \lambda Id) ^{-1}\tilde b$

** Off policy estimation of  $E[\mu(s_0)]$
*** Détails techniques
#+begin_src C
#include "LSTDmu.h"

unsigned int g_iP = -1;
unsigned int g_iA = -1;
unsigned int g_iS = -1;
gsl_matrix* (g_fPsi)(gsl_matrix*) = NULL;
double g_dGamma_anirl = -1;
double g_dLambda_lstdmu = -1;
gsl_matrix* (g_fS_0)() = NULL;

gsl_matrix* mu_s0 = lstd_mu_op(  gsl_matrix* D_mu );
#+end_src
*** Entrées
    - =D_mu= : Matrice dont chaque ligne a la forme  $(s,a,s',\psi(s)^T,eoe)$
    - =pi= : Politique associant une action à un état
*** Sorties
    - Une estimation de $E[\mu(s_0)]$ pour la politique fournie en argument
*** Paramètres
    - =g_fPsi= : fonction de feature de $S$ dans $\mathbf{R}^p$
    - =g_dGamma_anirl= : Coefficient d'amortissement FIXME: le nom (*_anirl) est mal choisi
    - =g_dLambda_lstdmu= : Coefficient de régularisation utilisé dans l'expression : $\tilde \omega^\pi \leftarrow (\tilde A + \lambda Id) ^{-1}\tilde b$
    - =g_fS_0= : Fonction renvoyant la matrice des états initiaux (un par ligne) sur lesquels l'estimation de monte carlo de l'espérance sera caclculée.
* ANIRL header
** Détails techniques
#+begin_src C
#include "LSTDmu.h"

unsigned int g_iK = -1;
unsigned int g_iP = -1;
gsl_matrix* (*g_fPsi)(gsl_matrix*) = NULL;
double g_dEpsilon_anirl = -1;
unsigned int g_iIt_max_anirl = -1;

gsl_matrix* omega = proj_lstd_lspi_ANIRL( gsl_matrix* D_E, 
				  gsl_matrix* D )
#+end_src
** Entrées
   - =D_E= : données provenant de l'expert
   - =D= : données arbitraires permettant l'évaluation /off-policy/ à l'aide de LSTD$\mu$
** Sorties
   - =omega= : matrice correspondant à la fonction de qualité de la politique la plus proche de celle de l'expert rencontrée par l'algorithme
** Paramètres
   - =g_dEpsilon_anirl= : Seuil pour l'arrêt
   - =g_iIt_max_anirl= : Nombre maximum d'itérations

   Il faut également régler les paramètres de [[file:LSPI.org][LSPI]] et ceux de LSTD$\mu$.
* C implementation
** Externals
*** ANIRL
   #+begin_src c :tangle LSTDmu.h :main no
gsl_matrix* proj_lstd_lspi_ANIRL( gsl_matrix* D_E, 
				  gsl_matrix* D );
   #+end_src
   Most of its arguments are passed via gobal variables (see [[file:RL_Globals.org][here]] and [[file:IRL_Globals.org][here]]), the $D_E$ matrix are the trajectories from the expert, and the $D$ matrix are the transitions to be fed to LSPI.

   It returns the $\omega$ matrix which defines the optimal policy as found by LSPI under the reward $R = \theta^T\psi$. Note that $\omega \equiv \pi$, in other words, ou aproximation of the value function defines the greedy policy.
*** LSTD$\mu$
   #+begin_src c :tangle LSTDmu.h :main no
gsl_matrix* lstd_mu_omega( gsl_matrix* D_mu, 
			   gsl_matrix* (*pi)(gsl_matrix*) );
   #+end_src 

    This returns the $\omega_\pi$ matrix that allows for the computation of $\mu_\pi(s,a) = \omega^T_\pi\phi(s,a)$, for the policy $\pi$ given in argument, computed from the data matrix $D_\mu$ whose format is $(s,a,s',\psi(s)^T,eoe)$.

   #+begin_src c :tangle LSTDmu.h :main no
gsl_matrix* lstd_mu_op_omega(  gsl_matrix* D_mu );
   #+end_src 
    This returns the $\omega_\pi$ matrix that allows for the computation of $\mu_\pi(s,a) = \omega^T_\pi\phi(s,a)$, for the policy that generated the data given in argument.
** Internals
   We use the GSL and some neighbooring code.
   #+begin_src c :tangle LSTDmu.c :main no
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_blas.h>
#include <gsl/gsl_permutation.h>
#include <gsl/gsl_linalg.h>
#include <math.h>
#include "greedy.h"
#include "utils.h"
#include "criteria.h"
#include "LSPI.h"
#include "RL_Globals.h"
#include "IRL_Globals.h"
   #+end_src
*** On-policy LSTD estimation of $\mu$
   One way to estimate $\mu$ is to do it in an /on-policy/ setting, this is typically used for the expert.
   #+begin_src c :tangle LSTDmu.c :main no
gsl_matrix* lstd_mu_op(  gsl_matrix* D_mu ){
   #+end_src
   - $\tilde A \leftarrow 0$
     #+begin_src c :tangle LSTDmu.c :main no
  gsl_matrix* A = gsl_matrix_calloc( g_iP, g_iP );
     #+end_src
   - $\tilde b \leftarrow 0$
     #+begin_src c :tangle LSTDmu.c :main no
  gsl_matrix* b = gsl_matrix_calloc( g_iP, g_iP );
     #+end_src
   - for each $(s,a,s',\psi(s)^T,eoe) \in D_\mu$
     #+begin_src c :tangle LSTDmu.c :main no
  for( unsigned int i=0; i < D_mu->size1 ; i++ ){
     #+end_src
     - $\tilde A \leftarrow \tilde A + \psi(s)\left(\psi(s) - \gamma \psi(s')\right)^T$
       #+begin_src c :tangle LSTDmu.c :main no
      gsl_matrix_view psi_s = 
	gsl_matrix_submatrix( D_mu, i, g_iS+g_iA+g_iS, 1, g_iP );
      gsl_matrix_view s_dash = 
	gsl_matrix_submatrix( D_mu, i, g_iS+g_iA, 1, g_iS);
      gsl_matrix* psi_dash = g_fPsi( &s_dash.matrix );
      gsl_matrix_scale( psi_dash, g_dGamma_anirl );
      double eoe = gsl_matrix_get( D_mu, i, g_iS+g_iA+g_iS+g_iP );
      gsl_matrix_scale( psi_dash, eoe );
      gsl_matrix* delta_psi = gsl_matrix_calloc( g_iP, 1 );
      gsl_matrix_transpose_memcpy( delta_psi, &psi_s.matrix );
      gsl_matrix_sub( delta_psi, psi_dash );
      gsl_matrix* deltaA = gsl_matrix_calloc( g_iP, g_iP );
      gsl_blas_dgemm( CblasTrans, CblasTrans, 1., 
			&psi_s.matrix, delta_psi, 0., deltaA);
      gsl_matrix_add( A, deltaA );
       #+end_src
     - $\tilde b \leftarrow \tilde b + \psi(s)\psi(s)^T$
       #+begin_src c :tangle LSTDmu.c :main no
      gsl_matrix* delta_b = gsl_matrix_alloc( g_iP, g_iP );
      /* \psi(s) is in line in the code but in column in the 
       comments */
      gsl_blas_dgemm( CblasTrans, CblasNoTrans, 1.0,
		      &psi_s.matrix, &psi_s.matrix, 0.0, delta_b );
      gsl_matrix_add( b, delta_b );
      gsl_matrix_free( deltaA );
      gsl_matrix_free( delta_psi );
      gsl_matrix_free( psi_dash );
      gsl_matrix_free( delta_b );
    }
       #+end_src
   - $\tilde \omega^\pi \leftarrow (\tilde A + \lambda Id) ^{-1}\tilde b$
     #+begin_src c :tangle LSTDmu.c :main no
  gsl_matrix* lambdaI = gsl_matrix_alloc( A->size1, A->size2 );
  gsl_matrix_set_identity( lambdaI );
  gsl_matrix_scale( lambdaI, g_dLambda_lstdmu );
  gsl_matrix_add( A, lambdaI );
  gsl_matrix_free( lambdaI );
  gsl_matrix* omega_pi = gsl_matrix_alloc( g_iP, g_iP );
  gsl_permutation* p = gsl_permutation_alloc( g_iP );
  int signum;
  gsl_linalg_LU_decomp( A, p, &signum );
  for( unsigned int i = 0 ; i < g_iP ; i++ ){
    gsl_vector_view b_v = gsl_matrix_column( b, i );
    gsl_vector_view o_v = gsl_matrix_column( omega_pi, i );
    gsl_linalg_LU_solve( A, p, &b_v.vector, &o_v.vector );
  }
  gsl_permutation_free( p );
  gsl_matrix_free( A );
  gsl_matrix_free( b );
     #+end_src
   - $\mu_\pi(s_0) \leftarrow \sum\limits_{s_0}\tilde\omega_\pi^T\psi(s_0)$ FIXME:dire que c'est une espérance et mettre un 1/N dans la somme
     #+begin_src c :tangle LSTDmu.c :main no
  gsl_matrix* s_0 = g_fS_0();
  gsl_matrix* mu = gsl_matrix_calloc( g_iP, 1 );
  gsl_matrix* delta_mu = gsl_matrix_alloc( g_iP, 1 );
  for( unsigned int i = 0; i<s_0->size1;i++){
    gsl_matrix_view mS_0 = gsl_matrix_submatrix( s_0, i, 0, 
						 1, g_iS );
    gsl_matrix* psi_s_0 = g_fPsi( &mS_0.matrix );
    gsl_blas_dgemm( CblasTrans, CblasNoTrans, 1.0,
		    omega_pi, psi_s_0, 0.0, delta_mu );
    gsl_matrix_add( mu, delta_mu );
    gsl_matrix_free( psi_s_0 );
  }
  gsl_matrix_scale( mu, 1./((double)s_0->size1) );
  gsl_matrix_free( delta_mu );
  gsl_matrix_free( omega_pi );
  gsl_matrix_free( s_0 );
  return mu;
}
     #+end_src

     We also may want to estimate the $\mu : S\times A \rightarrow \mathbb{R}^k$ function in an /on-policy/ manner. We do this with the $\omega_\pi$ matrix : $\hat \mu(s,a) = \omega_\pi^T\phi(s,a)$. One can get this matrix thanks to the following function :
     FIXME: Utiliser cette fonction dans InvertedPendulum/LAFEM_Exp3 (elle a été créée après coup)
     FIXME: Changer le nom de ces fonctions et nettoyer un peu tout ça
   #+begin_src c :tangle LSTDmu.c :main no
gsl_matrix* lstd_mu_op_omega(  gsl_matrix* D_mu ){
   #+end_src
    - $\tilde A \leftarrow 0$
      #+begin_src c :tangle LSTDmu.c :main no
  gsl_matrix* A = gsl_matrix_calloc( g_iK, g_iK );
      #+end_src
    - $\tilde b \leftarrow 0$
      #+begin_src c :tangle LSTDmu.c :main no
  gsl_matrix* b = gsl_matrix_calloc( g_iK, g_iP );
      #+end_src
    - for each $(s,a,s',\psi(s)^T,eoe) \in D_\mu$
      #+begin_src c :tangle LSTDmu.c :main no
  for( unsigned int i=0; i < D_mu->size1 - 1; i++ ){ //The last sample is unusable because we don't know pi(s')
      #+end_src
      - $\tilde A \leftarrow \tilde A + \phi(s,a)\left(\phi(s,a) - \gamma \phi(s',a')\right)^T$
        #+begin_src c :tangle LSTDmu.c :main no
    gsl_matrix_view sa = 
      gsl_matrix_submatrix( D_mu, i, 0, 1, g_iS+g_iA);
    gsl_matrix* phi_sa = g_fPhi( &sa.matrix );
    gsl_matrix* sa_dash = gsl_matrix_calloc( 1, g_iS+g_iA );
    gsl_matrix_view sdash_dst = gsl_matrix_submatrix( sa_dash, 
						      0, 0,
						      1, g_iS );
    gsl_matrix_view sdash_src = 
      gsl_matrix_submatrix( D_mu, i, g_iS+g_iA, 1, g_iS);
    gsl_matrix_memcpy( &sdash_dst.matrix, &sdash_src.matrix );
    gsl_matrix_view adash_dst = 
      gsl_matrix_submatrix( sa_dash, 0, g_iS, 1, g_iA );
    gsl_matrix_view adash_src = 
      gsl_matrix_submatrix( D_mu, i+1, g_iS, 1, g_iA );
    gsl_matrix_memcpy( &adash_dst.matrix, &adash_src.matrix );
    gsl_matrix* phi_dash = g_fPhi( sa_dash );
    gsl_matrix_scale( phi_dash, g_dGamma_anirl );
    double eoe = gsl_matrix_get( D_mu, i, g_iS+g_iA+g_iS+g_iP );
    gsl_matrix_scale( phi_dash, eoe );
    gsl_matrix* delta_phi = gsl_matrix_calloc( g_iK, 1 );
    gsl_matrix_memcpy( delta_phi, phi_sa );
    gsl_matrix_sub( delta_phi, phi_dash );
    gsl_matrix* deltaA = gsl_matrix_calloc( g_iK, g_iK );
    gsl_blas_dgemm( CblasNoTrans, CblasTrans, 1., 
		      phi_sa, delta_phi, 0., deltaA);
    gsl_matrix_add( A, deltaA );

        #+end_src
      - $\tilde b \leftarrow \tilde b + \phi(s,a)\psi(s)^T$
        #+begin_src c :tangle LSTDmu.c :main no
       gsl_matrix_view psi_s = 
	 gsl_matrix_submatrix( D_mu, i, g_iS+g_iA+g_iS, 1, g_iP );
       gsl_matrix* delta_b = gsl_matrix_alloc( g_iK, g_iP );
       /*\psi(s) is in line in the code but in column 
	 in the comments*/ 
       gsl_blas_dgemm( CblasNoTrans, CblasNoTrans, 1.0,
		       phi_sa, &psi_s.matrix, 0.0, delta_b );
       gsl_matrix_add( b, delta_b );
       gsl_matrix_free( deltaA );
       gsl_matrix_free( delta_phi );
       gsl_matrix_free( phi_dash );
       gsl_matrix_free( sa_dash );
       gsl_matrix_free( phi_sa );
       gsl_matrix_free( delta_b );
     }
       #+end_src
    - $\tilde \omega^\pi \leftarrow (\tilde A + \lambda Id) ^{-1}\tilde b$
      #+begin_src c :tangle LSTDmu.c :main no
  gsl_matrix* lambdaI = gsl_matrix_alloc( A->size1, A->size2 );
  gsl_matrix_set_identity( lambdaI );
  gsl_matrix_scale( lambdaI, g_dLambda_lstdmu );
  gsl_matrix_add( A, lambdaI );
  gsl_matrix_free( lambdaI );
  gsl_matrix* omega_pi = gsl_matrix_alloc( g_iK, g_iP );
  gsl_permutation* p = gsl_permutation_alloc( g_iK );
  int signum;
  gsl_linalg_LU_decomp( A, p, &signum );
  for( unsigned int i = 0 ; i < g_iP ; i++ ){
    gsl_vector_view b_v = gsl_matrix_column( b, i );
    gsl_vector_view o_v = gsl_matrix_column( omega_pi, i );
    gsl_linalg_LU_solve( A, p, &b_v.vector, &o_v.vector );
  }
  gsl_permutation_free( p );
  gsl_matrix_free( A );
  gsl_matrix_free( b );
  return omega_pi;
}
      #+end_src
   
*** Off-policy estimation of $\mu$

    One other way to estimate $\mu$ is in a /off-policy/ setting, à la LSTDQ.
    
   #+begin_src c :tangle LSTDmu.c :main no
gsl_matrix* lstd_mu_omega(  gsl_matrix* D_mu,
		      gsl_matrix* (*pi)(gsl_matrix*)){
   #+end_src
    - $\tilde A \leftarrow 0$
      #+begin_src c :tangle LSTDmu.c :main no
  gsl_matrix* A = gsl_matrix_calloc( g_iK, g_iK );
      #+end_src
    - $\tilde b \leftarrow 0$
      #+begin_src c :tangle LSTDmu.c :main no
  gsl_matrix* b = gsl_matrix_calloc( g_iK, g_iP );
      #+end_src
    - for each $(s,a,s',\psi(s)^T,eoe) \in D_\mu$
      #+begin_src c :tangle LSTDmu.c :main no
  for( unsigned int i=0; i < D_mu->size1 ; i++ ){
      #+end_src
      - $\tilde A \leftarrow \tilde A + \phi(s,a)\left(\phi(s,a) - \gamma \phi(s',\pi(s'))\right)^T$
        #+begin_src c :tangle LSTDmu.c :main no
    gsl_matrix_view sa = 
      gsl_matrix_submatrix( D_mu, i, 0, 1, g_iS+g_iA);
    gsl_matrix* phi_sa = g_fPhi( &sa.matrix );
    gsl_matrix* sa_dash = gsl_matrix_calloc( 1, g_iS+g_iA );
    gsl_matrix_view sdash_dst = gsl_matrix_submatrix( sa_dash, 
						      0, 0,
						      1, g_iS );
    gsl_matrix_view sdash_src = 
      gsl_matrix_submatrix( D_mu, i, g_iS+g_iA, 1, g_iS);
    gsl_matrix_memcpy( &sdash_dst.matrix, &sdash_src.matrix );
    gsl_matrix_view adash_dst = 
      gsl_matrix_submatrix( sa_dash, 0, g_iS, 1, g_iA );
    gsl_matrix* adash_src = pi( &sdash_src.matrix );
    gsl_matrix_memcpy( &adash_dst.matrix, adash_src );
    gsl_matrix* phi_dash = g_fPhi( sa_dash );
    gsl_matrix_scale( phi_dash, g_dGamma_anirl );
    double eoe = gsl_matrix_get( D_mu, i, g_iS+g_iA+g_iS+g_iP );
    gsl_matrix_scale( phi_dash, eoe );
    gsl_matrix* delta_phi = gsl_matrix_calloc( g_iK, 1 );
    gsl_matrix_memcpy( delta_phi, phi_sa );
    gsl_matrix_sub( delta_phi, phi_dash );
    gsl_matrix* deltaA = gsl_matrix_calloc( g_iK, g_iK );
    gsl_blas_dgemm( CblasNoTrans, CblasTrans, 1., 
		      phi_sa, delta_phi, 0., deltaA);
    gsl_matrix_add( A, deltaA );
        #+end_src
      - $\tilde b \leftarrow \tilde b + \phi(s,a)\psi(s)^T$
        #+begin_src c :tangle LSTDmu.c :main no
       gsl_matrix_view psi_s = 
	 gsl_matrix_submatrix( D_mu, i, g_iS+g_iA+g_iS, 1, g_iP );
       gsl_matrix* delta_b = gsl_matrix_alloc( g_iK, g_iP );
       /*\psi(s) is in line in the code but in column 
	 in the comments*/ 
       gsl_blas_dgemm( CblasNoTrans, CblasNoTrans, 1.0,
		       phi_sa, &psi_s.matrix, 0.0, delta_b );
       gsl_matrix_add( b, delta_b );
       gsl_matrix_free( deltaA );
       gsl_matrix_free( delta_phi );
       gsl_matrix_free( phi_dash );
       gsl_matrix_free( adash_src );
       gsl_matrix_free( sa_dash );
       gsl_matrix_free( phi_sa );
       gsl_matrix_free( delta_b );
     }
       #+end_src
    - $\tilde \omega^\pi \leftarrow (\tilde A + \lambda Id) ^{-1}\tilde b$
      #+begin_src c :tangle LSTDmu.c :main no
  gsl_matrix* lambdaI = gsl_matrix_alloc( A->size1, A->size2 );
  gsl_matrix_set_identity( lambdaI );
  gsl_matrix_scale( lambdaI, g_dLambda_lstdmu );
  gsl_matrix_add( A, lambdaI );
  gsl_matrix_free( lambdaI );
  gsl_matrix* omega_pi = gsl_matrix_alloc( g_iK, g_iP );
  gsl_permutation* p = gsl_permutation_alloc( g_iK );
  int signum;
  gsl_linalg_LU_decomp( A, p, &signum );
  for( unsigned int i = 0 ; i < g_iP ; i++ ){
    gsl_vector_view b_v = gsl_matrix_column( b, i );
    gsl_vector_view o_v = gsl_matrix_column( omega_pi, i );
    gsl_linalg_LU_solve( A, p, &b_v.vector, &o_v.vector );
  }
  gsl_permutation_free( p );
  gsl_matrix_free( A );
  gsl_matrix_free( b );
  return omega_pi;
}
      #+end_src


   #+begin_src c :tangle LSTDmu.c :main no
gsl_matrix* lstd_mu(  gsl_matrix* D_mu,
		      gsl_matrix* (*pi)(gsl_matrix*)){
   #+end_src
    - $\omega_\pi \leftarrow LSTD_\mu( D_\mu, \pi )$
      #+begin_src c :tangle LSTDmu.c :main no
  gsl_matrix* omega_pi = lstd_mu_omega( D_mu, pi );
      #+end_src
    - $\mu_\pi(s_0) \leftarrow \sum\limits_{s_0}\tilde\omega_\pi^T\phi(s_0,\pi(s_0))$
      #+begin_src c :tangle LSTDmu.c :main no
  gsl_matrix* s_pi_s = gsl_matrix_alloc( 1, g_iS+g_iA );
  gsl_matrix* s_0 = g_fS_0();
  gsl_matrix* mu = gsl_matrix_calloc( g_iP, 1 );
  gsl_matrix* delta_mu = gsl_matrix_alloc( g_iP, 1 );
  for( unsigned int i = 0; i<s_0->size1;i++){
    gsl_matrix_view mS_0 = gsl_matrix_submatrix( s_0, i, 0, 
						 1, g_iS );
    gsl_matrix_view s_dst = gsl_matrix_submatrix( s_pi_s, 
						  0, 0,
						  1, g_iS);
    gsl_matrix_memcpy( &s_dst.matrix, &mS_0.matrix );
    gsl_matrix_view pi_s_dst = gsl_matrix_submatrix( s_pi_s,
						     0, g_iS, 
						     1, g_iA);
    gsl_matrix* pi_s_src = pi( &mS_0.matrix );
    gsl_matrix_memcpy( &pi_s_dst.matrix, pi_s_src );
    gsl_matrix* phi_s_pi_s = g_fPhi( s_pi_s );
    gsl_blas_dgemm( CblasTrans, CblasNoTrans, 1.0,
		    omega_pi, phi_s_pi_s, 0.0, delta_mu );
    gsl_matrix_add( mu, delta_mu );
    gsl_matrix_free( phi_s_pi_s );
    gsl_matrix_free( pi_s_src );
  }
  gsl_matrix_scale( mu, 1./((double)s_0->size1) );
  gsl_matrix_free( s_pi_s );
  gsl_matrix_free( delta_mu );
  gsl_matrix_free( omega_pi );
  gsl_matrix_free( s_0 );
  return mu;
}
      #+end_src
*** Actual algorithm
    FIXME: Il faut que le code d'ANIRL existe en un seul endroit et qu'à l'aide de pointeurs de fonctions on choisisse les sous routines. Il ne faut pas qu'il y aie les deux versions comme c'est le cas à l'heure actuelle.


    We followed the same logic as in [[file:abbeel2004apprenticeshiporg]] : We do not follow the way things are exposed in the paper, but use a simpler (implementation wise) way. Mainly, the value referenced as $\bar\mu^i$ in the paper is now $\bar\mu$, a value constructed by a successive addition of terms. The variable $i$ is no more needed.

   #+begin_src c :tangle LSTDmu.c :main no
gsl_matrix* proj_lstd_lspi_ANIRL( gsl_matrix* D_E, 
				  gsl_matrix* D ){
  unsigned int m = 0; //0 is characteristic of LSTDMu when 
  //plotting
  gsl_matrix* omega_0 = gsl_matrix_calloc( g_iK, 1 );
   #+end_src
    - $\omega \leftarrow 0$
      #+begin_src c :tangle LSTDmu.c :main no
  gsl_matrix* omega = gsl_matrix_calloc( g_iK, 1 );
      #+end_src
    - $D_\mu.r \leftarrow \psi(D.s)$
     #+begin_src c :tangle LSTDmu.c :main no
  gsl_matrix* D_mu = gsl_matrix_alloc( D->size1, 
				       g_iS+g_iA+g_iS+g_iP+1 );
  gsl_matrix_view Dsas = 
    gsl_matrix_submatrix( D, 0, 0, D->size1, g_iS+g_iA+g_iS );
  gsl_matrix_view Dmusas = 
    gsl_matrix_submatrix( D_mu, 0, 0, D->size1, g_iS+g_iA+g_iS);
  gsl_matrix_memcpy( &Dmusas.matrix, &Dsas.matrix );
  for( unsigned int i = 0 ; i<D->size1 ; i++ ){
    gsl_matrix_view vS = gsl_matrix_submatrix( D, i, 0, 1,g_iS);
    gsl_matrix* psi_s_src = g_fPsi( &vS.matrix );
    gsl_matrix_view psi_s_dst = 
      gsl_matrix_submatrix( D_mu, i, g_iS+g_iA+g_iS, 1, g_iP );
    /* D.\psi(s) is in line in the code but in columns in
       the comments */
    gsl_matrix_transpose_memcpy( &psi_s_dst.matrix, psi_s_src );
    gsl_matrix_free( psi_s_src );
  }
  gsl_matrix_view Deoe = 
    gsl_matrix_submatrix( D, 0, g_iS+g_iA+g_iS+1, D->size1, 1 );
  gsl_matrix_view Dmueoe = 
    gsl_matrix_submatrix( D_mu, 0, g_iS+g_iA+g_iS+g_iP, 
			  D->size1, 1 ); 
  gsl_matrix_memcpy( &Dmueoe.matrix, &Deoe.matrix );
     #+end_src
    - $\mu \leftarrow LSTD\mu( D_\mu, k, p, s, a, \phi,\psi, \gamma, \pi )$
      #+begin_src c :tangle LSTDmu.c :main no
  g_mOmega = omega;
  gsl_matrix* mu = lstd_mu( D_mu, &greedy_policy );
      #+end_src
    - $D_E.r \leftarrow \psi(D_E.s)$
      #+begin_src c :tangle LSTDmu.c :main no
  gsl_matrix* D_E_mu = 
    gsl_matrix_alloc( D_E->size1, g_iS+g_iA+g_iS+g_iP+1 );
  gsl_matrix_view DEsas_dst = 
    gsl_matrix_submatrix( D_E_mu, 0, 0, 
			  D_E_mu->size1,g_iS+g_iA+g_iS );
  gsl_matrix_view DEsas_src = 
    gsl_matrix_submatrix(D_E, 0, 0, D_E->size1, g_iS+g_iA+g_iS);
  gsl_matrix_memcpy( &DEsas_dst.matrix, &DEsas_src.matrix );
  for( unsigned int i = 0 ; i<D_E_mu->size1 ; i++ ){
    gsl_matrix_view vS = 
      gsl_matrix_submatrix(D_E_mu, i, 0, 1, g_iS );
    gsl_matrix* psi_s_src = g_fPsi( &vS.matrix );
    gsl_matrix_view psi_s_dst = 
      gsl_matrix_submatrix( D_E_mu, i, g_iS+g_iA+g_iS, 1, g_iP);
    /* D.\psi(s) is in line in the code but in columns in
       the comments */
    gsl_matrix_transpose_memcpy( &psi_s_dst.matrix, psi_s_src );
    gsl_matrix_free( psi_s_src );
  }
  gsl_matrix_view DEeoe_dst = 
    gsl_matrix_submatrix( D_E_mu, 0, g_iS+g_iA+g_iS+g_iP,
			  D_E_mu->size1, 1 );
  gsl_matrix_view DEeoe_src = 
    gsl_matrix_submatrix( D_E, 0, g_iS+g_iA+g_iS+1, 
			  D_E->size1, 1 ); 
  gsl_matrix_memcpy( &DEeoe_dst.matrix, &DEeoe_src.matrix );
      #+end_src
    - $\mu_E \leftarrow on-LSTD_\mu( D_E, k, p, s, a, \psi,\phi, \gamma)$
      #+begin_src c :tangle LSTDmu.c :main no
  gsl_matrix* mu_E = lstd_mu_op( D_E_mu );
  gsl_matrix_free( D_E_mu );
      #+end_src
    - $\theta \leftarrow {\mu_E - \mu\over ||\mu_E - \mu||_2}$
      #+begin_src c :tangle LSTDmu.c :main no
  gsl_matrix* theta = gsl_matrix_alloc( g_iP, 1 );
  gsl_matrix_memcpy( theta, mu_E );
  gsl_matrix_sub( theta, mu );
  gsl_vector_view theta_v = gsl_matrix_column( theta, 0 );
  double theta_norm = gsl_blas_dnrm2( &theta_v.vector );
  if( theta_norm != 0 )
    gsl_matrix_scale( theta, 1./theta_norm );
      #+end_src
    - $\bar\mu \leftarrow \mu$
      #+begin_src c :tangle LSTDmu.c :main no
  gsl_matrix* bar_mu = gsl_matrix_alloc( g_iP, 1 );
  gsl_matrix_memcpy( bar_mu, mu );
      #+end_src
    - $t \leftarrow ||\mu_E - \bar\mu||_2$
      #+begin_src c :tangle LSTDmu.c :main no
  double t = diff_norm( mu_E, bar_mu );
  unsigned int nb_it = 0;
  g_dBest_error = diff_norm( mu_E, mu ); //FIXME: ces trois lignes font appel à g_fSimulator, ce qui est génant puisqu'on peut ne pas en avoir.
  g_dBest_true_error = true_diff_norm( omega );
  g_dBest_diff = true_V_diff( omega );
  g_dBest_t = t;
  g_mBest_omega = gsl_matrix_alloc( omega->size1, omega->size2 );
  gsl_matrix_memcpy( g_mBest_omega, omega );
      #+end_src
    - while $t > \epsilon$
      #+begin_src c :tangle LSTDmu.c :main no
  while( t > g_dEpsilon_anirl && nb_it < g_iIt_max_anirl ){
      #+end_src
      - Output of the different criteria
        #+begin_src c :tangle LSTDmu.c :main no
      double empirical_err = diff_norm( mu_E, mu );
      double true_err = true_diff_norm( omega );
      double true_V = true_V_diff( omega );
      printf( "%d %d %lf %lf %lf %lf\n", 
	      m, nb_it, 
	      t, empirical_err, true_err, true_V );
      //if( empirical_err <= g_dBest_error ){
      if( true_err <= g_dBest_true_error ){
	g_dBest_error = empirical_err;
	g_dBest_true_error = true_err;
	g_dBest_diff = true_V;
	g_dBest_t = t;
	gsl_matrix_memcpy( g_mBest_omega, omega );
      }
        #+end_src
      - $D.r \leftarrow \theta^T\psi(D.s)$
        #+begin_src c :tangle LSTDmu.c :main no
    for( unsigned int i = 0 ; i < D->size1 ; i++ ){
      gsl_matrix_view state = 
	gsl_matrix_submatrix( D, i, 0, 1, g_iS );
      gsl_matrix* psi_s = g_fPsi( &state.matrix );
      gsl_matrix_view r = 
	gsl_matrix_submatrix( D, i, 2*g_iS+g_iA, 1, 1 );
      gsl_blas_dgemm( CblasTrans, CblasNoTrans, 1.0, 
		       theta, psi_s, 0.0, &r.matrix );
      gsl_matrix_free( psi_s );
    }
        #+end_src
      - $\omega \leftarrow LSPI(D,k,\phi,\gamma_{LSPI},\epsilon_{LSPI}, \omega_0)$
        #+begin_src c :tangle LSTDmu.c :main no
    gsl_matrix_free( omega );
    omega = lspi( D, omega_0 );
        #+end_src
      - $\mu \leftarrow LSTD_\mu( D_\mu, k, p, s, a, \phi,\psi, \gamma, \pi )$
        #+begin_src c :tangle LSTDmu.c :main no
    g_mOmega = omega;
    gsl_matrix_free( mu );
    mu = lstd_mu( D_mu, &greedy_policy );
        #+end_src
      - $\bar\mu \leftarrow \bar\mu + { (\mu-\bar\mu)^T (\mu_E-\bar\mu) \over (\mu-\bar\mu)^T (\mu-\bar\mu) }(\mu-\bar\mu)$
        #+begin_src c :tangle LSTDmu.c :main no
    gsl_matrix* mu_barmu = gsl_matrix_alloc( g_iP, 1 );
    gsl_matrix* muE_barmu = gsl_matrix_alloc( g_iP, 1 );
    gsl_matrix* num = gsl_matrix_alloc( 1, 1 );
    gsl_matrix* denom = gsl_matrix_alloc( 1, 1 );
    gsl_matrix* delta_bar_mu = gsl_matrix_alloc( g_iP, 1 );
    gsl_matrix_memcpy( mu_barmu, mu );
    gsl_matrix_sub( mu_barmu, bar_mu );
    gsl_matrix_memcpy( muE_barmu, mu_E );
    gsl_matrix_sub( muE_barmu, bar_mu ); //Check here
    gsl_blas_dgemm( CblasTrans, CblasNoTrans, 1.0,
		    mu_barmu, muE_barmu, 0.0, num );
    gsl_blas_dgemm( CblasTrans, CblasNoTrans, 1.0,
		    mu_barmu, mu_barmu, 0.0, denom );
    gsl_matrix_memcpy( delta_bar_mu, mu_barmu );
    double scale = gsl_matrix_get( num, 0, 0 ) / 
      gsl_matrix_get( denom, 0, 0 );
    if( isnan( scale ) ){
      gsl_matrix_free( num );
      gsl_matrix_free( denom );
      gsl_matrix_free( mu_barmu );
      gsl_matrix_free( muE_barmu );
      gsl_matrix_free( delta_bar_mu );
      gsl_matrix_free( D_mu );
      gsl_matrix_free( omega_0 );
      gsl_matrix_free( mu );
      gsl_matrix_free( mu_E );
      gsl_matrix_free( bar_mu );
      gsl_matrix_free( theta );
      fprintf(stderr,"lstd_ANIRL returning early because it's stuck\n");
      return omega;
    }
    gsl_matrix_scale( delta_bar_mu, scale );
    gsl_matrix_add( bar_mu, delta_bar_mu );
    gsl_matrix_free( num );
    gsl_matrix_free( denom );
    gsl_matrix_free( mu_barmu );
    gsl_matrix_free( muE_barmu );
    gsl_matrix_free( delta_bar_mu );
        #+end_src
      - $\theta \leftarrow {\mu_E - \bar\mu\over ||\mu_E - \bar\mu||_2}$
        #+begin_src c :tangle LSTDmu.c :main no
    gsl_matrix_memcpy( theta, mu_E );
    gsl_matrix_sub( theta, bar_mu );
    theta_v = gsl_matrix_column( theta, 0 );
    theta_norm = gsl_blas_dnrm2( &theta_v.vector );
    if( theta_norm != 0 )
      gsl_matrix_scale( theta, 1./theta_norm );
        #+end_src
      - $t\leftarrow ||\mu_E - \bar\mu||_2$
        #+begin_src c :tangle LSTDmu.c :main no
    t = diff_norm( mu_E, bar_mu );
    nb_it++;
  }
        #+end_src
    - Last output of the different criteria
      #+begin_src c :tangle LSTDmu.c :main no
  double empirical_err = diff_norm( mu_E, mu );
  double true_err = true_diff_norm( omega );
  double true_V = true_V_diff( omega );
  printf( "%d %d %lf %lf %lf %lf\n", 
	  m, nb_it, 
	  t, empirical_err, true_err, true_V );
  //  if( empirical_err <= g_dBest_error ){
  if( true_err <= g_dBest_true_error ){
    g_dBest_error = empirical_err;
    g_dBest_true_error = true_err;
    g_dBest_diff = true_V;
    g_dBest_t = t;
    gsl_matrix_memcpy( g_mBest_omega, omega );
  }
  gsl_matrix_free( D_mu );
  gsl_matrix_free( omega_0 );
  gsl_matrix_free( mu );
  gsl_matrix_free( mu_E );
  gsl_matrix_free( bar_mu );
  gsl_matrix_free( theta );
  gsl_matrix_free( omega );
  return g_mBest_omega;
}
      #+end_src

** Makefile rules
   Some rules to tangle the source files :
  #+srcname: LSTDmu_code_make
  #+begin_src makefile
LSTDmu.c: LSTDmu.org 
	$(call tangle,"LSTDmu.org")

LSTDmu.h: LSTDmu.org
	$(call tangle,"LSTDmu.org")
  #+end_src

   A rule to create the object file :
  #+srcname: LSTDmu_c2o_make
  #+begin_src makefile
LSTDmu.o: LSTDmu.c LSTDmu.h utils.h criteria.h LSPI.h greedy.h RL_Globals.h IRL_Globals.h
	$(call c2obj,"LSTDmu.c")
  #+end_src

   A rule to clean the mess :
  #+srcname: LSTDmu_clean_make
  #+begin_src makefile
LSTDmu_clean:
	find . -maxdepth 1 -iname "LSTDmu.h"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "LSTDmu.c"   | xargs $(XARGS_OPT) rm 
	find . -maxdepth 1 -iname "LSTDmu.o"   | xargs $(XARGS_OPT) rm
  #+end_src
