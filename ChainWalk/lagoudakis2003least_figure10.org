#+TITLE: Reproducing Lagoudakis and Parr's results

* Introduction
  This program reproduces the figure 10 of \cite{lagoudakis2003least}, but with error bars corresponding to the standard deviation.

  The input files are expected to have the same format as the one output by [[file:ChainWalk_generator.org]].

* C Implementation
  We use the GSL, its BLAS interface and ou code fo LSPI.
  #+begin_src c :tangle lagoudakis2003least_figure10.c :main no
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_blas.h>
#include <math.h>
#include "LSPI.h"
#include "utils.h"
  #+end_src
  
  Some constants are defined :
  - $s a s' r eoe$, one digit each
    #+begin_src c :tangle lagoudakis2003least_figure10.c :main no
#define D_WIDTH 5
    #+end_src
  - Cardinal of the state space
    #+begin_src c :tangle lagoudakis2003least_figure10.c :main no
#define S_CARD 4
    #+end_src
  - Number of runs over which we compute the mean and the standad deviation.
    #+begin_src c :tangle lagoudakis2003least_figure10.c :main no
#define N_EXP  1000
    #+end_src
  - Prefix for files containing the transitions
    #+begin_src c :tangle lagoudakis2003least_figure10.c :main no
#define D_PREFIX "Samples"
    #+end_src
  - File containing the different actions, to be read and given to greedy.
    #+begin_src c :tangle lagoudakis2003least_figure10.c :main no
#define ACTION_FILE "actions.mat"
    #+end_src

  
  We define the feature function $\phi : S\times A\rightarrow\mathbb{R}^6$
  #+begin_src c :tangle lagoudakis2003least_figure10.c :main no
gsl_matrix* phi( gsl_matrix* sa ){
  gsl_matrix* answer = gsl_matrix_calloc( 6, 1 );
  int index = (int)gsl_matrix_get(sa,0,1) * 3; //Action 0 for 
                                               //left, 1 for 
                                               //right
  gsl_matrix_set( answer, index, 0, 1. );
  gsl_matrix_set( answer, index+1, 0, gsl_matrix_get(sa,0,0) );
  gsl_matrix_set( answer, index+2, 0,
		 gsl_matrix_get(sa,0,0)*gsl_matrix_get(sa,0,0));
  return answer;
}
  #+end_src

  We then set some of the global variables needed by LSPI. Note that the regularization coefficient for LSTDQ, $\lambda_{LSTDQ}$ influences variance in the final curve (a lot). Try 0, then 0.1, then 0.5.
  #+begin_src c :tangle lagoudakis2003least_figure10.c :main no
unsigned int g_iS = 1; /*State space dimension*/
unsigned int g_iA = 1; /*Action space dimension*/
unsigned int g_iK = 6; /*Feature space dimension*/
double g_dGamma_lstdq =  0.9; /*Discount factor*/
double g_dEpsilon_lspi = 0.1; /*Halt criterion*/
gsl_matrix* g_mOmega = NULL; //Omega
gsl_matrix* (*g_fPhi)(gsl_matrix*) = &phi; //\phi
gsl_matrix* g_mActions = NULL; //All actions, one per line
unsigned int g_iIt_max_lspi = 20;
double g_dLambda_lstdQ = 0.5; 
  #+end_src

  We allocate some stuff :
  #+begin_src c :tangle lagoudakis2003least_figure10.c :main no
int main( void ){
  gsl_matrix* omega_0 = gsl_matrix_calloc( g_iK, 1 );
  gsl_matrix* mQ = gsl_matrix_alloc( 1, 1 );
  gsl_matrix* values_L = gsl_matrix_calloc( N_EXP, S_CARD );
  gsl_matrix* values_R = gsl_matrix_calloc( N_EXP, S_CARD );
  g_mActions = file2matrix( ACTION_FILE, g_iA );
  #+end_src

  We do N_EXP runs. for each of these we read a different transition matrix, and get a $\omega^*$ from LSPI.
  #+begin_src c :tangle lagoudakis2003least_figure10.c :main no
  for( unsigned int i = 0; i < N_EXP ; i++ ){
    //    fprintf( stderr, "LSPI on sample set %d\n", i );	
    char D_name[1024];
    sprintf( D_name, "%s%04d", D_PREFIX, i+1 );
    gsl_matrix* D = file2matrix( D_name, D_WIDTH );
    gsl_matrix* omega_star = lspi( D, omega_0 );
  #+end_src

  We then, fo each state $s$, compute $Q(s,right)$ and $Q(s,left)$.
  #+begin_src c :tangle lagoudakis2003least_figure10.c :main no
    for( unsigned int s = 1; s <= 4; s++ ){
      gsl_matrix* sa = gsl_matrix_alloc( 1, g_iS+g_iA );
      gsl_matrix_set( sa, 0, 0, (double)s );
      gsl_matrix_set( sa, 0, 1, 0. );//Left
      gsl_matrix* phi_sa = phi( sa );
      gsl_blas_dgemm( CblasTrans, CblasNoTrans, 
		      1.0, omega_star, phi_sa, 
		      0.0, mQ );
      gsl_matrix_set( values_L, i, s-1, 
		      gsl_matrix_get( mQ, 0, 0 ) );
      gsl_matrix_free( phi_sa );     
      gsl_matrix_set( sa, 0, 1, 1. );//Right
      phi_sa = phi( sa );
      gsl_blas_dgemm( CblasTrans, CblasNoTrans, 
		      1.0, omega_star, phi_sa, 
		      0.0, mQ );
      gsl_matrix_set( values_R, i, s-1, 
		      gsl_matrix_get( mQ, 0, 0 ) );
      
    }
    gsl_matrix_free( omega_star );
    gsl_matrix_free( D );
  }
  #+end_src

  After all the runs are finished, the mean and variance is computed.
  #+begin_src c :tangle lagoudakis2003least_figure10.c :main no
  for( unsigned int s = 1; s <= 4; s++ ){
    double mean_L = 0;
    double mean_R = 0;
    for( unsigned int i = 0 ; i < N_EXP ; i++ ){
      mean_L += gsl_matrix_get( values_L, i, s-1 );
      mean_R += gsl_matrix_get( values_R, i, s-1 );
    }
    mean_L /= (double)N_EXP;
    mean_R /= (double)N_EXP;
    double var_L = 0;
    double var_R = 0;
    for( unsigned int i = 0 ; i < N_EXP ; i++ ){
      var_L += pow( gsl_matrix_get( values_L, i, s-1 ) - mean_L,
		    2 );
      var_R += pow( gsl_matrix_get( values_R, i, s-1 ) - mean_R,
		    2 );
    }
    var_L /= (double)N_EXP;
    var_R /= (double)N_EXP;
  #+end_src

  And printed.
  #+begin_src c :tangle lagoudakis2003least_figure10.c :main no
    printf("%d %lf %lf %lf %lf\n",
	   s, mean_L, sqrt(var_L), mean_R, sqrt(var_R) );

  } 
  
  
  return 0;
}
  #+end_src
* GNUplot instructions
#+begin_src text :tangle lagoudakis2003least_figure10.gp
set term postscript enhanced color
set output "lagoudakis2003least_figure10.ps"
set grid
set xrange[0.8:4.2]
set xlabel "States"
set ylabel "Q"
set xtics 1
plot "lagoudakis2003least_figure10.dat" u 1:2 w lines smooth csplines ls 1 title "Q(s,R)", "lagoudakis2003least_figure10.dat" u 1:2:3 w errorbars ls 1 lw 1 notitle,"lagoudakis2003least_figure10.dat" u 1:4 w lines smooth csplines ls 3 title "Q(s,L)", "lagoudakis2003least_figure10.dat" u 1:4:5 w errorbars ls 3 lw 2 notitle
#+end_src
* Makefile rules
  Some rules to tangle the source files :
  #+srcname: lagoudakis2003least_figure10_code_make
  #+begin_src makefile
lagoudakis2003least_figure10.c: lagoudakis2003least_figure10.org 
	$(call tangle,"lagoudakis2003least_figure10.org")
lagoudakis2003least_figure10.gp: lagoudakis2003least_figure10.org 
	$(call tangle,"lagoudakis2003least_figure10.org")
  #+end_src

   A rule to create the object file :
  #+srcname: lagoudakis2003least_figure10_c2o_make
  #+begin_src makefile
lagoudakis2003least_figure10.o: lagoudakis2003least_figure10.c ../LSPI.h ../utils.h
	$(call c2obj,"lagoudakis2003least_figure10.c")
  #+end_src

   A rule to create the executable from the object file :
#+srcname: lagoudakis2003least_figure10_o2exe_make
#+begin_src makefile
lagoudakis2003least_figure10.exe: lagoudakis2003least_figure10.o ../LSPI.o ../LSTDQ.o ../utils.o ../greedy.o 
	$(O2EXE) -o lagoudakis2003least_figure10.exe lagoudakis2003least_figure10.o ../LSPI.o ../LSTDQ.o ../utils.o ../greedy.o  $(LFLAGS)
generator.exe: generator.o ../utils.o
#+end_src


   A rule to clean the mess :
  #+srcname: lagoudakis2003least_figure10_clean_make
  #+begin_src makefile
lagoudakis2003least_figure10_clean:
	find . -maxdepth 1 -iname "lagoudakis2003least_figure10.exe"   | xargs -t rm
	find . -maxdepth 1 -iname "lagoudakis2003least_figure10.c"   | xargs -t rm 
	find . -maxdepth 1 -iname "lagoudakis2003least_figure10.o"   | xargs -t rm
	find . -maxdepth 1 -iname "lagoudakis2003least_figure10.gp"   | xargs -t rm
	find . -maxdepth 1 -iname "lagoudakis2003least_figure10.dat"   | xargs -t rm
	find . -maxdepth 1 -iname "lagoudakis2003least_figure10.ps"   | xargs -t rm
	find . -maxdepth 1 -iname "lagoudakis2003least_figure10.pdf"   | xargs -t rm
	find . -maxdepth 1 -iname "lagoudakis2003least_figure10.samples"   | xargs -t rm
	find . -maxdepth 1 -iname "Samples*"   | xargs -t rm
  #+end_src

And the rules that allows for the creation of the figure :
#+srcname: lagoudakis2003least_figure10_make
    #+begin_src makefile
lagoudakis2003least_figure10.pdf: lagoudakis2003least_figure10.ps
	ps2pdf lagoudakis2003least_figure10.ps

lagoudakis2003least_figure10.ps: lagoudakis2003least_figure10.dat lagoudakis2003least_figure10.gp
	gnuplot lagoudakis2003least_figure10.gp

lagoudakis2003least_figure10.dat: lagoudakis2003least_figure10.samples lagoudakis2003least_figure10.exe
	./lagoudakis2003least_figure10.exe > lagoudakis2003least_figure10.dat

lagoudakis2003least_figure10.samples: ChainWalk_generator.exe 
	for i in `seq -w 1000`; do ./ChainWalk_generator.exe 50 > Samples$$i; done && touch lagoudakis2003least_figure10.samples
    #+end_src
