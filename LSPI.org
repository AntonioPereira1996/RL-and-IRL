#+TITLE:LSPI
  LSPI is a reinforcement learning algorithm introduced in \cite{lagoudakis2003least}.
  
  It uses [[file:LSTDQ.org][LSTDQ]] and a [[file:greedy.org][greedy]] mechanism.
* LSPI header
** Détails techniques
   C :
   #+begin_src C
#include LSPI.h

unsigned int g_iK = -1;
gsl_matrix* g_mOmega = NULL;
double g_dEpsilon_lspi = -1;
unsigned int g_iIt_max_lspi = -1;

gsl_matrix* omega = lspi( D, omega_0 );
   #+end_src
** Entrées
   - =D= : Matrice de transitions dont chaque ligne est de la forme $s,a,s',r,eoe$ ($eoe$ vaut 0 en fin d'épisode, 1 sinon).
   - =omega_0= : Matrice de taille $k\times 1$ donnant la fonction de qualité initiale
** Sorties
   - Matrice $\omega$ de taille $k \times 1$ telle que la fonction de qualité optimale peut être approximée par $\hat Q(s,a) = \omega^T\phi(s,a)$
** Paramètres
   - =g_dEpsilon_lspi= : critère d'arrêt pour LSPI, seuil que doit passer la norme 2 entre deux valeurs consécutives de $\omega$.
   - =g_iIt_max_lspi= : critère d'arrêt pour LSPI, nombre maximum d'itération après lequel LSPI s'arrête s'il n'a pas passé le seuil

     
   Il faut également régler les paramètres de [[file:LSTDQ.org][LSTD$Q$]] et de [[file:greedy.org][la greedy policy]].
* C implementation
** Externals
    The C implementation follows quite closely the pseudo code given in \cite{lagoudakis2003least}.
    
    Most of LSPI input is taken via [[file:RL_Globals.org][global variables]].
    
    It takes the form of a C function :
#+begin_src c :tangle LSPI.h :main no
gsl_matrix* lspi( gsl_matrix* D, gsl_matrix* omega_0 );
#+end_src
    The $D$ matrix is passed to [[file:LSTDQ.org][LSTDQ]].

    The $\omega_0$ matrix defines the initial policy.
** Internals
    We use the GSL, our [[file:LSTDQ.org][LSTDQ]] implementation and a [[file:greedy.org][greedy]] mechanism.
    
#+begin_src c :tangle LSPI.c :main no
#include <gsl/gsl_matrix.h>
#include "LSTDQ.h"
#include "utils.h"
#include "greedy.h"
#include "LSPI.h"
#include "RL_Globals.h"
#+end_src

    We then follow quite cloesly the pseudo code of \cite{lagoudakis2003least}.
    - 
#+begin_src c :tangle LSPI.c :main no
gsl_matrix* lspi( gsl_matrix* D, gsl_matrix* omega_0 ){
  unsigned int nb_iterations = 0;
  gsl_matrix* omega = gsl_matrix_alloc( g_iK, 1 );
  g_mOmega = omega;
#+end_src
    - $\omega'\leftarrow \omega_0$
#+begin_src c :tangle LSPI.c :main no
  gsl_matrix* omega_dash = gsl_matrix_alloc( g_iK, 1 );
  gsl_matrix_memcpy( omega_dash, omega_0 );
  double norm;
#+end_src
    - Repeat : 
#+begin_src c :tangle LSPI.c :main no
  do{
#+end_src
     - $\omega \leftarrow \omega'$
 #+begin_src c :tangle LSPI.c :main no
     gsl_matrix_memcpy( omega, omega_dash );
 #+end_src
     - $\omega' \leftarrow lstdQ(D,\pi_\omega)$
 #+begin_src c :tangle LSPI.c :main no
     gsl_matrix_free( omega_dash );
     omega_dash = lstd_q( D, &greedy_policy );
 #+end_src
     - until $||\omega'-\omega|| < \epsilon_{LSPI}$ or the number of iteration is too high
 #+begin_src c :tangle LSPI.c :main no
     norm = diff_norm( omega_dash, omega );
     nb_iterations++;
   }while( norm >= g_dEpsilon_lspi && 
	   nb_iterations < g_iIt_max_lspi);
   gsl_matrix_free( omega );
 #+end_src
    - return $\omega'$
#+begin_src c :tangle LSPI.c :main no
  return omega_dash;
}
#+end_src
** Makefile rules
   Some rules to tangle the source files :
  #+srcname: LSPI_code_make
  #+begin_src makefile
LSPI.c: LSPI.org 
	$(call tangle,"LSPI.org")

LSPI.h: LSPI.org
	$(call tangle,"LSPI.org")
  #+end_src

   A rule to create the object file :
  #+srcname: LSPI_c2o_make
  #+begin_src makefile
LSPI.o: LSPI.c LSPI.h LSTDQ.h utils.h greedy.h RL_Globals.h
	$(call c2obj,"LSPI.c")
  #+end_src

   A rule to clean the mess :
  #+srcname: LSPI_clean_make
  #+begin_src makefile
LSPI_clean:
	find . -maxdepth 1 -iname "LSPI.h"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "LSPI.c"   | xargs $(XARGS_OPT) rm 
	find . -maxdepth 1 -iname "LSPI.o"   | xargs $(XARGS_OPT) rm
  #+end_src
* Python implementation
  - $\omega'\leftarrow \omega_0$
#+begin_src python :tangle LSPI.py 
from LSTDQ import *
from pylab import *
from DP import *
def LSPI( D, s_dim, a_dim, phi, phi_dim, actions, epsilon, max_it ):
    nb_iterations = 0;
    omega = zeros( [phi_dim, 1] )
    omega_dash = zeros( [phi_dim, 1] )
#+end_src
  - Repeat : 
#+begin_src python :tangle LSPI.py 
    while True:
#+end_src
     - $\omega \leftarrow \omega'$
 #+begin_src python :tangle LSPI.py 
        omega = omega_dash.copy()
 #+end_src
     - $\omega' \leftarrow lstdQ(D,\pi_\omega)$
 #+begin_src python :tangle LSPI.py 
        pi = lambda s: greedy_policy( s, omega, phi, actions )
        omega_dash = LSTDQ( D, s_dim, a_dim, pi, phi, phi_dim )
 #+end_src
     - until $||\omega'-\omega|| < \epsilon_{LSPI}$ or the number of iteration is too high
 #+begin_src python :tangle LSPI.py 
        nb_iterations+=1
        if norm( omega_dash-omega ) < epsilon or nb_iterations > max_it:
            break
 #+end_src
    - return $\omega'$
#+begin_src python :tangle LSPI.py 
    return omega_dash
#+end_src
