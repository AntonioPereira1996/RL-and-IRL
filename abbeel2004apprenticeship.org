#+TITLE: Abbeel and Ng's IRL algorithm, with Monte-Carlo estimation of the feature expectation
  
  In their paper, \cite{abbeel2004apprenticeship}, Ng and Abbeel present an IRL algorithm. This file is an implementation of this algorithm in its projection form, using a Monte-Carlo method to estimate $\mu_E$ and $\mu_i$ and using LSPI to solve the MDP.
* MC$\mu$ header
** Détails techniques  
#+begin_src C
#include "abbeel2004apprenticeship.h"

gsl_matrix* mu = monte_carlo_mu( D );
#+end_src
** Entrées
   - =D= : Matrice de données dont la dernière colonne est $eoe$ et les $dim(S)$ premières un état
** Sortie
   = =mu= : Matrice correspondant à l'estimation de Monte-Carlo de $\mu$ sur les données fournies, à savoir $\sum_{T \in D}\sum_{s_t\in T}\gamma^t\psi(s_t)$
** Paramètres
   - =g_fPsi= : Feature de $S$ dans $\mathbf{R}^p$
   - =g_dGamma_anirl= : Coefficient d'amortissement
* C implementation
** Externals
   Two functions are offered : 
   #+begin_src c :tangle abbeel2004apprenticeship.h :main no
gsl_matrix* monte_carlo_mu( gsl_matrix* D ); 
gsl_matrix* proj_mc_lspi_ANIRL( gsl_matrix* D_E,
				gsl_matrix* D,
				unsigned int m);
   #+end_src
   The first one computes an estimate of $\mu$ given a set of trajectories $D$ according to $\hat\mu = {1\over m }\sum\limits_{i=0}^m\sum\limits_{t=0}^\infty\gamma^t\psi(s_t^{(i)})$.

   The second one is the actual algorithm. Most of its arguments are passed via gobal variables (see [[file:RL_Globals.org][here]] and [[file:IRL_Gobals.org][here]]), the $D_E$ matrix are the trajectories from the expert, and the $D$ matrix are the transitions to be fed to LSPI. The parameter $m$ is the number of trajectories over which to compute $\mu$.

   It returns the $\omega$ matrix which defines the optimal policy as found by LSPI under the reward $R = \theta^T\psi$. Note that $\omega \equiv \pi$, in other words, ou aproximation of the value function defines the greedy policy.

** Internals
   We use the GSL, its BLAS interface and the rest of our code
   #+begin_src c :tangle abbeel2004apprenticeship.c :main no
#include <gsl/gsl_matrix.h>
#include <math.h>
#include <gsl/gsl_blas.h>
#include "RL_Globals.h"
#include "IRL_Globals.h"
#include "utils.h"
#include "criteria.h"
#include "LSPI.h"
   #+end_src


   We declare some of the variables of [[file:IRL_Globals.h]]. 
   #+begin_src c :tangle abbeel2004apprenticeship.c :main no
double g_dBest_error;
double g_dBest_true_error;
double g_dBest_diff;
double g_dBest_t;
gsl_matrix* g_mBest_omega;
   #+end_src
   
   The code of our first function is straightforward :
   #+begin_src c :tangle abbeel2004apprenticeship.c :main no
gsl_matrix* monte_carlo_mu( gsl_matrix* D ){
  gsl_matrix* answer = gsl_matrix_calloc( g_iP, 1 );
  double t = 0;
  unsigned int nb_traj = 0;
  gsl_matrix_view EOEs = 
    gsl_matrix_submatrix( D, 0, D->size2-1, D->size1, 1 ); 
  for( unsigned int i=0; i < D->size1 ; i++ ){
    gsl_matrix_view s = gsl_matrix_submatrix( D, i, 0, 
					      1, g_iS );
    gsl_matrix* delta_mu = g_fPsi( &s.matrix );
    double gamma_t = pow( g_dGamma_anirl, t );
    gsl_matrix_scale( delta_mu, gamma_t );
    gsl_matrix_add( answer, delta_mu );
    gsl_matrix_free( delta_mu );
    int eoe = (int)gsl_matrix_get( &EOEs.matrix, i, 0 );
    if( eoe == 0 ){ //End of episode
      t = 0;
      nb_traj++;
    }else{
      t++;
    }
  }
  gsl_matrix_scale( answer, 1./(double)nb_traj );
  return answer;
}
   #+end_src
   
   The implementation of Abbeel and Ng's algorithm is not as simple. We do not follow the way things are exposed in the paper, but use a simpler (implementation wise) way. Mainly, the value referenced as $\bar\mu^i$ in the paper is now $\bar\mu$, a value constructed by a successive addition of terms. The variable $i$ is no more needed.
   FIXME: Réunir cette implémentation avec celle de LSTDmu.org en paramétrant le choix des routines
   The implementation goes as follow :
   #+begin_src c :tangle abbeel2004apprenticeship.c :main no
gsl_matrix* proj_mc_lspi_ANIRL( gsl_matrix* D_E,
				gsl_matrix* D,
				unsigned int m ){
  gsl_matrix* omega_0 = gsl_matrix_calloc( g_iK, 1 );
   #+end_src
   - $\omega \leftarrow 0$
     #+begin_src c :tangle abbeel2004apprenticeship.c :main no
  gsl_matrix* omega = gsl_matrix_calloc( g_iK, 1 );
     #+end_src
   - $D_\pi \leftarrow simulator( m, \omega )$
     #+begin_src c :tangle abbeel2004apprenticeship.c :main no
  g_mOmega = omega;
  gsl_matrix* trans = g_fSimulator( m );
     #+end_src
   - $\mu \leftarrow mc( D_\pi, \gamma, \psi )$
     #+begin_src c :tangle abbeel2004apprenticeship.c :main no
  gsl_matrix* mu = monte_carlo_mu( trans );
  gsl_matrix_free( trans );
     #+end_src
   - $\mu_E \leftarrow mc( D_E, \gamma, \psi )$
     #+begin_src c :tangle abbeel2004apprenticeship.c :main no
  gsl_matrix* mu_E = monte_carlo_mu( D_E );
     #+end_src
   - $\theta \leftarrow {\mu_E - \mu\over ||\mu_E - \mu||_2}$
     #+begin_src c :tangle abbeel2004apprenticeship.c :main no
  gsl_matrix* theta = gsl_matrix_alloc(g_iP, 1 );
  gsl_matrix_memcpy( theta, mu_E );
  gsl_matrix_sub( theta, mu );
  gsl_vector_view theta_v = gsl_matrix_column( theta, 0 );
  double theta_norm = gsl_blas_dnrm2( &theta_v.vector );
  if( theta_norm != 0 )
    gsl_matrix_scale( theta, 1./theta_norm );
     #+end_src
   - $\bar\mu \leftarrow \mu$
     #+begin_src c :tangle abbeel2004apprenticeship.c :main no
     gsl_matrix* bar_mu = gsl_matrix_alloc( g_iP, 1 );
     gsl_matrix_memcpy( bar_mu, mu );
     #+end_src
   - $t \leftarrow ||\mu_E - \bar\mu||_2$
     #+begin_src c :tangle abbeel2004apprenticeship.c :main no
	double t = diff_norm( mu_E, bar_mu );
	unsigned int nb_it = 0;
	g_dBest_error = diff_norm( mu_E, mu );
	g_dBest_true_error = true_diff_norm( omega );
	g_dBest_diff = true_V_diff( omega );
	g_dBest_t = t;
	g_mBest_omega = gsl_matrix_alloc( omega->size1, omega->size2 );
	gsl_matrix_memcpy( g_mBest_omega, omega );
     #+end_src
   - While $t>\epsilon_{ANIRL}$ and the number of iterations is small enough
     #+begin_src c :tangle abbeel2004apprenticeship.c :main no
   while( t > g_dEpsilon_anirl && nb_it < g_iIt_max_anirl ){
     #+end_src
     - Output of the different criteria
       #+begin_src c :tangle abbeel2004apprenticeship.c :main no
    double empirical_err = diff_norm( mu_E, mu );
    double true_err = true_diff_norm( omega );
    double true_V = true_V_diff( omega );
    printf( "%d %d %lf %lf %lf %lf\n", 
	    m, nb_it,
	    t, empirical_err, true_err, true_V );
           if( true_err <= g_dBest_true_error ){
      g_dBest_error = empirical_err;
      g_dBest_true_error = true_err;
      g_dBest_diff = true_V;
      g_dBest_t = t;
      gsl_matrix_memcpy( g_mBest_omega, omega );
    }
       #+end_src
     - $D.r \leftarrow \theta^T\psi(D.s)$ 
       #+begin_src c :tangle abbeel2004apprenticeship.c :main no
    for( unsigned int i = 0 ; i < D->size1 ; i++ ){
      gsl_matrix_view state = 
	gsl_matrix_submatrix( D, i, 0, 1, g_iS );
      gsl_matrix* psi_s = g_fPsi( &state.matrix );
      gsl_matrix_view r = 
	gsl_matrix_submatrix( D, i, 2*g_iS+g_iA, 1, 1 );
      gsl_blas_dgemm( CblasTrans, CblasNoTrans, 1.0, 
		       theta, psi_s, 0.0, &r.matrix );
      gsl_matrix_free( psi_s );
    }
       #+end_src
     - $\omega \leftarrow LSPI(D,k,\phi,\gamma_{LSPI},\epsilon_{LSPI}, \omega_0)$
       #+begin_src c :tangle abbeel2004apprenticeship.c :main no
    gsl_matrix_free( omega );
    omega = lspi( D, omega_0 );
       #+end_src
     - $D_\pi \leftarrow simulator( m, \omega )$
       #+begin_src c :tangle abbeel2004apprenticeship.c :main no
    g_mOmega = omega;
    trans = g_fSimulator( m );
       #+end_src
     - $\mu \leftarrow mc( D_\pi, \gamma, \psi )$
       #+begin_src c :tangle abbeel2004apprenticeship.c :main no
    gsl_matrix_free( mu );
    mu = monte_carlo_mu( trans );
    gsl_matrix_free( trans );
       #+end_src
     - $\bar\mu \leftarrow \bar\mu + { (\mu-\bar\mu)^T (\mu_E-\bar\mu) \over (\mu-\bar\mu)^T (\mu-\bar\mu) }(\mu-\bar\mu)$
       #+begin_src c :tangle abbeel2004apprenticeship.c :main no
    gsl_matrix* mu_barmu = 
      gsl_matrix_alloc( g_iP, 1);
    gsl_matrix* muE_barmu = 
      gsl_matrix_alloc( g_iP, 1);
    gsl_matrix* num = gsl_matrix_alloc( 1, 1 );
    gsl_matrix* denom = gsl_matrix_alloc( 1, 1 );
    gsl_matrix* delta_bar_mu = 
      gsl_matrix_alloc( g_iP, 1);
    gsl_matrix_memcpy( mu_barmu, mu );
    gsl_matrix_sub( mu_barmu, bar_mu );
    gsl_matrix_memcpy( muE_barmu, mu_E );
    gsl_matrix_sub( muE_barmu, bar_mu );
    gsl_blas_dgemm( CblasTrans, CblasNoTrans, 1.0,
		    mu_barmu, muE_barmu, 0.0, num );
    gsl_blas_dgemm( CblasTrans, CblasNoTrans, 1.0,
		    mu_barmu, mu_barmu, 0.0, denom );
    gsl_matrix_memcpy( delta_bar_mu, mu_barmu );
    double scale = gsl_matrix_get( num, 0, 0 ) / 
      gsl_matrix_get( denom, 0, 0 );
    gsl_matrix_scale( delta_bar_mu, scale );
    gsl_matrix_add( bar_mu, delta_bar_mu );
    gsl_matrix_free( num );
    gsl_matrix_free( denom );
    gsl_matrix_free( mu_barmu );
    gsl_matrix_free( muE_barmu );
    gsl_matrix_free( delta_bar_mu );
       #+end_src
     - $\theta \leftarrow {\mu_E - \bar\mu\over ||\mu_E - \bar\mu||_2}$
       #+begin_src c :tangle abbeel2004apprenticeship.c :main no
    gsl_matrix_memcpy( theta, mu_E );
    gsl_matrix_sub( theta, bar_mu );
    theta_v = gsl_matrix_column( theta, 0 );
    theta_norm = gsl_blas_dnrm2( &theta_v.vector );
    if( theta_norm != 0 )
      gsl_matrix_scale( theta, 1./theta_norm );
       #+end_src
     - $t\leftarrow ||\mu_E - \bar\mu||_2$
       #+begin_src c :tangle abbeel2004apprenticeship.c :main no
    t = diff_norm( mu_E, bar_mu );
    nb_it++;
  }
       #+end_src
   -  Last Output of the different criteria
     #+begin_src c :tangle abbeel2004apprenticeship.c :main no
  double empirical_err = diff_norm( mu_E, mu );
  double true_err = true_diff_norm( omega );
  double true_V = true_V_diff( omega );
  printf( "%d %d %lf %lf %lf %lf\n", 
	  m, nb_it, 
	  t, empirical_err, true_err, true_V );
  if( true_err <= g_dBest_true_error ){
    g_dBest_error = empirical_err;
    g_dBest_true_error = true_err;
    g_dBest_diff = true_V;
    g_dBest_t = t;
    gsl_matrix_memcpy( g_mBest_omega, omega );
  }
  gsl_matrix_free( omega_0 );
  gsl_matrix_free( mu );
  gsl_matrix_free( mu_E );
  gsl_matrix_free( bar_mu );
  gsl_matrix_free( theta );
  gsl_matrix_free( omega );
  return g_mBest_omega;
}
     #+end_src
** Makefile rules
   Some rules to tangle the source files :
   #+srcname: a2a_code_make
  #+begin_src makefile
abbeel2004apprenticeship.c: abbeel2004apprenticeship.org 
	$(call tangle,"abbeel2004apprenticeship.org")

abbeel2004apprenticeship.h: abbeel2004apprenticeship.org 
	$(call tangle,"abbeel2004apprenticeship.org")
  #+end_src

   A rule to create the object file :
  #+srcname: a2a_c2o_make
  #+begin_src makefile
abbeel2004apprenticeship.o: abbeel2004apprenticeship.c abbeel2004apprenticeship.h LSPI.h utils.h RL_Globals.h IRL_Globals.h criteria.h
	$(call c2obj,"abbeel2004apprenticeship.c")
  #+end_src

   A rule to clean the mess :
  #+srcname: a2a_clean_make
  #+begin_src makefile
a2a_clean:
	find . -maxdepth 1 -iname "abbeel2004apprenticeship.h"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "abbeel2004apprenticeship.c"   | xargs $(XARGS_OPT) rm 
	find . -maxdepth 1 -iname "abbeel2004apprenticeship.o"   | xargs $(XARGS_OPT) rm
  #+end_src
