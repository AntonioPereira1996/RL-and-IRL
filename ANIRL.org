#+TITLE: Abbeel and Ng's IRL algorithm
  
  In their paper, \cite{abbeel2004apprenticeship}, Ng and Abbeel present an IRL algorithm. This file is an implementation of this algorithm in its projection form.


* ANIRL header
** Détails techniques
#+begin_src C
#include "ANIRL.h"

unsigned int g_iK = -1;
unsigned int g_iP = -1;
//gsl_matrix* (*g_fPsi)(gsl_matrix*) = NULL;
double g_dEpsilon_anirl = -1;
unsigned int g_iIt_max_anirl = -1;

gsl_matrix* (g_fMu_pi)(gsl_matrix*) = NULL;
gsl_matrix* (g_fMu_E)() = NULL;

gsl_matrix* omega = proj_ANIRL();
#+end_src
** Entrées
   Pas d'entrées
** Sorties
   - =omega= : matrice correspondant à la fonction de qualité de la politique la plus proche de celle de l'expert rencontrée par l'algorithme
** Paramètres
   - =g_dEpsilon_anirl= : Seuil pour l'arrêt
   - =g_iIt_max_anirl= : Nombre maximum d'itérations
   - =g_fMu_pi= : Fonction renvoyant $E[\mu^\pi(s_0)]$ pour la politique décrite par le $\omega$ donné en argument.
   - =g_fMu_E= : Fonction renvoyant une estimation de la feature expectation de l'expert.
   - =g_fMDP_solver= : Fonction renvoyant la matrice $\omega$ décrivant la $Q$-function de la politique optimale vis-à-vis de la récompense décrite par $\theta$.

   Il faut également régler les paramètres des sous routines =g_fMu_pi=, =g_fMu_E= et =g_fMSP_solver= utilisées.

* Implémentation
** C
   We use the GSL, its BLAS interface and the rest of our code
   #+begin_src c :tangle ANIRL.c :main no
#include <gsl/gsl_matrix.h>
#include <math.h>
#include <gsl/gsl_blas.h>
#include "RL_Globals.h"
#include "IRL_Globals.h"
#include "utils.h"
   #+end_src


   We declare some of the variables of [[file:IRL_Globals.h]]. 
   #+begin_src c :tangle ANIRL.c :main no
double g_dBest_t;
gsl_matrix* g_mBest_omega;
   #+end_src
   
   The implementation of Abbeel and Ng's algorithm is not quite simple. We do not follow the way things are exposed in the paper, but use a simpler (implementation wise) way. Mainly, the value referenced as $\bar\mu^i$ in the paper is now $\bar\mu$, a value constructed by a successive addition of terms. The variable $i$ is no more needed.

   The implementation goes as follow :
   #+begin_src c :tangle ANIRL.c :main no
gsl_matrix* proj_ANIRL(){
  gsl_matrix* omega_0 = gsl_matrix_calloc( g_iK, 1 );
   #+end_src
   - $\omega \leftarrow 0$
     #+begin_src c :tangle ANIRL.c :main no
  gsl_matrix* omega = gsl_matrix_calloc( g_iK, 1 );
     #+end_src
   - $\mu \leftarrow \mu^\pi, \pi \equiv\omega$
     #+begin_src c :tangle ANIRL.c :main no
  gsl_matrix* mu = g_fMu_pi( omega );
     #+end_src
   - $\mu_E \leftarrow \hat\mu_E$
     #+begin_src c :tangle ANIRL.c :main no
  gsl_matrix* mu_E = g_fMu_E();
     #+end_src
   - $\theta \leftarrow {\mu_E - \mu\over ||\mu_E - \mu||_2}$
     #+begin_src c :tangle ANIRL.c :main no
  gsl_matrix* theta = gsl_matrix_alloc(g_iP, 1 );
  gsl_matrix_memcpy( theta, mu_E );
  gsl_matrix_sub( theta, mu );
  gsl_vector_view theta_v = gsl_matrix_column( theta, 0 );
  double theta_norm = gsl_blas_dnrm2( &theta_v.vector );
  if( theta_norm != 0 )
    gsl_matrix_scale( theta, 1./theta_norm );
     #+end_src
   - $\bar\mu \leftarrow \mu$
     #+begin_src c :tangle ANIRL.c :main no
     gsl_matrix* bar_mu = gsl_matrix_alloc( g_iP, 1 );
     gsl_matrix_memcpy( bar_mu, mu );
     #+end_src
   - $t \leftarrow ||\mu_E - \bar\mu||_2$
     #+begin_src c :tangle ANIRL.c :main no
	double t = diff_norm( mu_E, bar_mu );
	unsigned int nb_it = 0;
	g_dBest_t = t;
	g_mBest_omega = gsl_matrix_alloc( omega->size1, omega->size2 );
	gsl_matrix_memcpy( g_mBest_omega, omega );
     #+end_src
   - While $t>\epsilon_{ANIRL}$ and the number of iterations is small enough
     #+begin_src c :tangle ANIRL.c :main no
   while( t > g_dEpsilon_anirl && nb_it < g_iIt_max_anirl ){
     #+end_src
     - Output of the halt criterion
       #+begin_src c :tangle ANIRL.c :main no
    printf( "%d %d %lf\n", m, nb_it, t );
    if( t <= g_dBest_t ){
      g_dBest_t = t;
      gsl_matrix_memcpy( g_mBest_omega, omega );
    }
       #+end_src
     - $\omega \leftarrow MDPsolver( \theta )$
       #+begin_src c :tangle ANIRL.c :main no
    omega = g_fMDP_solver( theta );
       #+end_src
     - $\mu \leftarrow \mu^\pi, \pi \equiv\omega$
       #+begin_src c :tangle ANIRL.c :main no
    mu = g_fMu_pi( omega );
       #+end_src
     - $\bar\mu \leftarrow \bar\mu + { (\mu-\bar\mu)^T (\mu_E-\bar\mu) \over (\mu-\bar\mu)^T (\mu-\bar\mu) }(\mu-\bar\mu)$
       #+begin_src c :tangle ANIRL.c :main no
    gsl_matrix* mu_barmu = 
      gsl_matrix_alloc( g_iP, 1);
    gsl_matrix* muE_barmu = 
      gsl_matrix_alloc( g_iP, 1);
    gsl_matrix* num = gsl_matrix_alloc( 1, 1 );
    gsl_matrix* denom = gsl_matrix_alloc( 1, 1 );
    gsl_matrix* delta_bar_mu = 
      gsl_matrix_alloc( g_iP, 1);
    gsl_matrix_memcpy( mu_barmu, mu );
    gsl_matrix_sub( mu_barmu, bar_mu );
    gsl_matrix_memcpy( muE_barmu, mu_E );
    gsl_matrix_sub( muE_barmu, bar_mu );
    gsl_blas_dgemm( CblasTrans, CblasNoTrans, 1.0,
		    mu_barmu, muE_barmu, 0.0, num );
    gsl_blas_dgemm( CblasTrans, CblasNoTrans, 1.0,
		    mu_barmu, mu_barmu, 0.0, denom );
    gsl_matrix_memcpy( delta_bar_mu, mu_barmu );
    double scale = gsl_matrix_get( num, 0, 0 ) / 
      gsl_matrix_get( denom, 0, 0 );
    gsl_matrix_scale( delta_bar_mu, scale );
    gsl_matrix_add( bar_mu, delta_bar_mu );
    gsl_matrix_free( num );
    gsl_matrix_free( denom );
    gsl_matrix_free( mu_barmu );
    gsl_matrix_free( muE_barmu );
    gsl_matrix_free( delta_bar_mu );
       #+end_src
     - $\theta \leftarrow {\mu_E - \bar\mu\over ||\mu_E - \bar\mu||_2}$
       #+begin_src c :tangle ANIRL.c :main no
    gsl_matrix_memcpy( theta, mu_E );
    gsl_matrix_sub( theta, bar_mu );
    theta_v = gsl_matrix_column( theta, 0 );
    theta_norm = gsl_blas_dnrm2( &theta_v.vector );
    if( theta_norm != 0 )
      gsl_matrix_scale( theta, 1./theta_norm );
       #+end_src
     - $t\leftarrow ||\mu_E - \bar\mu||_2$
       #+begin_src c :tangle ANIRL.c :main no
    t = diff_norm( mu_E, bar_mu );
    nb_it++;
  }
       #+end_src
   -  Last Output of the different criteria
     #+begin_src c :tangle ANIRL.c :main no
  printf( "%d %d %lf %lf %lf %lf\n", m, nb_it, t );
  if( t <= g_dBest_t ){
    g_dBest_t = t;
    gsl_matrix_memcpy( g_mBest_omega, omega );
  }
  gsl_matrix_free( omega_0 );
  gsl_matrix_free( mu );
  gsl_matrix_free( mu_E );
  gsl_matrix_free( bar_mu );
  gsl_matrix_free( theta );
  gsl_matrix_free( omega );
  return g_mBest_omega;
}
     #+end_src
** Makefile rules
   Some rules to tangle the source files :
   #+srcname: ANIRL_code_make
  #+begin_src makefile
ANIRL.c: ANIRL.org 
	$(call tangle,"ANIRL.org")

ANIRL.h: ANIRL.org 
	$(call tangle,"ANIRL.org")
  #+end_src

   A rule to create the object file :
  #+srcname: ANIRL_c2o_make
  #+begin_src makefile
ANIRL.o: ANIRL.c ANIRL.h utils.h RL_Globals.h IRL_Globals.h 
	$(call c2obj,"ANIRL.c")
  #+end_src

   A rule to clean the mess :
  #+srcname: ANIRL_clean_make
  #+begin_src makefile
ANIRL_clean:
	find . -maxdepth 1 -iname "ANIRL.h"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "ANIRL.c"   | xargs $(XARGS_OPT) rm 
	find . -maxdepth 1 -iname "ANIRL.o"   | xargs $(XARGS_OPT) rm
  #+end_src
