#+TITLE: Trajectory generator for the gridworld

This program generates a random walk in a gridworld. See \cite{ng2000algorithms} for a longer explanation of this toy problem. The transitions are output on the standard output. They have the following format $s~a~s'~r~eoe$ where : 
 - s and s' are couples in $[1:width] \times [1:height]$
 - a is an int in [1:4] fo the four compass direction
 - r is the reward, 1 in $(width,height)$ 0 otherwise
 - eoe is the end of episode flag. If not at the end of a trajectory its value is 1, 0 otherwise
* C implementation
The code is quite straightforward.

We use the GSL.
#+begin_src c :tangle generator.c :main no
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <unistd.h>
#include <gsl/gsl_matrix.h>
#include "utils.h"
#+end_src

We set some constants.
#+begin_src c :tangle generator.c :main no
#include "GridWorld.h"
#define NUMBER_OF_WALKS 500
#define MAX_WALK_LENGTH  (GRID_HEIGHT+GRID_WIDTH)
#+end_src

We generate the requested number of walks, the initial state being drawn randomly.
#+begin_src c :tangle generator.c :main no
int main(void){
  srand(time(NULL)+getpid()); rand(); rand();rand();
  for( unsigned int i = 0 ; i < NUMBER_OF_WALKS ; i++ ){
    unsigned int state_x = random_int( 1, GRID_WIDTH );
    unsigned int state_y = random_int( 1, GRID_HEIGHT );
    int eoe = 1;
#+end_src
For each walk, the requested number of steps is generated.
#+begin_src c :tangle generator.c :main no
    for( unsigned int j = 0 ; j < MAX_WALK_LENGTH && eoe == 1 ; 
	 j++ ){
      if( j == MAX_WALK_LENGTH - 1 ){
	eoe = 0;
      }
#+end_src

We set the next state according to the rules.
#+begin_src c :tangle generator.c :main no
      unsigned int next_state_x = state_x;
      unsigned int next_state_y = state_y;
      unsigned int action = random_int( 1, 4 );
      unsigned int true_action = action;
      int is_noisy = rand_1_in_10();
      if( is_noisy ){
	true_action = random_int( 1, 4 );
      }
      switch( true_action ){
      case UP:
	next_state_y++;
	if( next_state_y > GRID_HEIGHT ){
	  next_state_y = GRID_HEIGHT;
	}
	break;
      case DOWN:
	next_state_y--;
	if( next_state_y < 1 ){
	  next_state_y = 1;
	}
	break;
      case RIGHT:
	next_state_x++;
	if( next_state_x > GRID_WIDTH ){
	  next_state_x = GRID_WIDTH;
	}
	break;
      case LEFT:
	next_state_x--;
	if( next_state_x < 1 ){
	  next_state_x = 1;
	}
	break;
      }
#+end_src

The reward...
#+begin_src c :tangle generator.c :main no
      int reward = 0;
      if( state_x == GRID_WIDTH && 
	  state_y == GRID_HEIGHT ){
	reward = 1;
	eoe = 0;
      }
#+end_src

Finally, each transition is printed.
#+begin_src c :tangle generator.c :main no
      printf("%d %d %d %d %d %d %d\n",
	     state_x, state_y, action, 
	     next_state_x, next_state_y, reward, eoe );
      state_x = next_state_x;
      state_y = next_state_y;
    }
  }
}
#+end_src
* Makefile rules
  Some rules to tangle the source files :
  #+srcname: Generator_code_make
  #+begin_src makefile
generator.c: generator.org 
	$(call tangle,"generator.org")
  #+end_src

   A rule to create the object file :
  #+srcname: Generator_c2o_make
  #+begin_src makefile
generator.o: generator.c GridWorld.h ../utils.h 
	$(call c2obj,"generator.c")
  #+end_src

   A rule to create the executable from the object file :
#+srcname: Generator_o2exe_make
#+begin_src makefile
generator.exe: generator.o ../utils.o
	$(O2EXE) -o generator.exe generator.o ../utils.o
#+end_src


   A rule to clean the mess :
  #+srcname: Generator_clean_make
  #+begin_src makefile
Generator_clean:
	find . -maxdepth 1 -iname "Generator.exe"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "Generator.c"   | xargs $(XARGS_OPT) rm 
	find . -maxdepth 1 -iname "Generator.o"   | xargs $(XARGS_OPT) rm
  #+end_src

