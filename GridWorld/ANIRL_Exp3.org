#+TITLE:ANIRL, GridWorld, Dégradé

Cette expérience s'inscrit dans une démarche de test plus grande : [[file:../Protocoles.org]]. 

On récupère, comme prévu dans le protocole, les valeurs des paramètres d'ANIRL trouvées dans le cas parfait ([[file:ANIRL_Exp2.org]]). A savoir : $\epsilon_{ANIRL} = 0.3$ et $T_{ANIRL} = 170$.

Il ne reste enfin plus qu'à utiliser ces données pour faire tourner ANIRL.
#+begin_src c :tangle ANIRL_Exp3.c :main no
#define _POSIX_C_SOURCE 1
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_blas.h>
#include <math.h>
#include "GridWorld.h"
#include "simulator.h"
#include "utils.h"
#include "LSPI.h"
#include "ANIRL.h"
#include "LSTDmu.h"
#include "greedy.h"
#include "phipsi.h"

#include "RL_Globals.h"
#include "IRL_Globals.h"
#define TRANS_WIDTH 7
#define ACTION_FILE "actions.mat"

unsigned int g_iS = 2;
unsigned int g_iA = 1;
unsigned int g_iIt_max_lspi = 20;
gsl_matrix* (*g_fPhi)(gsl_matrix*) = &phi;
gsl_matrix* g_mOmega = NULL;
double g_dLambda_lstdQ = 0.1;
double g_dGamma_lstdq =  0.9;
double g_dEpsilon_lspi = 0.1;
double g_dLambda_lstdmu = 0.1;
double g_dGamma_anirl = 0.9;
double g_dEpsilon_anirl = 0.03;
unsigned int g_iIt_max_anirl = 170;
gsl_matrix* g_mActions = NULL; 
gsl_matrix* (*g_fPsi)(gsl_matrix*) = &psi;
gsl_matrix* D_E = NULL;
gsl_matrix* D_mu = NULL;
gsl_matrix* (*g_fSimulator)(int) = NULL;

//FIXME: Useless but defined anyway in order to compile
unsigned int M = -1; //M_{MCip}
double g_dGamma_lafem = -1;
#+end_src

Les sous routines utilisées pour ANIRL sont :
 - LSTD$\mu$ pour le calcul des /feature expectations/ :
   #+begin_src c :tangle ANIRL_Exp3.c :main no
gsl_matrix* S_0(){
  gsl_matrix* s_0 = gsl_matrix_alloc( 1, 2 );
  gsl_matrix_set( s_0, 0, 0, 0 );
  gsl_matrix_set( s_0, 0, 1, GRID_HEIGHT-1 );
  return s_0;
}

gsl_matrix* mu_pi(gsl_matrix* omega){
  g_mOmega = omega;
  return lstd_mu( D_mu, &greedy_policy );
}

gsl_matrix* mu_E(){
  return lstd_mu_op( D_mu );
}

gsl_matrix* (*g_fS_0)(void) = &S_0;
gsl_matrix* (*g_fMu_pi)(gsl_matrix*) = &mu_pi;
gsl_matrix* (*g_fMu_E)() = &mu_E;

   #+end_src
 - LSPI en tant que solveur de MDP :
   FIXME: Coder ce wrapper dans ANIRL.org, il est utilisé souvent, ce code est dupliqué tel quel en plusieurs endroits.
   #+begin_src c :tangle ANIRL_Exp3.c :main no
gsl_matrix* lspi_wrapper(gsl_matrix* theta){
  for( unsigned int i = 0 ; i < D_E->size1 ; i++ ){
    gsl_matrix_view state = 
      gsl_matrix_submatrix( D_E, i, 0, 1, g_iS );
    gsl_matrix* psi_s = g_fPsi( &state.matrix );
    gsl_matrix_view r = 
      gsl_matrix_submatrix( D_E, i, 2*g_iS+g_iA, 1, 1 );
    gsl_blas_dgemm( CblasTrans, CblasNoTrans, 1.0, 
		    theta, psi_s, 0.0, &r.matrix );
    gsl_matrix_free( psi_s );
    }
  gsl_matrix* omega_0 = gsl_matrix_calloc( g_iK, 1 );
  gsl_matrix* omega = lspi( D_E, omega_0 );
  gsl_matrix_free( omega_0 );
  return omega;
}

gsl_matrix* (*g_fMDP_solver)(gsl_matrix*) = &lspi_wrapper;
   #+end_src



#+begin_src c :tangle ANIRL_Exp3.c :main no
int main( int argc, char** argv ){
  g_mActions = file2matrix( ACTION_FILE, g_iA );
  D_E = file2matrix( argv[1], TRANS_WIDTH );
  D_mu = gsl_matrix_alloc( D_E->size1, g_iS + g_iA + g_iS + g_iP + 1 );

  for( int i = 0; i < D_E->size1 ; i++ ){
    gsl_matrix_view vsasdash_src = gsl_matrix_submatrix( D_E, i, 0, 1, g_iS + g_iA + g_iS );
    gsl_matrix_view vsasdash_dst = gsl_matrix_submatrix( D_mu, i, 0,
							 1, g_iS + g_iA + g_iS );
    gsl_matrix_memcpy( &(vsasdash_dst.matrix), &(vsasdash_src.matrix) );
    
    gsl_matrix_view vs = gsl_matrix_submatrix( D_E, i, 0, 1, g_iS );
    gsl_matrix* psi_s = g_fPsi( &(vs.matrix) );
    gsl_matrix_view vpsi_s = gsl_matrix_submatrix( D_mu, i, g_iS + g_iA + g_iS, 1, g_iP );
    gsl_matrix_transpose_memcpy( &(vpsi_s.matrix), psi_s );
    gsl_matrix_free( psi_s );

    gsl_matrix_view eoe_src = gsl_matrix_submatrix( D_E, i, g_iS + g_iA + g_iS + 1,
						    1, 1 );
    gsl_matrix_view eoe_dst = gsl_matrix_submatrix( D_mu, i, g_iS + g_iA + g_iS + g_iP,
						    1, 1 );
    gsl_matrix_memcpy( &(eoe_dst.matrix), &(eoe_src.matrix) );    
  }
//FIXME: La fabrication de D_mu est elle aussi présente en plusieurs exemplaires. On pourrait également la factoriser dans ANIRL.org
#+end_src

On lance ANIRL :
#+begin_src c :tangle ANIRL_Exp3.c :main no
    gsl_matrix* omega_agent =proj_ANIRL();
#+end_src

Puis on vérifie que le contrôle obtenu tient la route :
#+begin_src c :tangle ANIRL_Exp3.c :main no
  matrix2file( "ANIRL_Exp3_omega_agent.mat", omega_agent );
  printf("%d ",D_E->size1);
  fflush(NULL);
  return system( "python EvaluateOmega.py ANIRL_Exp3_omega_agent.mat" );
}

#+end_src

   #+srcname: ANIRL_Exp3_make
   #+begin_src makefile
ANIRL_Exp3.c: ANIRL_Exp3.org
	$(call tangle,"ANIRL_Exp3.org")
ANIRL_Exp3.o: ANIRL_Exp3.c GridWorld.h ../greedy.h ../RL_Globals.h ../utils.h  phipsi.h simulator.h ../LSTDmu.h ../IRL_Globals.h ../ANIRL.h ../LSPI.h
	$(call c2obj,"ANIRL_Exp3.c")
#FIXME: On ne devrait pas avoir à lier avec criteria.o ou abbeel2004apprenticeship.o
ANIRL_Exp3.exe: ANIRL_Exp3.o ../greedy.o ../utils.o  phipsi.o simulator.o ../LSTDmu.o ../ANIRL.o ../LSPI.o ../LSTDQ.o ../criteria.o ../abbeel2004apprenticeship.o
	$(O2EXE) -o ANIRL_Exp3.exe ANIRL_Exp3.o ../greedy.o ../utils.o  phipsi.o simulator.o ../LSTDmu.o ../ANIRL.o ../LSPI.o ../LSTDQ.o ../criteria.o ../abbeel2004apprenticeship.o

LM_VALUES="10 1" "15 1" "20 2" "20 10" "20 20" "20 30"
ANIRL_Exp3: ANIRL_Exp3.exe EvaluateOmega.py DE.py V_Expert.mat
	for i in $(LM_VALUES); \
	do \
	python DE.py $$i > DE.mat; \
        ./ANIRL_Exp3.exe DE.mat >> ANIRL_Exp3.mat; \
	done

   #+end_src


  #+srcname: ANIRL_Exp3_clean_make
  #+begin_src makefile
ANIRL_Exp3_clean:
	find . -maxdepth 1 -iname "ANIRL_Exp3.h"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "ANIRL_Exp3.c"   | xargs $(XARGS_OPT) rm 
	find . -maxdepth 1 -iname "ANIRL_Exp3.o"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "ANIRL_Exp3.exe"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "ANIRL_Exp3.tex"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "ANIRL_Exp3.pdf"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "ANIRL_Exp3_*"   | xargs $(XARGS_OPT) rm

  #+end_src



* Plotting
#+begin_src python :tangle ANIRL_Exp3_plot.py
from matplotlib import rc
rc('text', usetex=True)
import sys
sys.path+=['..']
from numpy import *
import scipy
import pylab as pylab
from Plot import *

D_ANIRL = genfromtxt( "ANIRL_Exp3.mat" )
[XA,Y_meanA,Y_minA,Y_maxA] = map( array, mean_min_max( D_ANIRL ))
[XA,Y_meanA,Y_varA] = map( array, mean_var( D_ANIRL ))

Expert = 4.11057152*ones(XA.shape) #python Expert.py to get this value
Random_mean = 0.44716131254651209*ones(XA.shape)#See Highway.org about Random.py for information on these values
Random_min = 0.070870373379200005*ones(XA.shape)#python Random.py to get this value
Random_max = 3.9837417388*ones(XA.shape)#python Random.py to get this value
Random_var = 0.79871008754797834*ones(XA.shape)#python Random.py to get this value
x_min = min(XA)
x_max = max(XA)
y_max = 5.0 #Comme ca l'expert peut respirer
y_min = min( Random_min[0],min(Y_minA) ) - 1.2

#Third plot, ANIRL avec les features informatives, seul
#Second plot, Cascading avec les features informatives, seul
pylab.figure(1)
pylab.clf()
pylab.axis([x_min,x_max,y_min,y_max])
pylab.xlabel('Number of samples from the expert')
pylab.ylabel('${1\over card(S)}\sum\limits_{s\in S}V(s)$')
pylab.grid(True)
filled_mean_min_max( pylab, XA, Y_meanA, Y_minA, Y_maxA, 'green', 0.2,'--',"Abbeel \& Ng IRL",None)
filled_mean_min_max( pylab, XA, Y_meanA, Y_meanA - Y_varA, Y_meanA + Y_varA, 'green', 0.4,'-.',None,None)
filled_mean_min_max( pylab, XA, Random_mean, Random_min, Random_max, 'cyan',0.2,'--',"Agent trained on a random reward",None)
filled_mean_min_max( pylab, XA, Random_mean, Random_mean-Random_var, Random_mean+Random_var, 'cyan',0.4,'-.',None,None)
pylab.plot(XA,Expert, color='blue',label="Expert",lw=2)
pylab.savefig('ANIRL_Exp3_fig1.pdf',transparent=True)

#Fourth file : the legend
fig = pylab.figure(2)
figlegend = pylab.figure(figsize=(4,2))
ax = fig.add_subplot(111)
#lines = ax.plot([-1,-1],[-1,-2], color='red',label="Cascading IRL",lw=2,linestyle='-')
lines = ax.plot([-1,-1],[-1,-2], color='green',label="Abbeen \& Ng IRL",lw=2,linestyle='-')
lines += ax.plot([-1,-1],[-1,-2], color='cyan',label="Agent trained on a random reward",lw=2,linestyle='-')
lines += ax.plot([-1,-1],[-1,-2], color='black',label="min, max",lw=1,linestyle='--')
lines += ax.plot([-1,-1],[-1,-2], color='black',label="Standard deviation",lw=1,linestyle='-.')
lines += ax.plot([-1,-1],[-1,-2], color='blue',label="Expert",lw=2,linestyle='-')
#figlegend.legend(lines,("Cascading IRL","Abbeel \& Ng IRL","Agent trained on a random reward","min, max","Standard deviation","Expert"),"center")
figlegend.legend(lines,("Abbeel \& Ng IRL","Agent trained on a random reward","min, max","Standard deviation","Expert"),"center")
figlegend.savefig("ANIRL_Exp3_legend.pdf")

#+end_src
FIXME: Le plot concernat ANIRL devrait avoir son code dans ANIRL_Exp6.org et non ici.

#+srcname: ANIRL_Exp3_make
#+begin_src makefile
ANIRL_Exp3_plot.py: ANIRL_Exp3.org
	$(call tangle,"ANIRL_Exp3.org")

ANIRL_Exp3_fig1.pdf: ANIRL_Exp3_plot.py ANIRL_Exp3.mat ../Plot.py
	python ANIRL_Exp3_plot.py

../Plot.py:
	make -C .. Plot.py

#+end_src
