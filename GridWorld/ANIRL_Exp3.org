#+TITLE:ANIRL, GridWorld, Dégradé

Cette expérience s'inscrit dans une démarche de test plus grande : [[file:../Protocoles.org]]. 

On récupère, comme prévu dans le protocole, les valeurs des paramètres d'ANIRL trouvées dans le cas parfait ([[file:ANIRL_Exp2.org]]). A savoir : $\epsilon_{ANIRL} = 0.3$ et $T_{ANIRL} = 170$.

L'expérience est un succès puisque la longueur de la trajectoire de l'agent est assez proche de celle de l'expert et assez loin de la limite autorisée.
Pour réaliser l'expérience :
 : make ANIRL_Exp3
dans le dossier racine.

L'expert est entraîné grâce à l'algorithme de programmation dynamique. On transforme cette politique dans un format exploitable par le simulateur grâce à:
#+begin_src python :tangle pi2omega.py
#FIXME: Factoriser ce code avec celui present dans ANIRL_Exp2.org, dans R2omega.py
import sys
from numpy import *
import scipy


R = genfromtxt( sys.argv[1] )
Ppi = genfromtxt( sys.argv[2] )
V = genfromtxt( sys.argv[3] )
P_north = genfromtxt( "TT_5x5_PENorth.mat" )
P_east = genfromtxt( "TT_5x5_PEEast.mat" )
P_west = genfromtxt( "TT_5x5_PEWest.mat" )
P_south = genfromtxt( "TT_5x5_PESouth.mat" )

#On construit maintenant la matrice omega, les
# indices utilises sont donc les memes
# que ceux de la fonction phi
# definie dans LSTDmu_exp.org
# FIXME: Creer un fichier qui decrit les indices
# est s'y referer a chaque fois

omega = zeros((100,1))

for x in range(0,5):
    for y in range(0,5):
        for a in range(1,5):
            index = y*5*4 + x*4 + a-1
            P_a = array([])
            if a == 1:
                P_a = P_west
            elif a == 2:
                P_a = P_south
            elif a == 3:
                P_a = P_north
            elif a == 4:
                P_a = P_east
            else:
                print "BOUM"
                exit( -1 )
            #Q(s,a) = R(s) + \gamma P_a(s)^TV
            #FIXME: Gamma est code en dur ici
            omega[index,0] = R[ x+5*y ] + 0.9*dot( P_a[x+5*y,:], V )
            #if x == 3 and y == 0:
                #import pdb
                #pdb.set_trace()
                #print "Index s : %d | Index sa : %d | Q((3,0),%d) = %f"%(x+5*y,index,a,R[ x+5*y ] + 0.9*dot( P_a[x+5*y,:], V ))

savetxt( "ANIRL_Exp3_expert_omega.mat", omega, "%e", "\n" )

#+end_src

#+srcname: ANIRL_Exp3_make
#+begin_src makefile
pi2omega.py: ANIRL_Exp3.org
	$(call tangle,"ANIRL_Exp3.org")

ANIRL_Exp3_expert_omega.mat: pi2omega.py TT_5x5_PENorth.mat TT_5x5_PESouth.mat TT_5x5_PEWest.mat TT_5x5_PEEast.mat TT_5x5_Ppi.mat ANIRL_Exp2_R_E.mat V_expert.mat
	python pi2omega.py ANIRL_Exp2_R_E.mat TT_5x5_Ppi.mat V_expert.mat

#+end_src

On peut maintenant s'occuper de générer une trajectoire (conformément au protocole) 

#+begin_src c :tangle ANIRL_Exp3_D_E.c :main no
#include <gsl/gsl_matrix.h>
#include "phipsi.h"
#include "simulator.h"
#include "utils.h"
#include "greedy.h"

#include "GridWorld.h"
#include "RL_Globals.h"
#define D_FILE_NAME "Samples.dat"
#define TRANS_WIDTH 7
#define ACTION_FILE "actions.mat"

unsigned int g_iS = 2;
unsigned int g_iA = 1;
gsl_matrix* (*g_fPhi)(gsl_matrix*) = &phi;
gsl_matrix* g_mOmega = NULL;
gsl_matrix* g_mActions = NULL; 

int main( void ){
  g_mActions = file2matrix( ACTION_FILE, 1 );
  gsl_matrix* omega_expert = file2matrix( "ANIRL_Exp3_expert_omega.mat", 1 );
  g_mOmega =  omega_expert;
  gsl_matrix* D_expert = gridworld_simulator( 1 );
  matrix2file( "ANIRL_Exp3_D_E.mat", D_expert );
  return 0;
}

#+end_src

   #+srcname: ANIRL_Exp3_make
   #+begin_src makefile
ANIRL_Exp3_D_E.c: ANIRL_Exp3.org
	$(call tangle,"ANIRL_Exp3.org")
ANIRL_Exp3_D_E.o: ANIRL_Exp3_D_E.c GridWorld.h ../greedy.h ../RL_Globals.h ../utils.h  phipsi.h simulator.h
	$(call c2obj,"ANIRL_Exp3_D_E.c")

ANIRL_Exp3_D_E.exe: ANIRL_Exp3_D_E.o ../greedy.o ../utils.o phipsi.o simulator.o
	$(O2EXE) -o ANIRL_Exp3_D_E.exe ANIRL_Exp3_D_E.o ../greedy.o ../utils.o phipsi.o simulator.o

ANIRL_Exp3_D_E.mat: ANIRL_Exp3_D_E.exe ANIRL_Exp3_expert_omega.mat
	./ANIRL_Exp3_D_E.exe

   #+end_src

Il ne reste enfin plus qu'à utiliser ces données pour faire tourner ANIRL.
#+begin_src c :tangle ANIRL_Exp3.c :main no
#define _POSIX_C_SOURCE 1
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_blas.h>
#include <math.h>
#include "GridWorld.h"
#include "simulator.h"
#include "utils.h"
#include "LSPI.h"
#include "ANIRL.h"
#include "LSTDmu.h"
#include "greedy.h"
#include "phipsi.h"

#include "RL_Globals.h"
#include "IRL_Globals.h"
#define TRANS_WIDTH 7
#define ACTION_FILE "actions.mat"
#define EXPERT_FILE "ANIRL_Exp3_D_E.mat"

unsigned int g_iS = 2;
unsigned int g_iA = 1;
unsigned int g_iIt_max_lspi = 20;
gsl_matrix* (*g_fPhi)(gsl_matrix*) = &phi;
gsl_matrix* g_mOmega = NULL;
double g_dLambda_lstdQ = 0.1;
double g_dGamma_lstdq =  0.9;
double g_dEpsilon_lspi = 0.1;
double g_dLambda_lstdmu = 0.1;
double g_dGamma_anirl = 0.9;
double g_dEpsilon_anirl = 0.03;
unsigned int g_iIt_max_anirl = 170;
gsl_matrix* g_mActions = NULL; 
gsl_matrix* (*g_fPsi)(gsl_matrix*) = &psi;
gsl_matrix* D_E = NULL;
gsl_matrix* D_mu = NULL;
gsl_matrix* (*g_fSimulator)(int) = &gridworld_simulator;

//FIXME: Useless but defined anyway in order to compile
unsigned int M = -1; //M_{MCip}
double g_dGamma_lafem = -1;
#+end_src

Les sous routines utilisées pour ANIRL sont :
 - LSTD$\mu$ pour le calcul des /feature expectations/ :
   #+begin_src c :tangle ANIRL_Exp3.c :main no
gsl_matrix* S_0(){
  gsl_matrix* s_0 = gsl_matrix_alloc( 1, 2 );
  gsl_matrix_set( s_0, 0, 0, 0 );
  gsl_matrix_set( s_0, 0, 1, GRID_HEIGHT-1 );
  return s_0;
}

gsl_matrix* mu_pi(gsl_matrix* omega){
  g_mOmega = omega;
  return lstd_mu( D_mu, &greedy_policy );
}

gsl_matrix* mu_E(){
  return lstd_mu_op( D_mu );
}

gsl_matrix* (*g_fS_0)(void) = &S_0;
gsl_matrix* (*g_fMu_pi)(gsl_matrix*) = &mu_pi;
gsl_matrix* (*g_fMu_E)() = &mu_E;

   #+end_src
 - LSPI en tant que solveur de MDP :
   #+begin_src c :tangle ANIRL_Exp3.c :main no
gsl_matrix* lspi_wrapper(gsl_matrix* theta){
  for( unsigned int i = 0 ; i < D_E->size1 ; i++ ){
    gsl_matrix_view state = 
      gsl_matrix_submatrix( D_E, i, 0, 1, g_iS );
    gsl_matrix* psi_s = g_fPsi( &state.matrix );
    gsl_matrix_view r = 
      gsl_matrix_submatrix( D_E, i, 2*g_iS+g_iA, 1, 1 );
    gsl_blas_dgemm( CblasTrans, CblasNoTrans, 1.0, 
		    theta, psi_s, 0.0, &r.matrix );
    gsl_matrix_free( psi_s );
    }
  gsl_matrix* omega_0 = gsl_matrix_calloc( g_iK, 1 );
  gsl_matrix* omega = lspi( D_E, omega_0 );
  gsl_matrix_free( omega_0 );
  return omega;
}

gsl_matrix* (*g_fMDP_solver)(gsl_matrix*) = &lspi_wrapper;
   #+end_src



#+begin_src c :tangle ANIRL_Exp3.c :main no
int main( void ){
  g_mActions = file2matrix( ACTION_FILE, g_iA );
  D_E = file2matrix( EXPERT_FILE, TRANS_WIDTH );
  D_mu = gsl_matrix_alloc( D_E->size1, g_iS + g_iA + g_iS + g_iP + 1 );

  for( int i = 0; i < D_E->size1 ; i++ ){
    gsl_matrix_view vsasdash_src = gsl_matrix_submatrix( D_E, i, 0, 1, g_iS + g_iA + g_iS );
    gsl_matrix_view vsasdash_dst = gsl_matrix_submatrix( D_mu, i, 0,
							 1, g_iS + g_iA + g_iS );
    gsl_matrix_memcpy( &(vsasdash_dst.matrix), &(vsasdash_src.matrix) );
    
    gsl_matrix_view vs = gsl_matrix_submatrix( D_E, i, 0, 1, g_iS );
    gsl_matrix* psi_s = g_fPsi( &(vs.matrix) );
    gsl_matrix_view vpsi_s = gsl_matrix_submatrix( D_mu, i, g_iS + g_iA + g_iS, 1, g_iP );
    gsl_matrix_transpose_memcpy( &(vpsi_s.matrix), psi_s );
    gsl_matrix_free( psi_s );

    gsl_matrix_view eoe_src = gsl_matrix_submatrix( D_E, i, g_iS + g_iA + g_iS + 1,
						    1, 1 );
    gsl_matrix_view eoe_dst = gsl_matrix_submatrix( D_mu, i, g_iS + g_iA + g_iS + g_iP,
						    1, 1 );
    gsl_matrix_memcpy( &(eoe_dst.matrix), &(eoe_src.matrix) );    
  }

#+end_src

On lance ANIRL :
#+begin_src c :tangle ANIRL_Exp3.c :main no
    gsl_matrix* omega_agent =proj_ANIRL();
#+end_src

Puis on vérifie que le contrôle obtenu tient la route :
#+begin_src c :tangle ANIRL_Exp3.c :main no
  g_mOmega = omega_agent;
  gsl_matrix* D_agent = gridworld_simulator( 1000 );
  printf("Longueur moyenne du run de l'agent : %f\n",((double)(D_agent->size1))/1000.);
  return 0;
}

#+end_src

   #+srcname: ANIRL_Exp3_make
   #+begin_src makefile
ANIRL_Exp3.c: ANIRL_Exp3.org
	$(call tangle,"ANIRL_Exp3.org")
ANIRL_Exp3.o: ANIRL_Exp3.c GridWorld.h ../greedy.h ../RL_Globals.h ../utils.h  phipsi.h simulator.h ../LSTDmu.h ../IRL_Globals.h ../ANIRL.h ../LSPI.h
	$(call c2obj,"ANIRL_Exp3.c")
#FIXME: On ne devrait pas avoir à lier avec criteria.o ou abbeel2004apprenticeship.o
ANIRL_Exp3.exe: ANIRL_Exp3.o ../greedy.o ../utils.o  phipsi.o simulator.o ../LSTDmu.o ../ANIRL.o ../LSPI.o ../LSTDQ.o ../criteria.o ../abbeel2004apprenticeship.o
	$(O2EXE) -o ANIRL_Exp3.exe ANIRL_Exp3.o ../greedy.o ../utils.o  phipsi.o simulator.o ../LSTDmu.o ../ANIRL.o ../LSPI.o ../LSTDQ.o ../criteria.o ../abbeel2004apprenticeship.o

ANIRL_Exp3: ANIRL_Exp3_D_E.mat ANIRL_Exp3.exe
	./ANIRL_Exp3.exe

   #+end_src


  #+srcname: ANIRL_Exp3_clean_make
  #+begin_src makefile
ANIRL_Exp3_clean:
	find . -maxdepth 1 -iname "ANIRL_Exp3.h"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "ANIRL_Exp3.c"   | xargs $(XARGS_OPT) rm 
	find . -maxdepth 1 -iname "ANIRL_Exp3.o"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "ANIRL_Exp3.exe"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "ANIRL_Exp3.tex"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "ANIRL_Exp3.pdf"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "ANIRL_Exp3_D_E.*"   | xargs $(XARGS_OPT) rm

  #+end_src


