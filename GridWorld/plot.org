#+TITLE: Plots for the paper about LSTD-$\mu$

This program outputs the data needed to plot three of the graphs (Figures 1, 4 and 5).

We use the GSL, the LSPI algorithm, Abbeel and Ng's IRL algorithm and our LSPI variant.
#+begin_src c :tangle plot.c :main no
#include <gsl/gsl_matrix.h>
#include "simulator.h"
#include "utils.h"
#include "LSPI.h"
#include "abbeel2004apprenticeship.h"
#include "LSTDmu.h"
#include "criteria.h"
#+end_src

We set some constants
#+begin_src c :tangle plot.c :main no
#include "GridWorld.h"
#include "RL_Globals.h"
#include "IRL_Globals.h"
#define D_FILE_NAME "Samples.dat"
#define TRANS_WIDTH 7
#define ACTION_FILE "actions.mat"
#+end_src

We define both feature functions : $\phi: S\times A \rightarrow \mathbb{R}^p$ and $\phi: S\rightarrow \mathbb{R}^p$.
#+begin_src c :tangle plot.c :main no
unsigned int g_iK = (GRID_HEIGHT*GRID_WIDTH*4); /* dim(\phi) */
unsigned int g_iP = (GRID_HEIGHT*GRID_WIDTH); /* dim(\psi) */

gsl_matrix* phi( gsl_matrix* sa ){
  gsl_matrix* answer = gsl_matrix_calloc( g_iK, 1 );
  unsigned int x = (unsigned int)gsl_matrix_get( sa, 0, 0 );
  unsigned int y = (unsigned int)gsl_matrix_get( sa, 0, 1 );
  unsigned int a = (unsigned int)gsl_matrix_get( sa, 0, 2 );
  unsigned int index = (y-1)*GRID_WIDTH*4 + (x-1)*4 + a-1;
  gsl_matrix_set( answer, index, 0, 1.0 );
  return answer;
}

gsl_matrix* psi( gsl_matrix* s ){
  gsl_matrix* answer = gsl_matrix_calloc( g_iP, 1 );
  unsigned int x = (unsigned int)gsl_matrix_get( s, 0, 0 );
  unsigned int y = (unsigned int)gsl_matrix_get( s, 0, 1 );
  unsigned int index = (y-1)*GRID_WIDTH + (x-1);
  gsl_matrix_set( answer, index, 0, 1.0 );
  return answer;
}
#+end_src

At the beginning of each episode, the player comes back to the lower left cell (i.e. coordinates (1,1) ).
#+begin_src c :tangle plot.c :main no
gsl_matrix* initial_state( void ){
  gsl_matrix* answer = gsl_matrix_alloc( 1, 2 );
  gsl_matrix_set( answer, 0, 0, 1.0 );
  gsl_matrix_set( answer, 0, 1, 1.0 );
  return answer;
}
#+end_src

We declare and set the global variables of our RL and IRL implementations.
#+begin_src c :tangle plot.c :main no
unsigned int g_iS = 2;
unsigned int g_iA = 1;
unsigned int g_iIt_max_lspi = 20;
gsl_matrix* (*g_fPhi)(gsl_matrix*) = &phi;
gsl_matrix* g_mOmega = NULL;
double g_dLambda_lstdQ = 0.1;
double g_dGamma_lstdq =  0.9;
double g_dEpsilon_lspi = 0.1;
double g_dLambda_lstdmu = 0.1;
double g_dGamma_anirl = 0.9;
double g_dEpsilon_anirl = 0.1;
unsigned int g_iIt_max_anirl = 40;
gsl_matrix* g_mActions = NULL; 
gsl_matrix* (*g_fPsi)(gsl_matrix*) = &psi;
gsl_matrix* (*g_fSimulator)(int) = &gridworld_simulator;
gsl_matrix* (*g_fS_0)(void) = &initial_state;
#+end_src

We train the expert, using LSPI fed with a large number of transitions.
#+begin_src c :tangle plot.c :main no
int main( void ){
  gsl_matrix* D = file2matrix( D_FILE_NAME, TRANS_WIDTH );
  g_mActions = file2matrix( ACTION_FILE, g_iA );
  gsl_matrix* omega_0 = gsl_matrix_calloc( g_iK, 1 );
  gsl_matrix* omega_expert = lspi( D, omega_0 );
  g_mOmega_E = omega_expert;
  expert_just_set();
#+end_src

The first plot is about the value of the different criteria during a run of the Monte-Carlo variant.
#+begin_src c :tangle plot.c :main no
  unsigned int M = 500;
  g_iNb_samples = D->size1;
  g_mOmega =  omega_expert;
  gsl_matrix* D_expert = gridworld_simulator( M );
  gsl_matrix* omega_imitation =
    proj_mc_lspi_ANIRL( D_expert, D, M );
  gsl_matrix_free( omega_imitation );
  gsl_matrix_free( D_expert );
#+end_src

We then, for some values of the number of samples available from the expert, run both the Monte-Carlo variant and the LSTD variant, and print their performance.
#+begin_src c :tangle plot.c :main no
  /*Courbes B & C : Performance de MC et LSTDmu*/
  M = 501; //To differentiate from above when greping.
  //See the Makefile
  int m_exp[] = {1,10,30,50,75,100,200};
  for( int i=0; i<7 ; i++ ){
    g_iNb_samples = 0;
    g_mOmega =  omega_expert;
    gsl_matrix* D_expert = gridworld_simulator( m_exp[i] );
    unsigned int nb_samples_exp = g_iNb_samples;
    gsl_matrix* omega_lstd = 
      proj_lstd_lspi_ANIRL( D_expert, D_expert );
    gsl_matrix_free( omega_lstd );
    printf("B %d %lf %lf %lf %lf\n", nb_samples_exp, 
	   g_dBest_t, g_dBest_error, 
	   g_dBest_true_error, g_dBest_diff );
    gsl_matrix* omega_imitation =
      proj_mc_lspi_ANIRL( D_expert, D, M );
    gsl_matrix_free( omega_imitation );
    gsl_matrix_free( D_expert );
    printf("C %d %lf %lf %lf %lf\n", nb_samples_exp, 
	   g_dBest_t, g_dBest_error, 
	   g_dBest_true_error, g_dBest_diff );
  }
  return 0;
}
#+end_src
