#+TITLE: GridWorld, SCIRL, Dégradé

Cette expérience s'inscrit dans un [[file:../Protocoles.org][protocole]] plus large.

L'expérience est un succès : la récompense est jolie, la fonction de valeur encore plus et surtout l'on a une longueur de trajectoire conforme à nos attentes.

On peut maintenant configurer SCIRL comme prévu par le protocole, à savoir en reprenant les valeurs des paramètres obtenues dans [[file:LAFEM_Exp1.org]].

    #+begin_src python :tangle SCIRL_Exp1.py
import sys
sys.path+=['..']
from a2str import *
from LAFEM import *
from DP import *
from DP_mu import *
import GridWorld

    #+end_src
    
      On définit ce qui est nécessaire au fonctionnement de LAFEM en sous classant la classe abstraite LAFEM
      #+begin_src python :tangle SCIRL_Exp1.py
class SCIRL_Exp1( LAFEM ):
    dicPi_E = {}
    A = GridWorld.A
    dicMu_E_s_only = {}

      #+end_src

      #+begin_src python :tangle SCIRL_Exp1.py

    def __init__( self ):
        D_E = genfromtxt(sys.argv[1])
        for trans in D_E:
            self.dicPi_E[l2str(trans[0:2])] = trans[2:3][0]
            self.data = self.data +[[ trans[0:2], trans[2:3][0]]]
      #+end_src      

      Le calcul de mu_E se fait d'après la technique de Monte-Carlo heuristique suggérée par Matthieu. Il s'agit pour les couples $(s,a)$ pour lesquels on possède des données d'un simple Monte-Carlo, et pour les couples $(s,a)$ où $a \neq \pi_E(s)$ de $\gamma \hat\mu_E(s,\pi_E(s))$.
FIXME:remonter cette méthode, et LSTDmu et les autres si elles sont assez générique dans la classe parente, sous un autre nom. Ainsi pour les utilser is suffira d'ecrire un truc du style =self.mu_E = self.mu_E_MC=.

      #+begin_src python :tangle SCIRL_Exp1.py
        dicMu_E_data = {}
        for start_index in range(0,len(D_E)):
            s = D_E[ start_index, 0:2 ]
            end_index = (i for i in range(start_index,len(D_E)) if D_E[i,2+1+2+1] == 0).next() #till next eoe
            data_MC = D_E[start_index:end_index+1,0:2]
            try:
                dicMu_E_data[l2str(s)].append(data_MC)
            except KeyError:
                dicMu_E_data[l2str(s)] = [data_MC]
        #Now dicMu_E_data contains the data that allows for the Monte-Carlo computation
        self.dicMu_E_s_only = {}
        for state in dicMu_E_data:
            gamma = 0.9
            lstMu_s = map( lambda traj: monte_carlo_mu( traj, 0.9, GridWorld.psi ), dicMu_E_data[state] )
            mu_s = mean( lstMu_s, 0 )
            self.dicMu_E_s_only[state] = mu_s

    def mu_E( self, s, a ):
        gamma = 0.9
        if self.dicPi_E[l2str(s)] == a:
            return self.dicMu_E_s_only[l2str(s)]
        else:
            return gamma*self.dicMu_E_s_only[l2str(s)]

      #+end_src      
    On définit la fonction de perte $l$ :
    #+begin_src python :tangle SCIRL_Exp1.py
    def l( self, s, a ):
        if self.dicPi_E[l2str(s)] == a:
            return 0
        else:
            return 1

    #+end_src
    
    
      #+begin_src python :tangle SCIRL_Exp1.py
    def alpha( self, t ):
        return 10./(t+1.)
    theta_0 = zeros( (25, 1) )
    #Threshold = 0.044
    Threshold = 0.0001
    T = 40
scirl = SCIRL_Exp1()
theta_scirl = scirl.run()
perf_agent = GridWorld.evaluate_theta( theta_scirl, GridWorld.psi )

print "%d\t%lf"%(len(scirl.data), perf_agent)

      #+end_src
#+srcname: SCIRL_Exp1_make
#+begin_src makefile
SCIRL_Exp1.py: SCIRL_Exp1.org
	$(call tangle,"SCIRL_Exp1.org")

SCIRL_Exp1: SCIRL_Exp1.py ../a2str.py ../LAFEM.py DE.py ../DP.py ../DP_mu.py V_Expert.mat
	for i in $(LM_VALUES); \
	do \
	python DE.py $$i > DE.mat; \
	python SCIRL_Exp1.py DE.mat >> SCIRL_Exp1.mat; \
	done

#+end_src


* Plotting
#+begin_src python :tangle SCIRL_Exp1_plot.py
from matplotlib import rc
rc('text', usetex=True)
import sys
sys.path+=['..']
from numpy import *
import scipy
import pylab as pylab
from Plot import *

D = genfromtxt( "SCIRL_Exp1.mat" )

myPlot = Plot()
Expert = 4.11057152*ones(XA.shape) #python Expert.py to get this value
myPlot.Random_mean = -1.5821833963484#See GridWorld.org about Random.py for information on these values
myPlot.Random_min = -4.0007295890199996#python Random.py to get this value
myPlot.Random_max = 2.7064859345599999#python Random.py to get this value
myPlot.Random_var = 1.4465398450419833#python Random.py to get this value
myPlot.y_max = 9.5 #Comme ca l'expert peut respirer
myPlot.y_min =myPlot.Random_min - 0.2

myPlot.plot( D, 'red', 'SCIRL_Exp1_fig1.pdf' )


#+end_src

#+srcname: SCIRL_Exp1_make
#+begin_src makefile
SCIRL_Exp1_plot.py: SCIRL_Exp1.org
	$(call tangle,"SCIRL_Exp1.org")

SCIRL_Exp1_fig1.pdf: SCIRL_Exp1_plot.py SCIRL_Exp1.mat ../Plot.py
	python SCIRL_Exp1_plot.py

#+end_src



  #+srcname: SCIRL_Exp1_clean_make
  #+begin_src makefile
SCIRL_Exp1_clean:
	find . -maxdepth 1 -iname "SCIRL_Exp1.py"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "SCIRL_Exp1.tex"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "SCIRL_Exp1_*"   | xargs $(XARGS_OPT) rm
  #+end_src

* Old plots, should be put in working order again soon

Maintenant on peut optimiser cette récompense et regarder ce que ça donne d'un point de vue graphique (tracé de V) :

     #+begin_src python :tangle SCIRL_Exp1_results.py
import sys
sys.path+=['..']
from DP import *
from Pi2txt import *

R = genfromtxt( "SCIRL_Exp1_theta.mat" )
P_north = genfromtxt( "TT_5x5_PENorth.mat" )
P_east = genfromtxt( "TT_5x5_PEEast.mat" )
P_west = genfromtxt( "TT_5x5_PEWest.mat" )
P_south = genfromtxt( "TT_5x5_PESouth.mat" )
Ppi = DP_txt( R, (P_north, P_south, P_west, P_east), "SCIRL_Exp1_V.mat" )

print "Politique de l'agent : "
print Pi2Asciiart( Ppi )
V_agent = genfromtxt("SCIRL_Exp1_V.mat")


f = open( "SCIRL_Exp1_V.txt", "w" )

for y in range(0,5):
    for x in range(0,5):
        index = x+5*y
        f.write( "%d %d %e\n"%(x,y,V_agent[index]) )
    f.write("\n")
f.close()

f = open( "SCIRL_Exp1_R.txt", "w" )
for y in range(0,5):
    for x in range(0,5):
        index = x+5*y
        f.write( "%d %d %e\n"%(x,y,R[index]) )
    f.write("\n")
f.close()


     #+end_src
#+begin_src gnuplot :tangle SCIRL_Exp1_V.gp
set pm3d
set output "SCIRL_Exp1_V.ps"
set term postscript enhanced color
set view 61,254
splot "SCIRL_Exp1_V.txt"
#+end_src

#+begin_src gnuplot :tangle SCIRL_Exp1_R.gp
set pm3d
set output "SCIRL_Exp1_R.ps"
set term postscript enhanced color
set view 61,254
splot "SCIRL_Exp1_R.txt"
#+end_src

#+srcname: SCIRL_Exp1_make
#+begin_src makefile
SCIRL_Exp1_V.txt: SCIRL_Exp1_results.py SCIRL_Exp1_theta.mat TT_5x5_PENorth.mat TT_5x5_PESouth.mat TT_5x5_PEWest.mat TT_5x5_PEEast.mat
	python SCIRL_Exp1_results.py
SCIRL_Exp1_R.txt: SCIRL_Exp1_results.py SCIRL_Exp1_theta.mat TT_5x5_PENorth.mat TT_5x5_PESouth.mat TT_5x5_PEWest.mat TT_5x5_PEEast.mat
	python SCIRL_Exp1_results.py

SCIRL_Exp1_V.pdf: SCIRL_Exp1_V.gp SCIRL_Exp1_V.txt
	gnuplot SCIRL_Exp1_V.gp
	ps2pdf SCIRL_Exp1_V.ps
	rm SCIRL_Exp1_V.ps

SCIRL_Exp1_R.pdf: SCIRL_Exp1_R.gp SCIRL_Exp1_R.txt
	gnuplot SCIRL_Exp1_R.gp
	ps2pdf SCIRL_Exp1_R.ps
	rm SCIRL_Exp1_R.ps

#+end_src


