#+TITLE: GridWorld, SCIRL, Dégradé

Cette expérience s'inscrit dans un [[file:../Protocoles.org][protocole]] plus large.

L'expérience est un succès : la récompense est jolie, la fonction de valeur encore plus et surtout l'on a une longueur de trajectoire conforme à nos attentes.

On peut maintenant configurer SCIRL comme prévu par le protocole, à savoir en reprenant les valeurs des paramètres obtenues dans [[file:LAFEM_Exp1.org]].

    #+begin_src python :tangle SCIRL_Exp1.py
import sys
sys.path+=['..']
from a2str import *
from LAFEM import *

#We had to debug a floating point error
#def err_handler(type, flag):
#    print "Floating point error (%s), with flag %s" % (type, flag)
#    import pdb
#    pdb.set_trace()
#seterrcall( err_handler )
#seterr( all='call' )


    #+end_src
    
      On définit ce qui est nécessaire au fonctionnement de LAFEM en sous classant la classe abstraite LAFEM
      #+begin_src python :tangle SCIRL_Exp1.py
class SCIRL_Exp1( LAFEM ):
    dicPi_E = {}

      #+end_src

      On définit $S$ et $A$ de manière à pouvoir itérer dessus.
    #+begin_src python :tangle SCIRL_Exp1.py
    def Sgenerator( self ):
        for x in range(0,5):
            for y in range(0,5):
                yield array([x,y])

    S = Sgenerator
    A = [1,2,3,4]
    #+end_src
      #+begin_src python :tangle SCIRL_Exp1.py
    dicMu_E_s_only = {}

    def psi( self, s ):
        answer = zeros((25,1))
        x = s[0]
        y = s[1]
        index = y*5 + x
        answer[index] = 1.
        return answer

    def __init__( self ):
        D_E = genfromtxt("ANIRL_Exp3_D_E.mat")
        for trans in D_E:
            self.dicPi_E[l2str(trans[0:2])] = trans[2:3][0]
            self.data = self.data +[[ trans[0:2], trans[2:3][0]]]
      #+end_src      

      Le calcul de mu_E se fait d'après la technique de Monte-Carlo heuristique suggérée par Matthieu. Il s'agit pour les couples $(s,a)$ pour lesquels on possède des données d'un simple Monte-Carlo, et pour les couples $(s,a)$ où $a \neq \pi_E(s)$ de $\gamma \hat\mu_E(s,\pi_E(s))$.
FIXME:remonter cette méthode, et LSTDmu et les autres si elles sont assez générique dans la classe parente, sous un autre nom. Ainsi pour les utilser is suffira d'ecrire un truc du style =self.mu_E = self.mu_E_MC=.

      #+begin_src python :tangle SCIRL_Exp1.py
        dicMu_E_data = {}
        for start_index in range(0,len(D_E)):
            trans = D_E[start_index,:]
            s = trans[0:2]
            a = trans[2:3][0]

            #import pdb
            #          pdb.set_trace()
            end_index = start_index
            while D_E[end_index,2+1+2+1] != 0.: #eoe
                end_index+=1
            data_MC = D_E[start_index:end_index+1,0:2]
            
            mu_struct = []
            try:
                mu_struct = dicMu_E_data[l2str(s)]
            except KeyError:
                pass
            mu_struct.append(data_MC)
            dicMu_E_data[l2str(s)] = mu_struct
        #Now dicMu_E_data contains the data that allows for the Monte-Carlo computation
        self.dicMu_E_s_only = {}
        for state in dicMu_E_data:
            nb = 0.
            gamma = 0.9
            mu_s = zeros((25,1))
            for traj in dicMu_E_data[state]:
                nb+=1.
                i = 0
                for s in traj:
                    i+=1.
                    mu_s += pow( gamma, i )*self.psi( s )
            mu_s /= nb
            self.dicMu_E_s_only[state] = mu_s

    def mu_E( self, s, a ):
        gamma = 0.9
        if self.dicPi_E[l2str(s)] == a:
            return self.dicMu_E_s_only[l2str(s)]
        else:
            return gamma*self.dicMu_E_s_only[l2str(s)]

      #+end_src      
    On définit la fonction de perte $l$ :
    #+begin_src python :tangle SCIRL_Exp1.py
    def l( self, s, a ):
        if self.dicPi_E[l2str(s)] == a:
            return 0
        else:
            return 1

    #+end_src
    
    
      #+begin_src python :tangle SCIRL_Exp1.py
    def alpha( self, t ):
        return 10./(t+1.)
    theta_0 = zeros( (25, 1) )
    Threshold = 0.044
    T = 40
scirl = SCIRL_Exp1()
theta_scirl = scirl.run()
print a2str(theta_scirl)

      #+end_src
#+srcname: SCIRL_Exp1_make
#+begin_src makefile
SCIRL_Exp1.py: SCIRL_Exp1.org
	$(call tangle,"SCIRL_Exp1.org")

SCIRL_Exp1_theta.mat: SCIRL_Exp1.py ../a2str.py ../LAFEM.py ANIRL_Exp3_D_E.mat
	python SCIRL_Exp1.py > SCIRL_Exp1_theta.mat

#+end_src

Maintenant on peut optimiser cette récompense et regarder ce que ça donne d'un point de vue graphique (tracé de V) :

     #+begin_src python :tangle SCIRL_Exp1_results.py
import sys
sys.path+=['..']
from DP import *
from Pi2txt import *

R = genfromtxt( "SCIRL_Exp1_theta.mat" )
P_north = genfromtxt( "TT_5x5_PENorth.mat" )
P_east = genfromtxt( "TT_5x5_PEEast.mat" )
P_west = genfromtxt( "TT_5x5_PEWest.mat" )
P_south = genfromtxt( "TT_5x5_PESouth.mat" )
Ppi = DP_txt( R, (P_north, P_south, P_west, P_east), "SCIRL_Exp1_V.mat" )

print "Politique de l'agent : "
print Pi2Asciiart( Ppi )
V_agent = genfromtxt("SCIRL_Exp1_V.mat")


f = open( "SCIRL_Exp1_V.txt", "w" )

for y in range(0,5):
    for x in range(0,5):
        index = x+5*y
        f.write( "%d %d %e\n"%(x,y,V_agent[index]) )
    f.write("\n")
f.close()

f = open( "SCIRL_Exp1_R.txt", "w" )
for y in range(0,5):
    for x in range(0,5):
        index = x+5*y
        f.write( "%d %d %e\n"%(x,y,R[index]) )
    f.write("\n")
f.close()


     #+end_src
#+begin_src gnuplot :tangle SCIRL_Exp1_V.gp
set pm3d
set output "SCIRL_Exp1_V.ps"
set term postscript enhanced color
set view 61,254
splot "SCIRL_Exp1_V.txt"
#+end_src

#+begin_src gnuplot :tangle SCIRL_Exp1_R.gp
set pm3d
set output "SCIRL_Exp1_R.ps"
set term postscript enhanced color
set view 61,254
splot "SCIRL_Exp1_R.txt"
#+end_src

#+srcname: SCIRL_Exp1_make
#+begin_src makefile
SCIRL_Exp1_V.txt: SCIRL_Exp1_results.py SCIRL_Exp1_theta.mat TT_5x5_PENorth.mat TT_5x5_PESouth.mat TT_5x5_PEWest.mat TT_5x5_PEEast.mat
	python SCIRL_Exp1_results.py
SCIRL_Exp1_R.txt: SCIRL_Exp1_results.py SCIRL_Exp1_theta.mat TT_5x5_PENorth.mat TT_5x5_PESouth.mat TT_5x5_PEWest.mat TT_5x5_PEEast.mat
	python SCIRL_Exp1_results.py

SCIRL_Exp1_V.pdf: SCIRL_Exp1_V.gp SCIRL_Exp1_V.txt
	gnuplot SCIRL_Exp1_V.gp
	ps2pdf SCIRL_Exp1_V.ps
	rm SCIRL_Exp1_V.ps

SCIRL_Exp1_R.pdf: SCIRL_Exp1_R.gp SCIRL_Exp1_R.txt
	gnuplot SCIRL_Exp1_R.gp
	ps2pdf SCIRL_Exp1_R.ps
	rm SCIRL_Exp1_R.ps

#+end_src

Ainsi que d'un point de vue de la longueur des trajectoires :
#+begin_src c :tangle SCIRL_Exp1.c :main no

#define _POSIX_C_SOURCE 1
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_blas.h>
#include <math.h>
#include "GridWorld.h"
#include "simulator.h"
#include "utils.h"
#include "greedy.h"
#include "phipsi.h"

#include "RL_Globals.h"
#include "IRL_Globals.h"
#define TRANS_WIDTH 7
#define ACTION_FILE "actions.mat"

unsigned int g_iS = 2;
unsigned int g_iA = 1;
gsl_matrix* (*g_fPhi)(gsl_matrix*) = &phi;
gsl_matrix* g_mOmega = NULL;
gsl_matrix* g_mActions = NULL; 
gsl_matrix* (*g_fPsi)(gsl_matrix*) = &psi;



int main( void ){
  g_mActions = file2matrix( ACTION_FILE, g_iA );
  gsl_matrix* omega_agent = file2matrix( "SCIRL_Exp1_omega.mat", 1 );
  g_mOmega = omega_agent;
  gsl_matrix* D_agent = gridworld_simulator( 1000 );
  printf("Longueur moyenne du run de l'agent : %f\n",((double)(D_agent->size1))/1000.);
  return 0;
}

#+end_src

#+srcname: SCIRL_Exp1_make
#+begin_src makefile
SCIRL_Exp1.c: SCIRL_Exp1.org
	$(call tangle,"SCIRL_Exp1.org")
SCIRL_Exp1.o: SCIRL_Exp1.c GridWorld.h ../greedy.h ../RL_Globals.h ../utils.h  phipsi.h simulator.h ../LSTDmu.h ../IRL_Globals.h ../ANIRL.h ../LSPI.h
	$(call c2obj,"SCIRL_Exp1.c")
#FIXME: On ne devrait pas avoir à lier avec criteria.o ou abbeel2004apprenticeship.o
SCIRL_Exp1.exe: SCIRL_Exp1.o ../greedy.o ../utils.o  phipsi.o simulator.o
	$(O2EXE) -o SCIRL_Exp1.exe SCIRL_Exp1.o ../greedy.o ../utils.o  phipsi.o simulator.o

SCIRL_Exp1_omega.mat: R2omega.py SCIRL_Exp1_theta.mat Pi2txt.py
	mv SCIRL_Exp1_theta.mat ANIRL_Exp2_R.mat #FIXME: Rendre R2omega plus générique pour ne plus avoir à faire ça
	python R2omega.py
	mv ANIRL_Exp2_R.mat SCIRL_Exp1_theta.mat
	mv ANIRL_Exp2_omega.mat SCIRL_Exp1_omega.mat

SCIRL_Exp1: SCIRL_Exp1.exe SCIRL_Exp1_omega.mat SCIRL_Exp1_R.pdf SCIRL_Exp1_V.pdf
	./SCIRL_Exp1.exe

#+end_src


  #+srcname: SCIRL_Exp1_clean_make
  #+begin_src makefile
SCIRL_Exp1_clean:
	find . -maxdepth 1 -iname "SCIRL_Exp1.h"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "SCIRL_Exp1.c"   | xargs $(XARGS_OPT) rm 
	find . -maxdepth 1 -iname "SCIRL_Exp1.o"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "SCIRL_Exp1.exe"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "SCIRL_Exp1.tex"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "SCIRL_Exp1*.pdf"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "SCIRL_Exp1*.ps"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "SCIRL_Exp1*.gp"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "SCIRL_Exp1*.txt"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "SCIRL_Exp1*.py"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "SCIRL_Exp1_*.mat"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "SCIRL_Exp1_LSTDmu*"   | xargs $(XARGS_OPT) rm
  #+end_src
