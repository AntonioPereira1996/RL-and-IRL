#+TITLE:LSTDQ
  LSTDQ is an off-policy approximator for the Q function based 
  on LSTD (\cite{bertsekas1996temporal}) introduced in 
  \cite{lagoudakis2003least}.
* C implementation
** Externals
    The C implementation follows quite closely the pseudo code given in \cite{lagoudakis2003least}.
    
    Some part of the behaviour are driven via [[file:RL_Globals.org][global variables]].

    It takes the form of a C function :
#+begin_src c :tangle LSTDQ.h :main no
gsl_matrix* lstd_q( gsl_matrix* D, 
		    gsl_matrix* (*pi)(gsl_matrix*) );
#+end_src

    The $D$ matrix is the sample source. One transition per line, each line being of the form
    $[s_0, ..., s_{n_s},a_0, ... ,a_{n_a},s'_0,...,s'_{n_s},r,eoe]$.
    where $r$ is the reward and $eoe$ is a flag set to 0 if this transition if the last of the 
    episode and to 1 if not.

** Internals
    We use the GSL.
    
#+begin_src c :tangle LSTDQ.c :main no
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_blas.h>
#include <gsl/gsl_permutation.h>
#include <gsl/gsl_linalg.h>
#include "RL_Globals.h"
#+end_src

    
#+begin_src c :tangle LSTDQ.c :main no
gsl_matrix* lstd_q( gsl_matrix* D, 
		    gsl_matrix* (*pi)(gsl_matrix*) ){
#+end_src
  - $\tilde A \leftarrow 0$
#+begin_src c :tangle LSTDQ.c :main no
  gsl_matrix* A = gsl_matrix_calloc( g_iK, g_iK );
#+end_src
  - $\tilde b \leftarrow 0$
#+begin_src c :tangle LSTDQ.c :main no
  gsl_matrix* b = gsl_matrix_calloc( g_iK, 1 );
#+end_src
  - for each $(s,a,s',r,eoe) \in D$
#+begin_src c :tangle LSTDQ.c :main no
  for( unsigned int i=0; i < D->size1 ; i++ ){
#+end_src
     - $\tilde A \leftarrow \tilde A + \phi(s,a)\left(\phi(s,a) - \gamma \phi(s',\pi(s'))\right)^T$
#+begin_src c :tangle LSTDQ.c :main no
     gsl_matrix_view sa = 
       gsl_matrix_submatrix( D, i, 0, 1, g_iS+g_iA );
     gsl_matrix* phi_sa = g_fPhi( &sa.matrix );
     gsl_matrix* sa_dash = gsl_matrix_alloc( 1, g_iS+g_iA );
     gsl_matrix_view sdash_dst = 
       gsl_matrix_submatrix( sa_dash, 0, 0, 1, g_iS );
     gsl_matrix_view sdash_src = 
       gsl_matrix_submatrix( D, i, g_iS+g_iA, 1, g_iS );
     gsl_matrix_memcpy( &sdash_dst.matrix, &sdash_src.matrix );
     gsl_matrix_view adash_dst = 
       gsl_matrix_submatrix( sa_dash, 0, g_iS, 1, g_iA );
     gsl_matrix* adash_src = pi( &sdash_src.matrix );
     gsl_matrix_memcpy( &adash_dst.matrix, adash_src );
     gsl_matrix* phi_dash = g_fPhi( sa_dash );
     gsl_matrix_scale( phi_dash, g_dGamma_lstdq );
     double eoe = gsl_matrix_get( D, i, g_iS+g_iA+g_iS+1 );
     gsl_matrix_scale( phi_dash, eoe );
     gsl_matrix* delta_phi = gsl_matrix_calloc( g_iK, 1 );
     gsl_matrix_memcpy( delta_phi, phi_sa );
     gsl_matrix_sub( delta_phi, phi_dash );
     gsl_matrix* deltaA = gsl_matrix_calloc( g_iK, g_iK );
     gsl_blas_dgemm( CblasNoTrans, CblasTrans, 1., 
		       phi_sa, delta_phi, 0., deltaA);
     gsl_matrix_add( A, deltaA );
 #+end_src
     - $\tilde b \leftarrow \tilde b + \phi(s,a)r$
 #+begin_src c :tangle LSTDQ.c :main no
     double r = gsl_matrix_get( D, i, g_iS+g_iA+g_iS );
     gsl_matrix_scale( phi_sa, r ); //phi_sa is now delta_b
     gsl_matrix_add( b, phi_sa );
     gsl_matrix_free( deltaA );
     gsl_matrix_free( delta_phi );
     gsl_matrix_free( phi_dash );
     gsl_matrix_free( adash_src );
     gsl_matrix_free( sa_dash );
     gsl_matrix_free( phi_sa );
   }
 #+end_src
  - $\tilde \omega^\pi \leftarrow (\tilde A + \lambda Id) ^{-1}\tilde b$
#+begin_src c :tangle LSTDQ.c :main no
  gsl_matrix* lambdaI = gsl_matrix_alloc( A->size1, A->size2 );
  gsl_matrix_set_identity( lambdaI );
  gsl_matrix_scale( lambdaI, g_dLambda_lstdQ );
  gsl_matrix_add( A, lambdaI );
  gsl_matrix_free( lambdaI );
  gsl_vector_view b_v = gsl_matrix_column( b, 0 );
  gsl_matrix* omega_pi = gsl_matrix_alloc( g_iK, 1 );
  gsl_vector_view o_v = gsl_matrix_column( omega_pi, 0 );
  gsl_permutation* p = gsl_permutation_alloc( g_iK );
  int signum;
  gsl_linalg_LU_decomp( A, p, &signum );
  gsl_linalg_LU_solve( A, p, &b_v.vector, &o_v.vector );
  gsl_matrix_free( A );
  gsl_matrix_free( b );
  gsl_permutation_free( p );
#+end_src
    - return $\tilde \omega_\pi$
#+begin_src c :tangle LSTDQ.c :main no
  return omega_pi;
}
#+end_src

** Makefile rules
   Some rules to tangle the source files :
  #+srcname: LSTDQ_code_make
  #+begin_src makefile
LSTDQ.c: LSTDQ.org 
	$(call tangle,"LSTDQ.org")

LSTDQ.h: LSTDQ.org
	$(call tangle,"LSTDQ.org")
  #+end_src

   A rule to create the object file :
  #+srcname: LSTDQ_c2o_make
  #+begin_src makefile
LSTDQ.o: LSTDQ.c LSTDQ.h RL_Globals.h
	$(call c2obj,"LSTDQ.c")
  #+end_src

   A rule to clean the mess :
  #+srcname: LSTDQ_clean_make
  #+begin_src makefile
LSTDQ_clean:
	find . -maxdepth 1 -iname "LSTDQ.h"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "LSTDQ.c"   | xargs $(XARGS_OPT) rm 
	find . -maxdepth 1 -iname "LSTDQ.o"   | xargs $(XARGS_OPT) rm
  #+end_src
