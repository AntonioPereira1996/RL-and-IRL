#+TITLE:Relative Entropy IRL

Le code ci dssous, pillé dans ce que m'a fourni Senthil, implémente l'algorithme d'IRL à base d'entropie relative de Boularias : \cite{boularias2011relative}.

#+begin_src c :main no :tangle RelativeEntropy.h
/*
 * Copyright: Supelec - IMS Research group, Metz - France
 *
 * 24th Feb 2012
 * 
 * Author: Senthilkumar Chandramohan, Matthieu Geist & Olivier Pietquin
 *
 * Note: Relative Entropy IRL based User Simulation
 *
 */
  
 extern gsl_vector* theta; //Tabular reward over state-action space
 extern gsl_vector* delta_theta; //update of the gradient descent
 extern gsl_vector* uniform_feature;//used to iterate over uniform_matrix
 extern gsl_vector* tmp_uniform_feature;//same same but different
 extern unsigned int NoEpisodes;//number of episodes from the uniform policy
 extern gsl_matrix* uniform_matrix;//feature expectation for every episode from the uniform policy, one mu vector per line (matrix is NoEpisode \times g_iK)
 extern unsigned int Acount; //Cardinal of action space
 extern gsl_vector* dlength; //dlength at i is the length of episode i
 extern gsl_vector* scalar_value; //temp buffer fur summation
 extern gsl_vector* expert_feature; //mu_E, feature expectation of the expert
 extern unsigned int NoSteps;//Max number of iterations
 extern double Eta;//Algo parameter (\epsilon_i in the paper)
 extern double Alpha;//Algo parameter (\alpha_i in the paper)
 extern double Convergence;//Stop criterion for the algorithm
 
void gradientDescent();
void populateUniformMatrix( char* filename );
void populateExpertFeature( char* filename );

#+end_src


#+begin_src c :main no :tangle RelativeEntropy.c
/*
 * Copyright: Supelec - IMS Research group, Metz - France
 *
 * 24th Feb 2012
 * 
 * Author: Senthilkumar Chandramohan, Matthieu Geist & Olivier Pietquin
 *
 * Note: Relative Entropy IRL based User Simulation
 *
 */
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_vector.h>   
#include <gsl/gsl_blas.h>
#include <math.h>
#include "RelativeEntropy.h"
#include "RL_Globals.h"
#include "IRL_Globals.h"
#include "utils.h"

void relativeEntropy(){

	double dotproduct = 0.0;
	double denaminator = 0.0;
	
	gsl_vector_set_zero(delta_theta);
	gsl_vector_set_zero(uniform_feature);
	gsl_vector_set_zero(tmp_uniform_feature);
	//Normalizing theta to avoid numerical explosion
	//if( gsl_blas_dnrm2( theta ) != 0. )
	//  gsl_vector_scale( theta, gsl_blas_dnrm2( theta ) );
		
	for(int i = 0; i < NoEpisodes; i++){
	
		//Computing exp(theta . feature_trajectory)/pi(a/s)_trajectory
		gsl_matrix_get_row(uniform_feature, uniform_matrix, i);
		gsl_blas_ddot(theta, uniform_feature, &dotproduct);
		gsl_vector_set(scalar_value, i, exp(dotproduct)*pow(Acount, gsl_vector_get(dlength,i)));
		
		//Scaling each feature_trajectory & summing scaled feature trajectories
		gsl_vector_scale(uniform_feature, gsl_vector_get(scalar_value, i));
		gsl_vector_add(tmp_uniform_feature, uniform_feature);	
	}	
	
	//Denaminator
	for(int i = 0; i < NoEpisodes; i++){
		denaminator = denaminator + gsl_vector_get(scalar_value, i);
	}
	
	//Computing the final feature vector of the uniform_policy
	gsl_vector_memcpy(uniform_feature, tmp_uniform_feature);
	gsl_vector_scale(uniform_feature, 1.0/denaminator);
	
	//Computing delta_theta
	gsl_vector_memcpy(delta_theta, expert_feature);
	gsl_vector_sub(delta_theta, uniform_feature);
	for(int i = 0; i < g_iK; i++){
    	double toto = gsl_vector_get(delta_theta, i);
		if(gsl_vector_get(theta, i) >= 0)
			gsl_vector_set(delta_theta, i, toto - Eta);	
		else
			gsl_vector_set(delta_theta, i, toto + Eta);	
	}
	
}
 
void gradientDescent(){

	gsl_vector_set_all(theta, 0.);
	gsl_vector_set_zero(delta_theta);

	double change = 0.0;
	int nonZero = 0;
	
	for(int i = 1; i < NoSteps; i++){
	
		relativeEntropy();
		
		change = 0.0;
		nonZero = 0;
		for(int j = 0; j < g_iK; j++){
			change = change + (gsl_vector_get(delta_theta, j))*(gsl_vector_get(delta_theta, j));
			if(gsl_vector_get(delta_theta, j) != 0.)
				nonZero++;
		}
		
		fprintf( stderr, "%d NonZeroCount: %d : ChangeMargin: %f \n",i,nonZero,sqrt(change));
		gsl_vector_scale(delta_theta, 0.1); //FIXME put alpha
		if( change != 0.)
		  gsl_vector_scale(delta_theta, 1.0/sqrt(change));
		gsl_vector_add(theta, delta_theta);
				
		if(sqrt(change) <= Convergence)
			break;
		
	}
		
}

//Fills in the proper global variables from the provided datafile
//Expected format in the datafile is one transition per line, 
//in a (s a s' r eoe) form, with eoe==0 meaning end of episode
void populateUniformMatrix( char* filename ){
  //First pass to construct one mu vector per episode
  gsl_matrix* D = file2matrix( filename, g_iS+g_iA+g_iS+1+1 );
  gsl_matrix* mu = gsl_matrix_calloc( g_iK, 1 );
  gsl_matrix** all_mus = malloc( D->size1 * sizeof( *all_mus ) ); //Larger than necessary table to store the feature expectation of each episode
  int* all_lengths = malloc( D->size1 * sizeof( *all_lengths ) ); //Larger than necessary table to store the length of each episode
  double t = 0;
  NoEpisodes = 0;
  gsl_matrix_view EOEs = 
    gsl_matrix_submatrix( D, 0, D->size2-1, D->size1, 1 ); 
  for( unsigned int i=0; i < D->size1 ; i++ ){
    gsl_matrix_view sa = gsl_matrix_submatrix( D, i, 0, 
					      1, g_iS+g_iA );
    gsl_matrix* delta_mu = g_fPhi( &sa.matrix );
    double gamma_t = pow( g_dGamma_anirl, t );
    gsl_matrix_scale( delta_mu, gamma_t );
    gsl_matrix_add( mu, delta_mu );
    gsl_matrix_free( delta_mu );
    int eoe = (int)gsl_matrix_get( &EOEs.matrix, i, 0 );
    if( eoe == 0 ){ //End of episode
      all_mus[ NoEpisodes ] = mu;
      mu = gsl_matrix_calloc( g_iK, 1 );
      all_lengths[ NoEpisodes ] = t;
      t = 0;
      NoEpisodes++;
    }else{
      t++;
    }
  }
  //second pass to concatenate all feature expectations in uniform_matrix and all lengths in dlength
  uniform_matrix = gsl_matrix_alloc( NoEpisodes, g_iK );
  dlength = gsl_vector_alloc( NoEpisodes );
  for( int i = 0; i<NoEpisodes; i++ ){
    gsl_matrix_view dest = gsl_matrix_submatrix( uniform_matrix, i, 0, 1, g_iK );
    gsl_matrix_transpose_memcpy( &dest.matrix, all_mus[ i ] );
    gsl_matrix_free( all_mus[ i ] );
    gsl_vector_set( dlength, i, all_lengths[ i ]);
  }
  free( all_mus );
  free( all_lengths );
  scalar_value = gsl_vector_calloc( NoEpisodes );
}


void populateExpertFeature( char* filename ){
  gsl_matrix* D = file2matrix( filename, g_iS+g_iA+g_iS+1+1 );
  expert_feature = gsl_vector_calloc( g_iK );
  gsl_matrix* src = gsl_matrix_calloc( g_iK, 1 );
  double t = 0;
  unsigned int nb_traj = 0;
  gsl_matrix_view EOEs = 
    gsl_matrix_submatrix( D, 0, D->size2-1, D->size1, 1 ); 
  for( unsigned int i=0; i < D->size1 ; i++ ){
    gsl_matrix_view sa = gsl_matrix_submatrix( D, i, 0, 
					      1, g_iS+g_iA );
    gsl_matrix* delta_mu = g_fPhi( &sa.matrix );
    double gamma_t = pow( g_dGamma_anirl, t );
    gsl_matrix_scale( delta_mu, gamma_t );
    gsl_matrix_add( src, delta_mu );
    gsl_matrix_free( delta_mu );
    int eoe = (int)gsl_matrix_get( &EOEs.matrix, i, 0 );
    if( eoe == 0 ){ //End of episode
      t = 0;
      nb_traj++;
    }else{
      t++;
    }
  }
  gsl_matrix_scale( src, 1./(double)nb_traj );
  for( int i = 0; i<g_iK;i++ ){
    gsl_vector_set( expert_feature, i, gsl_matrix_get( src, i, 0 ));
    //fprintf( stderr, "%e\n", gsl_matrix_get( src, i, 0 ) );
  }
  
}

#+end_src

   #+srcname: RelativeEntropy_make
  #+begin_src makefile
RelativeEntropy.c: RelativeEntropy.org 
	$(call tangle,"RelativeEntropy.org")

RelativeEntropy.h: RelativeEntropy.org 
	$(call tangle,"RelativeEntropy.org")

RelativeEntropy.o: RelativeEntropy.c RelativeEntropy.h utils.h
	$(call c2obj,"RelativeEntropy.c")
  #+end_src
  #+srcname: RelativeEntropy_clean_make
  #+begin_src makefile
RelativeEntropy_clean:
	find . -maxdepth 1 -iname "RelativeEntropy.h"   | xargs $(XARGS_OPT) rm
	find . -maxdepth 1 -iname "RelativeEntropy.c"   | xargs $(XARGS_OPT) rm 
	find . -maxdepth 1 -iname "RelativeEntropy.o"   | xargs $(XARGS_OPT) rm
  #+end_src
